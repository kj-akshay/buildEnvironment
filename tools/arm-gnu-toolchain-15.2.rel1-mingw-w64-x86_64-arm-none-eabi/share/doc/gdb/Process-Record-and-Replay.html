<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- Copyright Â© 1988-2024 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Free Software" and "Free Software Needs
Free Documentation", with the Front-Cover Texts being "A GNU Manual,"
and with the Back-Cover Texts as in (a) below.

(a) The FSF's Back-Cover Text is: "You are free to copy and modify
this GNU Manual.  Buying copies from GNU Press supports the FSF in
developing GNU and promoting software freedom." -->
<title>Process Record and Replay (Debugging with GDB)</title>

<meta name="description" content="Process Record and Replay (Debugging with GDB)">
<meta name="keywords" content="Process Record and Replay (Debugging with GDB)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Concept-Index.html" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="index.html" rel="up" title="Top">
<link href="Stack.html" rel="next" title="Stack">
<link href="Reverse-Execution.html" rel="prev" title="Reverse Execution">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
kbd.kbd {font-style: oblique}
span:hover a.copiable-link {visibility: visible}
ul.mark-bullet {list-style-type: disc}
-->
</style>


</head>

<body lang="en">
<div class="chapter-level-extent" id="Process-Record-and-Replay">
<div class="nav-panel">
<p>
Next: <a href="Stack.html" accesskey="n" rel="next">Examining the Stack</a>, Previous: <a href="Reverse-Execution.html" accesskey="p" rel="prev">Running programs backward</a>, Up: <a href="index.html" accesskey="u" rel="up">Debugging with <small class="sc">GDB</small></a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h2 class="chapter" id="Recording-Inferior_0027s-Execution-and-Replaying-It"><span>7 Recording Inferior&rsquo;s Execution and Replaying It<a class="copiable-link" href="#Recording-Inferior_0027s-Execution-and-Replaying-It"> &para;</a></span></h2>
<a class="index-entry-id" id="index-process-record-and-replay"></a>
<a class="index-entry-id" id="index-recording-inferior_0027s-execution-and-replaying-it"></a>

<p>On some platforms, <small class="sc">GDB</small> provides a special <em class="dfn">process record
and replay</em> target that can record a log of the process execution, and
replay it later with both forward and reverse execution commands.
</p>
<a class="index-entry-id" id="index-replay-mode"></a>
<p>When this target is in use, if the execution log includes the record
for the next instruction, <small class="sc">GDB</small> will debug in <em class="dfn">replay
mode</em>.  In the replay mode, the inferior does not really execute code
instructions.  Instead, all the events that normally happen during
code execution are taken from the execution log.  While code is not
really executed in replay mode, the values of registers (including the
program counter register) and the memory of the inferior are still
changed as they normally would.  Their contents are taken from the
execution log.
</p>
<a class="index-entry-id" id="index-record-mode"></a>
<p>If the record for the next instruction is not in the execution log,
<small class="sc">GDB</small> will debug in <em class="dfn">record mode</em>.  In this mode, the
inferior executes normally, and <small class="sc">GDB</small> records the execution log
for future replay.
</p>
<p>The process record and replay target supports reverse execution
(see <a class="pxref" href="Reverse-Execution.html">Running programs backward</a>), even if the platform on which the
inferior runs does not.  However, the reverse execution is limited in
this case by the range of the instructions recorded in the execution
log.  In other words, reverse execution on platforms that don&rsquo;t
support it directly can only be done in the replay mode.
</p>
<p>When debugging in the reverse direction, <small class="sc">GDB</small> will work in
replay mode as long as the execution log includes the record for the
previous instruction; otherwise, it will work in record mode, if the
platform supports reverse execution, or stop if not.
</p>
<p>Currently, process record and replay is supported on ARM, Aarch64,
LoongArch, Moxie, PowerPC, PowerPC64, S/390, and x86 (i386/amd64) running
GNU/Linux.  Process record and replay can be used both when native
debugging, and when remote debugging via <code class="code">gdbserver</code>.
</p>
<p>When recording an inferior, <small class="sc">GDB</small> may print auxiliary information
during stepping commands and commands displaying the execution history.
</p>
<p>For architecture environments that support process record and replay,
<small class="sc">GDB</small> provides the following commands:
</p>
<dl class="table">
<dt><a class="index-entry-id" id="index-target-record_002dfull"></a>
<a class="index-entry-id" id="index-target-record_002dbtrace"></a>
<a class="index-entry-id" id="index-record"></a>
<a class="index-entry-id" id="index-record-full"></a>
<a class="index-entry-id" id="index-record-btrace"></a>
<a class="index-entry-id" id="index-record-btrace-bts"></a>
<a class="index-entry-id" id="index-record-btrace-pt"></a>
<a class="index-entry-id" id="index-record-bts"></a>
<a class="index-entry-id" id="index-record-pt"></a>
<a class="index-entry-id" id="index-rec"></a>
<a class="index-entry-id" id="index-rec-full"></a>
<a class="index-entry-id" id="index-rec-btrace"></a>
<a class="index-entry-id" id="index-rec-btrace-bts"></a>
<a class="index-entry-id" id="index-rec-btrace-pt"></a>
<a class="index-entry-id" id="index-rec-bts"></a>
<a class="index-entry-id" id="index-rec-pt"></a>
<a id="index-target-record"></a><span><code class="code">record <var class="var">method</var></code><a class="copiable-link" href="#index-target-record"> &para;</a></span></dt>
<dd><p>This command starts the process record and replay target.  The
recording method can be specified as parameter.  Without a parameter
the command uses the <code class="code">full</code> recording method.  The following
recording methods are available:
</p>
<dl class="table">
<dt><code class="code">full</code></dt>
<dd><p>Full record/replay recording using <small class="sc">GDB</small>&rsquo;s software record and
replay implementation.  This method allows replaying and reverse
execution.
</p>
</dd>
<dt><code class="code">btrace <var class="var">format</var></code></dt>
<dd><p>Hardware-supported instruction recording, supported on Intel
processors.  This method does not record data.  Further, the data is
collected in a ring buffer so old data will be overwritten when the
buffer is full.  It allows limited reverse execution.  Variables and
registers are not available during reverse execution.  In remote
debugging, recording continues on disconnect.  Recorded data can be
inspected after reconnecting.  The recording may be stopped using
<code class="code">record stop</code>.
</p>
<p>The recording format can be specified as parameter.  Without a parameter
the command chooses the recording format.  The following recording
formats are available:
</p>
<dl class="table">
<dt><a id="index-branch-trace-store"></a><span><code class="code">bts</code><a class="copiable-link" href="#index-branch-trace-store"> &para;</a></span></dt>
<dd><p>Use the <em class="dfn">Branch Trace Store</em> (<abbr class="acronym">BTS</abbr>) recording format.  In
this format, the processor stores a from/to record for each executed
branch in the btrace ring buffer.
</p>
</dd>
<dt><a id="index-Intel-Processor-Trace"></a><span><code class="code">pt</code><a class="copiable-link" href="#index-Intel-Processor-Trace"> &para;</a></span></dt>
<dd><p>Use the <em class="dfn">Intel Processor Trace</em> recording format.  In this
format, the processor stores the execution trace in a compressed form
that is afterwards decoded by <small class="sc">GDB</small>.
</p>
<p>The trace can be recorded with very low overhead.  The compressed
trace format also allows small trace buffers to already contain a big
number of instructions compared to <abbr class="acronym">BTS</abbr>.
</p>
<p>Decoding the recorded execution trace, on the other hand, is more
expensive than decoding <abbr class="acronym">BTS</abbr> trace.  This is mostly due to the
increased number of instructions to process.  You should increase the
buffer-size with care.
</p></dd>
</dl>

<p>Not all recording formats may be available on all processors.
</p></dd>
</dl>

<p>The process record and replay target can only debug a process that is
already running.  Therefore, you need first to start the process with
the <kbd class="kbd">run</kbd> or <kbd class="kbd">start</kbd> commands, and then start the recording
with the <kbd class="kbd">record <var class="var">method</var></kbd> command.
</p>
<a class="index-entry-id" id="index-displaced-stepping_002c-and-process-record-and-replay"></a>
<p>Displaced stepping (see <a class="pxref" href="Maintenance-Commands.html">displaced stepping</a>)
will be automatically disabled when process record and replay target
is started.  That&rsquo;s because the process record and replay target
doesn&rsquo;t support displaced stepping.
</p>
<a class="index-entry-id" id="index-non_002dstop-mode_002c-and-process-record-and-replay"></a>
<a class="index-entry-id" id="index-asynchronous-execution_002c-and-process-record-and-replay"></a>
<p>If the inferior is in the non-stop mode (see <a class="pxref" href="Non_002dStop-Mode.html">Non-Stop Mode</a>) or in
the asynchronous execution mode (see <a class="pxref" href="Background-Execution.html">Background Execution</a>), not
all recording methods are available.  The <code class="code">full</code> recording method
does not support these two modes.
</p>
</dd>
<dt><a class="index-entry-id" id="index-rec-s"></a>
<a id="index-record-stop"></a><span><code class="code">record stop</code><a class="copiable-link" href="#index-record-stop"> &para;</a></span></dt>
<dd><p>Stop the process record and replay target.  When process record and
replay target stops, the entire execution log will be deleted and the
inferior will either be terminated, or will remain in its final state.
</p>
<p>When you stop the process record and replay target in record mode (at
the end of the execution log), the inferior will be stopped at the
next instruction that would have been recorded.  In other words, if
you record for a while and then stop recording, the inferior process
will be left in the same state as if the recording never happened.
</p>
<p>On the other hand, if the process record and replay target is stopped
while in replay mode (that is, not at the end of the execution log,
but at some earlier point), the inferior process will become &ldquo;live&rdquo;
at that earlier state, and it will then be possible to continue the
usual &ldquo;live&rdquo; debugging of the process from that state.
</p>
<p>When the inferior process exits, or <small class="sc">GDB</small> detaches from it,
process record and replay target will automatically stop itself.
</p>
</dd>
<dt><a id="index-record-goto"></a><span><code class="code">record goto</code><a class="copiable-link" href="#index-record-goto"> &para;</a></span></dt>
<dd><p>Go to a specific location in the execution log.  There are several
ways to specify the location to go to:
</p>
<dl class="table">
<dt><code class="code">record goto begin</code></dt>
<dt><code class="code">record goto start</code></dt>
<dd><p>Go to the beginning of the execution log.
</p>
</dd>
<dt><code class="code">record goto end</code></dt>
<dd><p>Go to the end of the execution log.
</p>
</dd>
<dt><code class="code">record goto <var class="var">n</var></code></dt>
<dd><p>Go to instruction number <var class="var">n</var> in the execution log.
</p></dd>
</dl>

</dd>
<dt><a id="index-record-save"></a><span><code class="code">record save <var class="var">filename</var></code><a class="copiable-link" href="#index-record-save"> &para;</a></span></dt>
<dd><p>Save the execution log to a file <samp class="file"><var class="var">filename</var></samp>.
Default filename is <samp class="file">gdb_record.<var class="var">process_id</var></samp>, where
<var class="var">process_id</var> is the process ID of the inferior.
</p>
<p>This command may not be available for all recording methods.
</p>
</dd>
<dt><a id="index-record-restore"></a><span><code class="code">record restore <var class="var">filename</var></code><a class="copiable-link" href="#index-record-restore"> &para;</a></span></dt>
<dd><p>Restore the execution log from a file <samp class="file"><var class="var">filename</var></samp>.
File must have been created with <code class="code">record save</code>.
</p>
</dd>
<dt><a id="index-set-record-full"></a><span><code class="code">set record full insn-number-max <var class="var">limit</var></code><a class="copiable-link" href="#index-set-record-full"> &para;</a></span></dt>
<dt><code class="code">set record full insn-number-max unlimited</code></dt>
<dd><p>Set the limit of instructions to be recorded for the <code class="code">full</code>
recording method.  Default value is 200000.
</p>
<p>If <var class="var">limit</var> is a positive number, then <small class="sc">GDB</small> will start
deleting instructions from the log once the number of the record
instructions becomes greater than <var class="var">limit</var>.  For every new recorded
instruction, <small class="sc">GDB</small> will delete the earliest recorded
instruction to keep the number of recorded instructions at the limit.
(Since deleting recorded instructions loses information, <small class="sc">GDB</small>
lets you control what happens when the limit is reached, by means of
the <code class="code">stop-at-limit</code> option, described below.)
</p>
<p>If <var class="var">limit</var> is <code class="code">unlimited</code> or zero, <small class="sc">GDB</small> will never
delete recorded instructions from the execution log.  The number of
recorded instructions is limited only by the available memory.
</p>
</dd>
<dt><a id="index-show-record-full"></a><span><code class="code">show record full insn-number-max</code><a class="copiable-link" href="#index-show-record-full"> &para;</a></span></dt>
<dd><p>Show the limit of instructions to be recorded with the <code class="code">full</code>
recording method.
</p>
</dd>
<dt><code class="code">set record full stop-at-limit</code></dt>
<dd><p>Control the behavior of the  <code class="code">full</code> recording method when the
number of recorded instructions reaches the limit.  If ON (the
default), <small class="sc">GDB</small> will stop when the limit is reached for the
first time and ask you whether you want to stop the inferior or
continue running it and recording the execution log.  If you decide
to continue recording, each new recorded instruction will cause the
oldest one to be deleted.
</p>
<p>If this option is OFF, <small class="sc">GDB</small> will automatically delete the
oldest record to make room for each new one, without asking.
</p>
</dd>
<dt><code class="code">show record full stop-at-limit</code></dt>
<dd><p>Show the current setting of <code class="code">stop-at-limit</code>.
</p>
</dd>
<dt><code class="code">set record full memory-query</code></dt>
<dd><p>Control the behavior when <small class="sc">GDB</small> is unable to record memory
changes caused by an instruction for the <code class="code">full</code> recording method.
If ON, <small class="sc">GDB</small> will query whether to stop the inferior in that
case.
</p>
<p>If this option is OFF (the default), <small class="sc">GDB</small> will automatically
ignore the effect of such instructions on memory.  Later, when
<small class="sc">GDB</small> replays this execution log, it will mark the log of this
instruction as not accessible, and it will not affect the replay
results.
</p>
</dd>
<dt><code class="code">show record full memory-query</code></dt>
<dd><p>Show the current setting of <code class="code">memory-query</code>.
</p>
<a class="index-entry-id" id="index-set-record-btrace"></a>
<p>The <code class="code">btrace</code> record target does not trace data.  As a
convenience, when replaying, <small class="sc">GDB</small> reads read-only memory off
the live program directly, assuming that the addresses of the
read-only areas don&rsquo;t change.  This for example makes it possible to
disassemble code while replaying, but not to print variables.
In some cases, being able to inspect variables might be useful.
You can use the following command for that:
</p>
</dd>
<dt><code class="code">set record btrace replay-memory-access</code></dt>
<dd><p>Control the behavior of the <code class="code">btrace</code> recording method when
accessing memory during replay.  If <code class="code">read-only</code> (the default),
<small class="sc">GDB</small> will only allow accesses to read-only memory.
If <code class="code">read-write</code>, <small class="sc">GDB</small> will allow accesses to read-only
and to read-write memory.  Beware that the accessed memory corresponds
to the live target and not necessarily to the current replay
position.
</p>
</dd>
<dt><code class="code">set record btrace cpu <var class="var">identifier</var></code></dt>
<dd><p>Set the processor to be used for enabling workarounds for processor
errata when decoding the trace.
</p>
<p>Processor errata are defects in processor operation, caused by its
design or manufacture.  They can cause a trace not to match the
specification.  This, in turn, may cause trace decode to fail.
<small class="sc">GDB</small> can detect erroneous trace packets and correct them, thus
avoiding the decoding failures.  These corrections are known as
<em class="dfn">errata workarounds</em>, and are enabled based on the processor on
which the trace was recorded.
</p>
<p>By default, <small class="sc">GDB</small> attempts to detect the processor
automatically, and apply the necessary workarounds for it.  However,
you may need to specify the processor if <small class="sc">GDB</small> does not yet
support it.  This command allows you to do that, and also allows to
disable the workarounds.
</p>
<p>The argument <var class="var">identifier</var> identifies the <small class="sc">CPU</small> and is of the
form: <code class="code"><var class="var">vendor</var>:<var class="var">processor identifier</var></code>.  In addition,
there are two special identifiers, <code class="code">none</code> and <code class="code">auto</code>
(default).
</p>
<p>The following vendor identifiers and corresponding processor
identifiers are currently supported:
</p>
<table class="multitable">
<tbody><tr><td width="10%"><code class="code">intel</code></td><td width="90%"><var class="var">family</var>/<var class="var">model</var>[/<var class="var">stepping</var>]</td></tr>
</tbody>
</table>

<p>On GNU/Linux systems, the processor <var class="var">family</var>, <var class="var">model</var>, and
<var class="var">stepping</var> can be obtained from <code class="code">/proc/cpuinfo</code>.
</p>
<p>If <var class="var">identifier</var> is <code class="code">auto</code>, enable errata workarounds for the
processor on which the trace was recorded.  If <var class="var">identifier</var> is
<code class="code">none</code>, errata workarounds are disabled.
</p>
<p>For example, when using an old <small class="sc">GDB</small> on a new system, decode
may fail because <small class="sc">GDB</small> does not support the new processor.  It
often suffices to specify an older processor that <small class="sc">GDB</small>
supports.
</p>
<div class="example smallexample">
<pre class="example-preformatted">(gdb) info record
Active record target: record-btrace
Recording format: Intel Processor Trace.
Buffer size: 16kB.
Failed to configure the Intel Processor Trace decoder: unknown cpu.
(gdb) set record btrace cpu intel:6/158
(gdb) info record
Active record target: record-btrace
Recording format: Intel Processor Trace.
Buffer size: 16kB.
Recorded 84872 instructions in 3189 functions (0 gaps) for thread 1 (...).
</pre></div>

</dd>
<dt><a id="index-show-record-btrace"></a><span><code class="code">show record btrace replay-memory-access</code><a class="copiable-link" href="#index-show-record-btrace"> &para;</a></span></dt>
<dd><p>Show the current setting of <code class="code">replay-memory-access</code>.
</p>
</dd>
<dt><code class="code">show record btrace cpu</code></dt>
<dd><p>Show the processor to be used for enabling trace decode errata
workarounds.
</p>
</dd>
<dt><a id="index-set-record-btrace-bts"></a><span><code class="code">set record btrace bts buffer-size <var class="var">size</var></code><a class="copiable-link" href="#index-set-record-btrace-bts"> &para;</a></span></dt>
<dt><code class="code">set record btrace bts buffer-size unlimited</code></dt>
<dd><p>Set the requested ring buffer size for branch tracing in <abbr class="acronym">BTS</abbr>
format.  Default is 64KB.
</p>
<p>If <var class="var">size</var> is a positive number, then <small class="sc">GDB</small> will try to
allocate a buffer of at least <var class="var">size</var> bytes for each new thread
that uses the btrace recording method and the <abbr class="acronym">BTS</abbr> format.
The actually obtained buffer size may differ from the requested
<var class="var">size</var>.  Use the <code class="code">info record</code> command to see the actual
buffer size for each thread that uses the btrace recording method and
the <abbr class="acronym">BTS</abbr> format.
</p>
<p>If <var class="var">limit</var> is <code class="code">unlimited</code> or zero, <small class="sc">GDB</small> will try to
allocate a buffer of 4MB.
</p>
<p>Bigger buffers mean longer traces.  On the other hand, <small class="sc">GDB</small> will
also need longer to process the branch trace data before it can be used.
</p>
</dd>
<dt><code class="code">show record btrace bts buffer-size <var class="var">size</var></code></dt>
<dd><p>Show the current setting of the requested ring buffer size for branch
tracing in <abbr class="acronym">BTS</abbr> format.
</p>
</dd>
<dt><a id="index-set-record-btrace-pt"></a><span><code class="code">set record btrace pt buffer-size <var class="var">size</var></code><a class="copiable-link" href="#index-set-record-btrace-pt"> &para;</a></span></dt>
<dt><code class="code">set record btrace pt buffer-size unlimited</code></dt>
<dd><p>Set the requested ring buffer size for branch tracing in Intel
Processor Trace format.  Default is 16KB.
</p>
<p>If <var class="var">size</var> is a positive number, then <small class="sc">GDB</small> will try to
allocate a buffer of at least <var class="var">size</var> bytes for each new thread
that uses the btrace recording method and the Intel Processor Trace
format.  The actually obtained buffer size may differ from the
requested <var class="var">size</var>.  Use the <code class="code">info record</code> command to see the
actual buffer size for each thread.
</p>
<p>If <var class="var">limit</var> is <code class="code">unlimited</code> or zero, <small class="sc">GDB</small> will try to
allocate a buffer of 4MB.
</p>
<p>Bigger buffers mean longer traces.  On the other hand, <small class="sc">GDB</small> will
also need longer to process the branch trace data before it can be used.
</p>
</dd>
<dt><code class="code">show record btrace pt buffer-size <var class="var">size</var></code></dt>
<dd><p>Show the current setting of the requested ring buffer size for branch
tracing in Intel Processor Trace format.
</p>
</dd>
<dt><code class="code">set record btrace pt event-tracing</code></dt>
<dd><p>Enable or disable event tracing for branch tracing in Intel Processor
Trace format.  When enabled, events are recorded during execution as
auxiliary information and will be printed during stepping commands and
commands displaying the execution history.  Changing this setting has no
effect on an active recording.  The default is off.
</p>
</dd>
<dt><code class="code">show record btrace pt event-tracing</code></dt>
<dd><p>Show the current setting of Intel Processor Trace event tracing.
</p>
</dd>
<dt><a id="index-info-record"></a><span><code class="code">info record</code><a class="copiable-link" href="#index-info-record"> &para;</a></span></dt>
<dd><p>Show various statistics about the recording depending on the recording
method:
</p>
<dl class="table">
<dt><code class="code">full</code></dt>
<dd><p>For the <code class="code">full</code> recording method, it shows the state of process
record and its in-memory execution log buffer, including:
</p>
<ul class="itemize mark-bullet">
<li>Whether in record mode or replay mode.
</li><li>Lowest recorded instruction number (counting from when the current execution log started recording instructions).
</li><li>Highest recorded instruction number.
</li><li>Current instruction about to be replayed (if in replay mode).
</li><li>Number of instructions contained in the execution log.
</li><li>Maximum number of instructions that may be contained in the execution log.
</li></ul>

</dd>
<dt><code class="code">btrace</code></dt>
<dd><p>For the <code class="code">btrace</code> recording method, it shows:
</p>
<ul class="itemize mark-bullet">
<li>Recording format.
</li><li>Number of instructions that have been recorded.
</li><li>Number of blocks of sequential control-flow formed by the recorded
instructions.
</li><li>Whether in record mode or replay mode.
</li></ul>

<p>For the <code class="code">bts</code> recording format, it also shows:
</p><ul class="itemize mark-bullet">
<li>Size of the perf ring buffer.
</li></ul>

<p>For the <code class="code">pt</code> recording format, it also shows:
</p><ul class="itemize mark-bullet">
<li>Size of the perf ring buffer.
</li></ul>
</dd>
</dl>

</dd>
<dt><a class="index-entry-id" id="index-rec-del"></a>
<a id="index-record-delete"></a><span><code class="code">record delete</code><a class="copiable-link" href="#index-record-delete"> &para;</a></span></dt>
<dd><p>When record target runs in replay mode (&ldquo;in the past&rdquo;), delete the
subsequent execution log and begin to record a new execution log starting
from the current address.  This means you will abandon the previously
recorded &ldquo;future&rdquo; and begin recording a new &ldquo;future&rdquo;.
</p>
</dd>
<dt><a class="index-entry-id" id="index-rec-instruction_002dhistory"></a>
<a id="index-record-instruction_002dhistory"></a><span><code class="code">record instruction-history</code><a class="copiable-link" href="#index-record-instruction_002dhistory"> &para;</a></span></dt>
<dd><p>Disassembles instructions from the recorded execution log.  By
default, ten instructions are disassembled.  This can be changed using
the <code class="code">set record instruction-history-size</code> command.  Instructions
are printed in execution order.
</p>
<p>It can also print mixed source+disassembly if you specify the the
<code class="code">/m</code> or <code class="code">/s</code> modifier, and print the raw instructions in hex
as well as in symbolic form by specifying the <code class="code">/r</code> or <code class="code">/b</code>
modifier.  The behavior of the <code class="code">/m</code>, <code class="code">/s</code>, <code class="code">/r</code>, and
<code class="code">/b</code> modifiers are the same as for the <kbd class="kbd">disassemble</kbd> command
(see <a class="pxref" href="Machine-Code.html#disassemble"><kbd class="kbd">disassemble</kbd></a>).
</p>
<p>The current position marker is printed for the instruction at the
current program counter value.  This instruction can appear multiple
times in the trace and the current position marker will be printed
every time.  To omit the current position marker, specify the
<code class="code">/p</code> modifier.
</p>
<p>To better align the printed instructions when the trace contains
instructions from more than one function, the function name may be
omitted by specifying the <code class="code">/f</code> modifier.
</p>
<p>Printing auxiliary information is enabled by default and can be
omitted with the <code class="code">/a</code> modifier.
</p>
<p>Speculatively executed instructions are prefixed with &lsquo;<samp class="samp">?</samp>&rsquo;.  This
feature is not available for all recording formats.
</p>
<p>There are several ways to specify what part of the execution log to
disassemble:
</p>
<dl class="table">
<dt><code class="code">record instruction-history <var class="var">insn</var></code></dt>
<dd><p>Disassembles ten instructions starting from instruction number
<var class="var">insn</var>.
</p>
</dd>
<dt><code class="code">record instruction-history <var class="var">insn</var>, +/-<var class="var">n</var></code></dt>
<dd><p>Disassembles <var class="var">n</var> instructions around instruction number
<var class="var">insn</var>.  If <var class="var">n</var> is preceded with <code class="code">+</code>, disassembles
<var class="var">n</var> instructions after instruction number <var class="var">insn</var>.  If
<var class="var">n</var> is preceded with <code class="code">-</code>, disassembles <var class="var">n</var>
instructions before instruction number <var class="var">insn</var>.
</p>
</dd>
<dt><code class="code">record instruction-history</code></dt>
<dd><p>Disassembles ten more instructions after the last disassembly.
</p>
</dd>
<dt><code class="code">record instruction-history -</code></dt>
<dd><p>Disassembles ten more instructions before the last disassembly.
</p>
</dd>
<dt><code class="code">record instruction-history <var class="var">begin</var>, <var class="var">end</var></code></dt>
<dd><p>Disassembles instructions beginning with instruction number
<var class="var">begin</var> until instruction number <var class="var">end</var>.  The instruction
number <var class="var">end</var> is included.
</p></dd>
</dl>

<p>This command may not be available for all recording methods.
</p>
</dd>
<dt><a id="index-set-record"></a><span><code class="code">set record instruction-history-size <var class="var">size</var></code><a class="copiable-link" href="#index-set-record"> &para;</a></span></dt>
<dt><code class="code">set record instruction-history-size unlimited</code></dt>
<dd><p>Define how many instructions to disassemble in the <code class="code">record
instruction-history</code> command.  The default value is 10.
A <var class="var">size</var> of <code class="code">unlimited</code> means unlimited instructions.
</p>
</dd>
<dt><a id="index-show-record"></a><span><code class="code">show record instruction-history-size</code><a class="copiable-link" href="#index-show-record"> &para;</a></span></dt>
<dd><p>Show how many instructions to disassemble in the <code class="code">record
instruction-history</code> command.
</p>
</dd>
<dt><a class="index-entry-id" id="index-rec-function_002dcall_002dhistory"></a>
<a id="index-record-function_002dcall_002dhistory"></a><span><code class="code">record function-call-history</code><a class="copiable-link" href="#index-record-function_002dcall_002dhistory"> &para;</a></span></dt>
<dd><p>Prints the execution history at function granularity.  For each sequence
of instructions that belong to the same function, it prints the name of
that function, the source lines for this instruction sequence (if the
<code class="code">/l</code> modifier is specified), and the instructions numbers that form
the sequence (if the <code class="code">/i</code> modifier is specified).  The function names
are indented to reflect the call stack depth if the <code class="code">/c</code> modifier is
specified.  Printing auxiliary information is enabled by default and can be
omitted with the <code class="code">/a</code> modifier.  The <code class="code">/l</code>, <code class="code">/i</code>, <code class="code">/a</code>,
and <code class="code">/c</code> modifiers can be given together.
</p>
<div class="example smallexample">
<pre class="example-preformatted">(gdb) <b class="b">list 1, 10</b>
1   void foo (void)
2   {
3   }
4
5   void bar (void)
6   {
7     ...
8     foo ();
9     ...
10  }
(gdb) <b class="b">record function-call-history /ilc</b>
1  bar     inst 1,4     at foo.c:6,8
2    foo   inst 5,10    at foo.c:2,3
3  bar     inst 11,13   at foo.c:9,10
</pre></div>

<p>By default, ten functions are printed.  This can be changed using the
<code class="code">set record function-call-history-size</code> command.  Functions are
printed in execution order.  There are several ways to specify what
to print:
</p>
<dl class="table">
<dt><code class="code">record function-call-history <var class="var">func</var></code></dt>
<dd><p>Prints ten functions starting from function number <var class="var">func</var>.
</p>
</dd>
<dt><code class="code">record function-call-history <var class="var">func</var>, +/-<var class="var">n</var></code></dt>
<dd><p>Prints <var class="var">n</var> functions around function number <var class="var">func</var>.  If
<var class="var">n</var> is preceded with <code class="code">+</code>, prints <var class="var">n</var> functions after
function number <var class="var">func</var>.  If <var class="var">n</var> is preceded with <code class="code">-</code>,
prints <var class="var">n</var> functions before function number <var class="var">func</var>.
</p>
</dd>
<dt><code class="code">record function-call-history</code></dt>
<dd><p>Prints ten more functions after the last ten-function print.
</p>
</dd>
<dt><code class="code">record function-call-history -</code></dt>
<dd><p>Prints ten more functions before the last ten-function print.
</p>
</dd>
<dt><code class="code">record function-call-history <var class="var">begin</var>, <var class="var">end</var></code></dt>
<dd><p>Prints functions beginning with function number <var class="var">begin</var> until
function number <var class="var">end</var>.  The function number <var class="var">end</var> is included.
</p></dd>
</dl>

<p>This command may not be available for all recording methods.
</p>
</dd>
<dt><code class="code">set record function-call-history-size <var class="var">size</var></code></dt>
<dt><code class="code">set record function-call-history-size unlimited</code></dt>
<dd><p>Define how many functions to print in the
<code class="code">record function-call-history</code> command.  The default value is 10.
A size of <code class="code">unlimited</code> means unlimited functions.
</p>
</dd>
<dt><code class="code">show record function-call-history-size</code></dt>
<dd><p>Show how many functions to print in the
<code class="code">record function-call-history</code> command.
</p></dd>
</dl>


</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Stack.html">Examining the Stack</a>, Previous: <a href="Reverse-Execution.html">Running programs backward</a>, Up: <a href="index.html">Debugging with <small class="sc">GDB</small></a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>

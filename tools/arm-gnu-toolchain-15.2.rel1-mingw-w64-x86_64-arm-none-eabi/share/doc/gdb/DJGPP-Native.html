<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- Copyright Â© 1988-2024 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Free Software" and "Free Software Needs
Free Documentation", with the Front-Cover Texts being "A GNU Manual,"
and with the Back-Cover Texts as in (a) below.

(a) The FSF's Back-Cover Text is: "You are free to copy and modify
this GNU Manual.  Buying copies from GNU Press supports the FSF in
developing GNU and promoting software freedom." -->
<title>DJGPP Native (Debugging with GDB)</title>

<meta name="description" content="DJGPP Native (Debugging with GDB)">
<meta name="keywords" content="DJGPP Native (Debugging with GDB)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Concept-Index.html" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Native.html" rel="up" title="Native">
<link href="Cygwin-Native.html" rel="next" title="Cygwin Native">
<link href="Process-Information.html" rel="prev" title="Process Information">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
kbd.kbd {font-style: oblique}
span:hover a.copiable-link {visibility: visible}
-->
</style>


</head>

<body lang="en">
<div class="subsection-level-extent" id="DJGPP-Native">
<div class="nav-panel">
<p>
Next: <a href="Cygwin-Native.html" accesskey="n" rel="next">Features for Debugging MS Windows PE Executables</a>, Previous: <a href="Process-Information.html" accesskey="p" rel="prev">Process Information</a>, Up: <a href="Native.html" accesskey="u" rel="up">Native</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h4 class="subsection" id="Features-for-Debugging-djgpp-Programs"><span>21.1.3 Features for Debugging <small class="sc">DJGPP</small> Programs<a class="copiable-link" href="#Features-for-Debugging-djgpp-Programs"> &para;</a></span></h4>
<a class="index-entry-id" id="index-djgpp-debugging"></a>
<a class="index-entry-id" id="index-native-djgpp-debugging"></a>
<a class="index-entry-id" id="index-MS_002dDOS_002dspecific-commands"></a>

<a class="index-entry-id" id="index-DPMI"></a>
<p><small class="sc">DJGPP</small> is a port of the <small class="sc">GNU</small> development tools to MS-DOS and
MS-Windows.  <small class="sc">DJGPP</small> programs are 32-bit protected-mode programs
that use the <em class="dfn">DPMI</em> (DOS Protected-Mode Interface) API to run on
top of real-mode DOS systems and their emulations.
</p>
<p><small class="sc">GDB</small> supports native debugging of <small class="sc">DJGPP</small> programs, and
defines a few commands specific to the <small class="sc">DJGPP</small> port.  This
subsection describes those commands.
</p>
<dl class="table">
<dt><a id="index-info-dos"></a><span><code class="code">info dos</code><a class="copiable-link" href="#index-info-dos"> &para;</a></span></dt>
<dd><p>This is a prefix of <small class="sc">DJGPP</small>-specific commands which print
information about the target system and important OS structures.
</p>
</dd>
<dt><a class="index-entry-id" id="index-MS_002dDOS-system-info"></a>
<a class="index-entry-id" id="index-free-memory-information-_0028MS_002dDOS_0029"></a>
<a id="index-sysinfo"></a><span><code class="code">info dos sysinfo</code><a class="copiable-link" href="#index-sysinfo"> &para;</a></span></dt>
<dd><p>This command displays assorted information about the underlying
platform: the CPU type and features, the OS version and flavor, the
DPMI version, and the available conventional and DPMI memory.
</p>
</dd>
<dt><a class="index-entry-id" id="index-LDT"></a>
<a class="index-entry-id" id="index-IDT"></a>
<a class="index-entry-id" id="index-segment-descriptor-tables"></a>
<a class="index-entry-id" id="index-descriptor-tables-display"></a>
<a id="index-GDT"></a><span><code class="code">info dos gdt</code><a class="copiable-link" href="#index-GDT"> &para;</a></span></dt>
<dt><code class="code">info dos ldt</code></dt>
<dt><code class="code">info dos idt</code></dt>
<dd><p>These 3 commands display entries from, respectively, Global, Local,
and Interrupt Descriptor Tables (GDT, LDT, and IDT).  The descriptor
tables are data structures which store a descriptor for each segment
that is currently in use.  The segment&rsquo;s selector is an index into a
descriptor table; the table entry for that index holds the
descriptor&rsquo;s base address and limit, and its attributes and access
rights.
</p>
<p>A typical <small class="sc">DJGPP</small> program uses 3 segments: a code segment, a data
segment (used for both data and the stack), and a DOS segment (which
allows access to DOS/BIOS data structures and absolute addresses in
conventional memory).  However, the DPMI host will usually define
additional segments in order to support the DPMI environment.
</p>
<a class="index-entry-id" id="index-garbled-pointers"></a>
<p>These commands allow to display entries from the descriptor tables.
Without an argument, all entries from the specified table are
displayed.  An argument, which should be an integer expression, means
display a single entry whose index is given by the argument.  For
example, here&rsquo;s a convenient way to display information about the
debugged program&rsquo;s data segment:
</p>
<div class="example smallexample">
<pre class="exdent"><code class="code">(gdb) info dos ldt $ds</code>
</pre><pre class="exdent"><code class="code">0x13f: base=0x11970000 limit=0x0009ffff 32-Bit Data (Read/Write, Exp-up)</code>
</pre></div>

<p>This comes in handy when you want to see whether a pointer is outside
the data segment&rsquo;s limit (i.e. <em class="dfn">garbled</em>).
</p>
</dd>
<dt><a id="index-page-tables-display-_0028MS_002dDOS_0029"></a><span><code class="code">info dos pde</code><a class="copiable-link" href="#index-page-tables-display-_0028MS_002dDOS_0029"> &para;</a></span></dt>
<dt><code class="code">info dos pte</code></dt>
<dd><p>These two commands display entries from, respectively, the Page
Directory and the Page Tables.  Page Directories and Page Tables are
data structures which control how virtual memory addresses are mapped
into physical addresses.  A Page Table includes an entry for every
page of memory that is mapped into the program&rsquo;s address space; there
may be several Page Tables, each one holding up to 4096 entries.  A
Page Directory has up to 4096 entries, one each for every Page Table
that is currently in use.
</p>
<p>Without an argument, <kbd class="kbd">info dos pde</kbd> displays the entire Page
Directory, and <kbd class="kbd">info dos pte</kbd> displays all the entries in all of
the Page Tables.  An argument, an integer expression, given to the
<kbd class="kbd">info dos pde</kbd> command means display only that entry from the Page
Directory table.  An argument given to the <kbd class="kbd">info dos pte</kbd> command
means display entries from a single Page Table, the one pointed to by
the specified entry in the Page Directory.
</p>
<a class="index-entry-id" id="index-direct-memory-access-_0028DMA_0029-on-MS_002dDOS"></a>
<p>These commands are useful when your program uses <em class="dfn">DMA</em> (Direct
Memory Access), which needs physical addresses to program the DMA
controller.
</p>
<p>These commands are supported only with some DPMI servers.
</p>
</dd>
<dt><a id="index-physical-address-from-linear-address"></a><span><code class="code">info dos address-pte <var class="var">addr</var></code><a class="copiable-link" href="#index-physical-address-from-linear-address"> &para;</a></span></dt>
<dd><p>This command displays the Page Table entry for a specified linear
address.  The argument <var class="var">addr</var> is a linear address which should
already have the appropriate segment&rsquo;s base address added to it,
because this command accepts addresses which may belong to <em class="emph">any</em>
segment.  For example, here&rsquo;s how to display the Page Table entry for
the page where a variable <code class="code">i</code> is stored:
</p>
<div class="example smallexample">
<pre class="exdent"><code class="code">(gdb) info dos address-pte __djgpp_base_address + (char *)&amp;i</code>
</pre><pre class="exdent"><code class="code">Page Table entry for address 0x11a00d30:</code>
</pre><pre class="exdent"><code class="code">Base=0x02698000 Dirty Acc. Not-Cached Write-Back Usr Read-Write +0xd30</code>
</pre></div>

<p>This says that <code class="code">i</code> is stored at offset <code class="code">0xd30</code> from the page
whose physical base address is <code class="code">0x02698000</code>, and shows all the
attributes of that page.
</p>
<p>Note that you must cast the addresses of variables to a <code class="code">char *</code>,
since otherwise the value of <code class="code">__djgpp_base_address</code>, the base
address of all variables and functions in a <small class="sc">DJGPP</small> program, will
be added using the rules of C pointer arithmetic: if <code class="code">i</code> is
declared an <code class="code">int</code>, <small class="sc">GDB</small> will add 4 times the value of
<code class="code">__djgpp_base_address</code> to the address of <code class="code">i</code>.
</p>
<p>Here&rsquo;s another example, it displays the Page Table entry for the
transfer buffer:
</p>
<div class="example smallexample">
<pre class="exdent"><code class="code">(gdb) info dos address-pte *((unsigned *)&amp;_go32_info_block + 3)</code>
</pre><pre class="exdent"><code class="code">Page Table entry for address 0x29110:</code>
</pre><pre class="exdent"><code class="code">Base=0x00029000 Dirty Acc. Not-Cached Write-Back Usr Read-Write +0x110</code>
</pre></div>

<p>(The <code class="code">+ 3</code> offset is because the transfer buffer&rsquo;s address is the
3rd member of the <code class="code">_go32_info_block</code> structure.)  The output
clearly shows that this DPMI server maps the addresses in conventional
memory 1:1, i.e. the physical (<code class="code">0x00029000</code> + <code class="code">0x110</code>) and
linear (<code class="code">0x29110</code>) addresses are identical.
</p>
<p>This command is supported only with some DPMI servers.
</p></dd>
</dl>

<a class="index-entry-id" id="index-DOS-serial-data-link_002c-remote-debugging"></a>
<p>In addition to native debugging, the DJGPP port supports remote
debugging via a serial data link.  The following commands are specific
to remote serial debugging in the DJGPP port of <small class="sc">GDB</small>.
</p>
<dl class="table">
<dt><a class="index-entry-id" id="index-set-com1irq"></a>
<a class="index-entry-id" id="index-set-com2base"></a>
<a class="index-entry-id" id="index-set-com2irq"></a>
<a class="index-entry-id" id="index-set-com3base"></a>
<a class="index-entry-id" id="index-set-com3irq"></a>
<a class="index-entry-id" id="index-set-com4base"></a>
<a class="index-entry-id" id="index-set-com4irq"></a>
<a id="index-set-com1base"></a><span><code class="code">set com1base <var class="var">addr</var></code><a class="copiable-link" href="#index-set-com1base"> &para;</a></span></dt>
<dd><p>This command sets the base I/O port address of the <samp class="file">COM1</samp> serial
port.
</p>
</dd>
<dt><code class="code">set com1irq <var class="var">irq</var></code></dt>
<dd><p>This command sets the <em class="dfn">Interrupt Request</em> (<code class="code">IRQ</code>) line to use
for the <samp class="file">COM1</samp> serial port.
</p>
<p>There are similar commands &lsquo;<samp class="samp">set com2base</samp>&rsquo;, &lsquo;<samp class="samp">set com3irq</samp>&rsquo;,
etc. for setting the port address and the <code class="code">IRQ</code> lines for the
other 3 COM ports.
</p>
<a class="index-entry-id" id="index-show-com1base"></a>
<a class="index-entry-id" id="index-show-com1irq"></a>
<a class="index-entry-id" id="index-show-com2base"></a>
<a class="index-entry-id" id="index-show-com2irq"></a>
<a class="index-entry-id" id="index-show-com3base"></a>
<a class="index-entry-id" id="index-show-com3irq"></a>
<a class="index-entry-id" id="index-show-com4base"></a>
<a class="index-entry-id" id="index-show-com4irq"></a>
<p>The related commands &lsquo;<samp class="samp">show com1base</samp>&rsquo;, &lsquo;<samp class="samp">show com1irq</samp>&rsquo; etc.
display the current settings of the base address and the <code class="code">IRQ</code>
lines used by the COM ports.
</p>
</dd>
<dt><a class="index-entry-id" id="index-DOS-serial-port-status"></a>
<a id="index-info-serial"></a><span><code class="code">info serial</code><a class="copiable-link" href="#index-info-serial"> &para;</a></span></dt>
<dd><p>This command prints the status of the 4 DOS serial ports.  For each
port, it prints whether it&rsquo;s active or not, its I/O base address and
IRQ number, whether it uses a 16550-style FIFO, its baudrate, and the
counts of various errors encountered so far.
</p></dd>
</dl>


</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Cygwin-Native.html">Features for Debugging MS Windows PE Executables</a>, Previous: <a href="Process-Information.html">Process Information</a>, Up: <a href="Native.html">Native</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>

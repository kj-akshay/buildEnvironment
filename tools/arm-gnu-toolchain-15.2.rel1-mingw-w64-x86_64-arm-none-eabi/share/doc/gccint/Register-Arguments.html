<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- Copyright Â© 1988-2025 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Funding Free Software", the Front-Cover
Texts being (a) (see below), and with the Back-Cover Texts being (b)
(see below).  A copy of the license is included in the section entitled
"GNU Free Documentation License".

(a) The FSF's Front-Cover Text is:

A GNU Manual

(b) The FSF's Back-Cover Text is:

You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development. -->
<title>Register Arguments (GNU Compiler Collection (GCC) Internals)</title>

<meta name="description" content="Register Arguments (GNU Compiler Collection (GCC) Internals)">
<meta name="keywords" content="Register Arguments (GNU Compiler Collection (GCC) Internals)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Option-Index.html" rel="index" title="Option Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Stack-and-Calling.html" rel="up" title="Stack and Calling">
<link href="Scalar-Return.html" rel="next" title="Scalar Return">
<link href="Stack-Arguments.html" rel="prev" title="Stack Arguments">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>


</head>

<body lang="en">
<div class="subsection-level-extent" id="Register-Arguments">
<div class="nav-panel">
<p>
Next: <a href="Scalar-Return.html" accesskey="n" rel="next">How Scalar Function Values Are Returned</a>, Previous: <a href="Stack-Arguments.html" accesskey="p" rel="prev">Passing Function Arguments on the Stack</a>, Up: <a href="Stack-and-Calling.html" accesskey="u" rel="up">Stack Layout and Calling Conventions</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Option-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h4 class="subsection" id="Passing-Arguments-in-Registers"><span>17.9.7 Passing Arguments in Registers<a class="copiable-link" href="#Passing-Arguments-in-Registers"> &para;</a></span></h4>
<a class="index-entry-id" id="index-arguments-in-registers"></a>
<a class="index-entry-id" id="index-registers-arguments"></a>

<p>This section describes the macros which let you control how various
types of arguments are passed in registers or how they are arranged in
the stack.
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fFUNCTION_005fARG"><span class="category-def">Target Hook: </span><span><code class="def-type">rtx</code> <strong class="def-name">TARGET_FUNCTION_ARG</strong> <code class="def-code-arguments">(cumulative_args_t <var class="var">ca</var>, const function_arg_info <var class="var">&amp;arg</var>)</code><a class="copiable-link" href="#index-TARGET_005fFUNCTION_005fARG"> &para;</a></span></dt>
<dd><p>Return an RTX indicating whether function argument <var class="var">arg</var> is passed
in a register and if so, which register.  Argument <var class="var">ca</var> summarizes all
the previous arguments.
</p>
<p>The return value is usually either a <code class="code">reg</code> RTX for the hard
register in which to pass the argument, or zero to pass the argument
on the stack.
</p>
<p>The value of the expression can also be a <code class="code">parallel</code> RTX.  This is
used when an argument is passed in multiple locations.  The mode of the
<code class="code">parallel</code> should be the mode of the entire argument.  The
<code class="code">parallel</code> holds any number of <code class="code">expr_list</code> pairs; each one
describes where part of the argument is passed.  In each
<code class="code">expr_list</code> the first operand must be a <code class="code">reg</code> RTX for the hard
register in which to pass this part of the argument, and the mode of the
register RTX indicates how large this part of the argument is.  The
second operand of the <code class="code">expr_list</code> is a <code class="code">const_int</code> which gives
the offset in bytes into the entire argument of where this part starts.
As a special exception the first <code class="code">expr_list</code> in the <code class="code">parallel</code>
RTX may have a first operand of zero.  This indicates that the entire
argument is also stored on the stack.
</p>
<p>The last time this hook is called, it is called with <code class="code">MODE ==
VOIDmode</code>, and its result is passed to the <code class="code">call</code> or <code class="code">call_value</code>
pattern as operands 2 and 3 respectively.
</p>
<a class="index-entry-id" id="index-stdarg_002eh-and-register-arguments"></a>
<p>The usual way to make the ISO library <samp class="file">stdarg.h</samp> work on a
machine where some arguments are usually passed in registers, is to
cause nameless arguments to be passed on the stack instead.  This is
done by making <code class="code">TARGET_FUNCTION_ARG</code> return 0 whenever
<var class="var">named</var> is <code class="code">false</code>.
</p>
<a class="index-entry-id" id="index-TARGET_005fMUST_005fPASS_005fIN_005fSTACK_002c-and-TARGET_005fFUNCTION_005fARG"></a>
<a class="index-entry-id" id="index-REG_005fPARM_005fSTACK_005fSPACE_002c-and-TARGET_005fFUNCTION_005fARG"></a>
<p>You may use the hook <code class="code">targetm.calls.must_pass_in_stack</code>
in the definition of this macro to determine if this argument is of a
type that must be passed in the stack.  If <code class="code">REG_PARM_STACK_SPACE</code>
is not defined and <code class="code">TARGET_FUNCTION_ARG</code> returns nonzero for such an
argument, the compiler will abort.  If <code class="code">REG_PARM_STACK_SPACE</code> is
defined, the argument will be computed in the stack and then loaded into
a register.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fMUST_005fPASS_005fIN_005fSTACK"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_MUST_PASS_IN_STACK</strong> <code class="def-code-arguments">(const function_arg_info <var class="var">&amp;arg</var>)</code><a class="copiable-link" href="#index-TARGET_005fMUST_005fPASS_005fIN_005fSTACK"> &para;</a></span></dt>
<dd><p>This target hook should return <code class="code">true</code> if we should not pass <var class="var">arg</var>
solely in registers.  The file <samp class="file">expr.h</samp> defines a
definition that is usually appropriate, refer to <samp class="file">expr.h</samp> for additional
documentation.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fFUNCTION_005fINCOMING_005fARG"><span class="category-def">Target Hook: </span><span><code class="def-type">rtx</code> <strong class="def-name">TARGET_FUNCTION_INCOMING_ARG</strong> <code class="def-code-arguments">(cumulative_args_t <var class="var">ca</var>, const function_arg_info <var class="var">&amp;arg</var>)</code><a class="copiable-link" href="#index-TARGET_005fFUNCTION_005fINCOMING_005fARG"> &para;</a></span></dt>
<dd><p>Define this hook if the caller and callee on the target have different
views of where arguments are passed.  Also define this hook if there are
functions that are never directly called, but are invoked by the hardware
and which have nonstandard calling conventions.
</p>
<p>In this case <code class="code">TARGET_FUNCTION_ARG</code> computes the register in
which the caller passes the value, and
<code class="code">TARGET_FUNCTION_INCOMING_ARG</code> should be defined in a similar
fashion to tell the function being called where the arguments will
arrive.
</p>
<p><code class="code">TARGET_FUNCTION_INCOMING_ARG</code> can also return arbitrary address
computation using hard register, which can be forced into a register,
so that it can be used to pass special arguments.
</p>
<p>If <code class="code">TARGET_FUNCTION_INCOMING_ARG</code> is not defined,
<code class="code">TARGET_FUNCTION_ARG</code> serves both purposes.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fUSE_005fPSEUDO_005fPIC_005fREG"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_USE_PSEUDO_PIC_REG</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fUSE_005fPSEUDO_005fPIC_005fREG"> &para;</a></span></dt>
<dd><p>This hook should return 1 in case pseudo register should be created
for pic_offset_table_rtx during function expand.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fINIT_005fPIC_005fREG"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_INIT_PIC_REG</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fINIT_005fPIC_005fREG"> &para;</a></span></dt>
<dd><p>Perform a target dependent initialization of pic_offset_table_rtx.
This hook is called at the start of register allocation.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fARG_005fPARTIAL_005fBYTES"><span class="category-def">Target Hook: </span><span><code class="def-type">int</code> <strong class="def-name">TARGET_ARG_PARTIAL_BYTES</strong> <code class="def-code-arguments">(cumulative_args_t <var class="var">cum</var>, const function_arg_info <var class="var">&amp;arg</var>)</code><a class="copiable-link" href="#index-TARGET_005fARG_005fPARTIAL_005fBYTES"> &para;</a></span></dt>
<dd><p>This target hook returns the number of bytes at the beginning of an
argument that must be put in registers.  The value must be zero for
arguments that are passed entirely in registers or that are entirely
pushed on the stack.
</p>
<p>On some machines, certain arguments must be passed partially in
registers and partially in memory.  On these machines, typically the
first few words of arguments are passed in registers, and the rest
on the stack.  If a multi-word argument (a <code class="code">double</code> or a
structure) crosses that boundary, its first few words must be passed
in registers and the rest must be pushed.  This macro tells the
compiler when this occurs, and how many bytes should go in registers.
</p>
<p><code class="code">TARGET_FUNCTION_ARG</code> for these arguments should return the first
register to be used by the caller for this argument; likewise
<code class="code">TARGET_FUNCTION_INCOMING_ARG</code>, for the called function.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fPASS_005fBY_005fREFERENCE"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_PASS_BY_REFERENCE</strong> <code class="def-code-arguments">(cumulative_args_t <var class="var">cum</var>, const function_arg_info <var class="var">&amp;arg</var>)</code><a class="copiable-link" href="#index-TARGET_005fPASS_005fBY_005fREFERENCE"> &para;</a></span></dt>
<dd><p>This target hook should return <code class="code">true</code> if argument <var class="var">arg</var> at the
position indicated by <var class="var">cum</var> should be passed by reference.  This
predicate is queried after target independent reasons for being
passed by reference, such as <code class="code">TREE_ADDRESSABLE (<var class="var">arg</var>.type)</code>.
</p>
<p>If the hook returns true, a copy of that argument is made in memory and a
pointer to the argument is passed instead of the argument itself.
The pointer is passed in whatever way is appropriate for passing a pointer
to that type.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fCALLEE_005fCOPIES"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_CALLEE_COPIES</strong> <code class="def-code-arguments">(cumulative_args_t <var class="var">cum</var>, const function_arg_info <var class="var">&amp;arg</var>)</code><a class="copiable-link" href="#index-TARGET_005fCALLEE_005fCOPIES"> &para;</a></span></dt>
<dd><p>The function argument described by the parameters to this hook is
known to be passed by reference.  The hook should return true if the
function argument should be copied by the callee instead of copied
by the caller.
</p>
<p>For any argument for which the hook returns true, if it can be
determined that the argument is not modified, then a copy need
not be generated.
</p>
<p>The default version of this hook always returns false.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-CUMULATIVE_005fARGS"><span class="category-def">Macro: </span><span><strong class="def-name">CUMULATIVE_ARGS</strong><a class="copiable-link" href="#index-CUMULATIVE_005fARGS"> &para;</a></span></dt>
<dd><p>A C type for declaring a variable that is used as the first argument
of <code class="code">TARGET_FUNCTION_ARG</code> and other related values.  For some
target machines, the type <code class="code">int</code> suffices and can hold the number
of bytes of argument so far.
</p>
<p>There is no need to record in <code class="code">CUMULATIVE_ARGS</code> anything about the
arguments that have been passed on the stack.  The compiler has other
variables to keep track of that.  For target machines on which all
arguments are passed on the stack, there is no need to store anything in
<code class="code">CUMULATIVE_ARGS</code>; however, the data structure must exist and
should not be empty, so use <code class="code">int</code>.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-OVERRIDE_005fABI_005fFORMAT"><span class="category-def">Macro: </span><span><strong class="def-name">OVERRIDE_ABI_FORMAT</strong> <var class="def-var-arguments">(<var class="var">fndecl</var>)</var><a class="copiable-link" href="#index-OVERRIDE_005fABI_005fFORMAT"> &para;</a></span></dt>
<dd><p>If defined, this macro is called before generating any code for a
function, but after the <var class="var">cfun</var> descriptor for the function has been
created.  The back end may use this macro to update <var class="var">cfun</var> to
reflect an ABI other than that which would normally be used by default.
If the compiler is generating code for a compiler-generated function,
<var class="var">fndecl</var> may be <code class="code">NULL</code>.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-INIT_005fCUMULATIVE_005fARGS"><span class="category-def">Macro: </span><span><strong class="def-name">INIT_CUMULATIVE_ARGS</strong> <var class="def-var-arguments">(<var class="var">cum</var>, <var class="var">fntype</var>, <var class="var">libname</var>, <var class="var">fndecl</var>, <var class="var">n_named_args</var>)</var><a class="copiable-link" href="#index-INIT_005fCUMULATIVE_005fARGS"> &para;</a></span></dt>
<dd><p>A C statement (sans semicolon) for initializing the variable
<var class="var">cum</var> for the state at the beginning of the argument list.  The
variable has type <code class="code">CUMULATIVE_ARGS</code>.  The value of <var class="var">fntype</var>
is the tree node for the data type of the function which will receive
the args, or 0 if the args are to a compiler support library function.
For direct calls that are not libcalls, <var class="var">fndecl</var> contain the
declaration node of the function.  <var class="var">fndecl</var> is also set when
<code class="code">INIT_CUMULATIVE_ARGS</code> is used to find arguments for the function
being compiled.  <var class="var">n_named_args</var> is set to the number of named
arguments, including a structure return address if it is passed as a
parameter, when making a call.  When processing incoming arguments,
<var class="var">n_named_args</var> is set to &minus;1.
</p>
<p>When processing a call to a compiler support library function,
<var class="var">libname</var> identifies which one.  It is a <code class="code">symbol_ref</code> rtx which
contains the name of the function, as a string.  <var class="var">libname</var> is 0 when
an ordinary C function call is being processed.  Thus, each time this
macro is called, either <var class="var">libname</var> or <var class="var">fntype</var> is nonzero, but
never both of them at once.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-INIT_005fCUMULATIVE_005fLIBCALL_005fARGS"><span class="category-def">Macro: </span><span><strong class="def-name">INIT_CUMULATIVE_LIBCALL_ARGS</strong> <var class="def-var-arguments">(<var class="var">cum</var>, <var class="var">mode</var>, <var class="var">libname</var>)</var><a class="copiable-link" href="#index-INIT_005fCUMULATIVE_005fLIBCALL_005fARGS"> &para;</a></span></dt>
<dd><p>Like <code class="code">INIT_CUMULATIVE_ARGS</code> but only used for outgoing libcalls,
it gets a <code class="code">MODE</code> argument instead of <var class="var">fntype</var>, that would be
<code class="code">NULL</code>.  <var class="var">indirect</var> would always be zero, too.  If this macro
is not defined, <code class="code">INIT_CUMULATIVE_ARGS (cum, NULL_RTX, libname,
0)</code> is used instead.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-INIT_005fCUMULATIVE_005fINCOMING_005fARGS"><span class="category-def">Macro: </span><span><strong class="def-name">INIT_CUMULATIVE_INCOMING_ARGS</strong> <var class="def-var-arguments">(<var class="var">cum</var>, <var class="var">fntype</var>, <var class="var">libname</var>)</var><a class="copiable-link" href="#index-INIT_005fCUMULATIVE_005fINCOMING_005fARGS"> &para;</a></span></dt>
<dd><p>Like <code class="code">INIT_CUMULATIVE_ARGS</code> but overrides it for the purposes of
finding the arguments for the function being compiled.  If this macro is
undefined, <code class="code">INIT_CUMULATIVE_ARGS</code> is used instead.
</p>
<p>The value passed for <var class="var">libname</var> is always 0, since library routines
with special calling conventions are never compiled with GCC.  The
argument <var class="var">libname</var> exists for symmetry with
<code class="code">INIT_CUMULATIVE_ARGS</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fFUNCTION_005fARG_005fADVANCE"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_FUNCTION_ARG_ADVANCE</strong> <code class="def-code-arguments">(cumulative_args_t <var class="var">ca</var>, const function_arg_info <var class="var">&amp;arg</var>)</code><a class="copiable-link" href="#index-TARGET_005fFUNCTION_005fARG_005fADVANCE"> &para;</a></span></dt>
<dd><p>This hook updates the summarizer variable pointed to by <var class="var">ca</var> to
advance past argument <var class="var">arg</var> in the argument list.  Once this is done,
the variable <var class="var">cum</var> is suitable for analyzing the <em class="emph">following</em>
argument with <code class="code">TARGET_FUNCTION_ARG</code>, etc.
</p>
<p>This hook need not do anything if the argument in question was passed
on the stack.  The compiler knows how to track the amount of stack space
used for arguments without any special help.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fFUNCTION_005fARG_005fOFFSET"><span class="category-def">Target Hook: </span><span><code class="def-type">HOST_WIDE_INT</code> <strong class="def-name">TARGET_FUNCTION_ARG_OFFSET</strong> <code class="def-code-arguments">(machine_mode <var class="var">mode</var>, const_tree <var class="var">type</var>)</code><a class="copiable-link" href="#index-TARGET_005fFUNCTION_005fARG_005fOFFSET"> &para;</a></span></dt>
<dd><p>This hook returns the number of bytes to add to the offset of an
argument of type <var class="var">type</var> and mode <var class="var">mode</var> when passed in memory.
This is needed for the SPU, which passes <code class="code">char</code> and <code class="code">short</code>
arguments in the preferred slot that is in the middle of the quad word
instead of starting at the top.  The default implementation returns 0.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fFUNCTION_005fARG_005fPADDING"><span class="category-def">Target Hook: </span><span><code class="def-type">pad_direction</code> <strong class="def-name">TARGET_FUNCTION_ARG_PADDING</strong> <code class="def-code-arguments">(machine_mode <var class="var">mode</var>, const_tree <var class="var">type</var>)</code><a class="copiable-link" href="#index-TARGET_005fFUNCTION_005fARG_005fPADDING"> &para;</a></span></dt>
<dd><p>This hook determines whether, and in which direction, to pad out
an argument of mode <var class="var">mode</var> and type <var class="var">type</var>.  It returns
<code class="code">PAD_UPWARD</code> to insert padding above the argument, <code class="code">PAD_DOWNWARD</code>
to insert padding below the argument, or <code class="code">PAD_NONE</code> to inhibit padding.
</p>
<p>The <em class="emph">amount</em> of padding is not controlled by this hook, but by
<code class="code">TARGET_FUNCTION_ARG_ROUND_BOUNDARY</code>.  It is always just enough
to reach the next multiple of that boundary.
</p>
<p>This hook has a default definition that is right for most systems.
For little-endian machines, the default is to pad upward.  For
big-endian machines, the default is to pad downward for an argument of
constant size shorter than an <code class="code">int</code>, and upward otherwise.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-PAD_005fVARARGS_005fDOWN"><span class="category-def">Macro: </span><span><strong class="def-name">PAD_VARARGS_DOWN</strong><a class="copiable-link" href="#index-PAD_005fVARARGS_005fDOWN"> &para;</a></span></dt>
<dd><p>If defined, a C expression which determines whether the default
implementation of va_arg will attempt to pad down before reading the
next argument, if that argument is smaller than its aligned space as
controlled by <code class="code">PARM_BOUNDARY</code>.  If this macro is not defined, all such
arguments are padded down if <code class="code">BYTES_BIG_ENDIAN</code> is true.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-BLOCK_005fREG_005fPADDING"><span class="category-def">Macro: </span><span><strong class="def-name">BLOCK_REG_PADDING</strong> <var class="def-var-arguments">(<var class="var">mode</var>, <var class="var">type</var>, <var class="var">first</var>)</var><a class="copiable-link" href="#index-BLOCK_005fREG_005fPADDING"> &para;</a></span></dt>
<dd><p>Specify padding for the last element of a block move between registers and
memory.  <var class="var">first</var> is nonzero if this is the only element.  Defining this
macro allows better control of register function parameters on big-endian
machines, without using <code class="code">PARALLEL</code> rtl.  In particular,
<code class="code">MUST_PASS_IN_STACK</code> need not test padding and mode of types in
registers, as there is no longer a &quot;wrong&quot; part of a register;  For example,
a three byte aggregate may be passed in the high part of a register if so
required.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fFUNCTION_005fARG_005fBOUNDARY"><span class="category-def">Target Hook: </span><span><code class="def-type">unsigned int</code> <strong class="def-name">TARGET_FUNCTION_ARG_BOUNDARY</strong> <code class="def-code-arguments">(machine_mode <var class="var">mode</var>, const_tree <var class="var">type</var>)</code><a class="copiable-link" href="#index-TARGET_005fFUNCTION_005fARG_005fBOUNDARY"> &para;</a></span></dt>
<dd><p>This hook returns the alignment boundary, in bits, of an argument
with the specified mode and type.  The default hook returns
<code class="code">PARM_BOUNDARY</code> for all arguments.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fFUNCTION_005fARG_005fROUND_005fBOUNDARY"><span class="category-def">Target Hook: </span><span><code class="def-type">unsigned int</code> <strong class="def-name">TARGET_FUNCTION_ARG_ROUND_BOUNDARY</strong> <code class="def-code-arguments">(machine_mode <var class="var">mode</var>, const_tree <var class="var">type</var>)</code><a class="copiable-link" href="#index-TARGET_005fFUNCTION_005fARG_005fROUND_005fBOUNDARY"> &para;</a></span></dt>
<dd><p>Normally, the size of an argument is rounded up to <code class="code">PARM_BOUNDARY</code>,
which is the default value for this hook.  You can define this hook to
return a different value if an argument size must be rounded to a larger
value.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-FUNCTION_005fARG_005fREGNO_005fP"><span class="category-def">Macro: </span><span><strong class="def-name">FUNCTION_ARG_REGNO_P</strong> <var class="def-var-arguments">(<var class="var">regno</var>)</var><a class="copiable-link" href="#index-FUNCTION_005fARG_005fREGNO_005fP"> &para;</a></span></dt>
<dd><p>A C expression that is nonzero if <var class="var">regno</var> is the number of a hard
register in which function arguments are sometimes passed.  This does
<em class="emph">not</em> include implicit arguments such as the static chain and
the structure-value address.  On many machines, no registers can be
used for this purpose since all function arguments are pushed on the
stack.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSPLIT_005fCOMPLEX_005fARG"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_SPLIT_COMPLEX_ARG</strong> <code class="def-code-arguments">(const_tree <var class="var">type</var>)</code><a class="copiable-link" href="#index-TARGET_005fSPLIT_005fCOMPLEX_005fARG"> &para;</a></span></dt>
<dd><p>This hook should return true if parameter of type <var class="var">type</var> are passed
as two scalar parameters.  By default, GCC will attempt to pack complex
arguments into the target&rsquo;s word size.  Some ABIs require complex arguments
to be split and treated as their individual components.  For example, on
AIX64, complex floats should be passed in a pair of floating point
registers, even though a complex float would fit in one 64-bit floating
point register.
</p>
<p>The default value of this hook is <code class="code">NULL</code>, which is treated as always
false.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fBUILD_005fBUILTIN_005fVA_005fLIST"><span class="category-def">Target Hook: </span><span><code class="def-type">tree</code> <strong class="def-name">TARGET_BUILD_BUILTIN_VA_LIST</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fBUILD_005fBUILTIN_005fVA_005fLIST"> &para;</a></span></dt>
<dd><p>This hook returns a type node for <code class="code">va_list</code> for the target.
The default version of the hook returns <code class="code">void*</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fENUM_005fVA_005fLIST_005fP"><span class="category-def">Target Hook: </span><span><code class="def-type">int</code> <strong class="def-name">TARGET_ENUM_VA_LIST_P</strong> <code class="def-code-arguments">(int <var class="var">idx</var>, const char **<var class="var">pname</var>, tree *<var class="var">ptree</var>)</code><a class="copiable-link" href="#index-TARGET_005fENUM_005fVA_005fLIST_005fP"> &para;</a></span></dt>
<dd><p>This target hook is used in function <code class="code">c_common_nodes_and_builtins</code>
to iterate through the target specific builtin types for va_list. The
variable <var class="var">idx</var> is used as iterator. <var class="var">pname</var> has to be a pointer
to a <code class="code">const char *</code> and <var class="var">ptree</var> a pointer to a <code class="code">tree</code> typed
variable.
The arguments <var class="var">pname</var> and <var class="var">ptree</var> are used to store the result of
this macro and are set to the name of the va_list builtin type and its
internal type.
If the return value of this macro is zero, then there is no more element.
Otherwise the <var class="var">IDX</var> should be increased for the next call of this
macro to iterate through all types.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fFN_005fABI_005fVA_005fLIST"><span class="category-def">Target Hook: </span><span><code class="def-type">tree</code> <strong class="def-name">TARGET_FN_ABI_VA_LIST</strong> <code class="def-code-arguments">(tree <var class="var">fndecl</var>)</code><a class="copiable-link" href="#index-TARGET_005fFN_005fABI_005fVA_005fLIST"> &para;</a></span></dt>
<dd><p>This hook returns the va_list type of the calling convention specified by
<var class="var">fndecl</var>.
The default version of this hook returns <code class="code">va_list_type_node</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fCANONICAL_005fVA_005fLIST_005fTYPE"><span class="category-def">Target Hook: </span><span><code class="def-type">tree</code> <strong class="def-name">TARGET_CANONICAL_VA_LIST_TYPE</strong> <code class="def-code-arguments">(tree <var class="var">type</var>)</code><a class="copiable-link" href="#index-TARGET_005fCANONICAL_005fVA_005fLIST_005fTYPE"> &para;</a></span></dt>
<dd><p>This hook returns the va_list type of the calling convention specified by the
type of <var class="var">type</var>. If <var class="var">type</var> is not a valid va_list type, it returns
<code class="code">NULL_TREE</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fGIMPLIFY_005fVA_005fARG_005fEXPR"><span class="category-def">Target Hook: </span><span><code class="def-type">tree</code> <strong class="def-name">TARGET_GIMPLIFY_VA_ARG_EXPR</strong> <code class="def-code-arguments">(tree <var class="var">valist</var>, tree <var class="var">type</var>, gimple_seq *<var class="var">pre_p</var>, gimple_seq *<var class="var">post_p</var>)</code><a class="copiable-link" href="#index-TARGET_005fGIMPLIFY_005fVA_005fARG_005fEXPR"> &para;</a></span></dt>
<dd><p>This hook performs target-specific gimplification of
<code class="code">VA_ARG_EXPR</code>.  The first two parameters correspond to the
arguments to <code class="code">va_arg</code>; the latter two are as in
<code class="code">gimplify.cc:gimplify_expr</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fVALID_005fPOINTER_005fMODE"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_VALID_POINTER_MODE</strong> <code class="def-code-arguments">(scalar_int_mode <var class="var">mode</var>)</code><a class="copiable-link" href="#index-TARGET_005fVALID_005fPOINTER_005fMODE"> &para;</a></span></dt>
<dd><p>Define this to return nonzero if the port can handle pointers
with machine mode <var class="var">mode</var>.  The default version of this
hook returns true for both <code class="code">ptr_mode</code> and <code class="code">Pmode</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fREF_005fMAY_005fALIAS_005fERRNO"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_REF_MAY_ALIAS_ERRNO</strong> <code class="def-code-arguments">(ao_ref *<var class="var">ref</var>)</code><a class="copiable-link" href="#index-TARGET_005fREF_005fMAY_005fALIAS_005fERRNO"> &para;</a></span></dt>
<dd><p>Define this to return nonzero if the memory reference <var class="var">ref</var>
may alias with the system C library errno location.  The default
version of this hook assumes the system C library errno location
is either a declaration of type int or accessed by dereferencing
a pointer to int.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fMODE_005fCAN_005fTRANSFER_005fBITS"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_MODE_CAN_TRANSFER_BITS</strong> <code class="def-code-arguments">(machine_mode <var class="var">mode</var>)</code><a class="copiable-link" href="#index-TARGET_005fMODE_005fCAN_005fTRANSFER_005fBITS"> &para;</a></span></dt>
<dd><p>Define this to return false if the mode <var class="var">mode</var> cannot be used
for memory copying of <code class="code">GET_MODE_SIZE (mode)</code> units.  This might be
because a register class allowed for <var class="var">mode</var> has registers that do
not transparently transfer every bit pattern or because the load or
store patterns available for <var class="var">mode</var> have this issue.
</p>
<p>The default is to assume modes with the same precision as size are fine
to be used.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fREDZONE_005fCLOBBER"><span class="category-def">Target Hook: </span><span><code class="def-type">rtx</code> <strong class="def-name">TARGET_REDZONE_CLOBBER</strong> <code class="def-code-arguments">()</code><a class="copiable-link" href="#index-TARGET_005fREDZONE_005fCLOBBER"> &para;</a></span></dt>
<dd><p>Define this to return some RTL for the <code class="code">redzone</code> <code class="code">asm</code> clobber
if target has a red zone and wants to support the <code class="code">redzone</code> clobber
or return NULL if the clobber should be ignored.
</p>
<p>The default is to ignore the <code class="code">redzone</code> clobber.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fTRANSLATE_005fMODE_005fATTRIBUTE"><span class="category-def">Target Hook: </span><span><code class="def-type">machine_mode</code> <strong class="def-name">TARGET_TRANSLATE_MODE_ATTRIBUTE</strong> <code class="def-code-arguments">(machine_mode <var class="var">mode</var>)</code><a class="copiable-link" href="#index-TARGET_005fTRANSLATE_005fMODE_005fATTRIBUTE"> &para;</a></span></dt>
<dd><p>Define this hook if during mode attribute processing, the port should
translate machine_mode <var class="var">mode</var> to another mode.  For example, rs6000&rsquo;s
<code class="code">KFmode</code>, when it is the same as <code class="code">TFmode</code>.
</p>
<p>The default version of the hook returns that mode that was passed in.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCALAR_005fMODE_005fSUPPORTED_005fP"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_SCALAR_MODE_SUPPORTED_P</strong> <code class="def-code-arguments">(scalar_mode <var class="var">mode</var>)</code><a class="copiable-link" href="#index-TARGET_005fSCALAR_005fMODE_005fSUPPORTED_005fP"> &para;</a></span></dt>
<dd><p>Define this to return nonzero if the port is prepared to handle
insns involving scalar mode <var class="var">mode</var>.  For a scalar mode to be
considered supported, all the basic arithmetic and comparisons
must work.
</p>
<p>The default version of this hook returns true for any mode
required to handle the basic C types (as defined by the port).
Included here are the double-word arithmetic supported by the
code in <samp class="file">optabs.cc</samp>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fVECTOR_005fMODE_005fSUPPORTED_005fP"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_VECTOR_MODE_SUPPORTED_P</strong> <code class="def-code-arguments">(machine_mode <var class="var">mode</var>)</code><a class="copiable-link" href="#index-TARGET_005fVECTOR_005fMODE_005fSUPPORTED_005fP"> &para;</a></span></dt>
<dd><p>Define this to return nonzero if the current target is prepared to handle
insns involving vector mode <var class="var">mode</var>.  At the very least, it
must have move patterns for this mode.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fVECTOR_005fMODE_005fSUPPORTED_005fANY_005fTARGET_005fP"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_VECTOR_MODE_SUPPORTED_ANY_TARGET_P</strong> <code class="def-code-arguments">(machine_mode <var class="var">mode</var>)</code><a class="copiable-link" href="#index-TARGET_005fVECTOR_005fMODE_005fSUPPORTED_005fANY_005fTARGET_005fP"> &para;</a></span></dt>
<dd><p>Define this to return nonzero if the port is prepared to handle
insns involving vector mode <var class="var">mode</var> in any target configuration.
Returning <var class="var">true</var> means that the mode can be used as the &lsquo;<samp class="samp">TYPE_MODE</samp>&rsquo;
for vector types.
</p>
<p>The default version of this hook returns true.  The final mode assigned to
&lsquo;<samp class="samp">TYPE_MODE</samp>&rsquo; will also be checked against
<code class="code">TARGET_VECTOR_MODE_SUPPORTED_P</code> to take target configuration into
account.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fCOMPATIBLE_005fVECTOR_005fTYPES_005fP"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_COMPATIBLE_VECTOR_TYPES_P</strong> <code class="def-code-arguments">(const_tree <var class="var">type1</var>, const_tree <var class="var">type2</var>)</code><a class="copiable-link" href="#index-TARGET_005fCOMPATIBLE_005fVECTOR_005fTYPES_005fP"> &para;</a></span></dt>
<dd><p>Return true if there is no target-specific reason for treating
vector types <var class="var">type1</var> and <var class="var">type2</var> as distinct types.  The caller
has already checked for target-independent reasons, meaning that the
types are known to have the same mode, to have the same number of elements,
and to have what the caller considers to be compatible element types.
</p>
<p>The main reason for defining this hook is to reject pairs of types
that are handled differently by the target&rsquo;s calling convention.
For example, when a new <var class="var">N</var>-bit vector architecture is added
to a target, the target may want to handle normal <var class="var">N</var>-bit
<code class="code">VECTOR_TYPE</code> arguments and return values in the same way as
before, to maintain backwards compatibility.  However, it may also
provide new, architecture-specific <code class="code">VECTOR_TYPE</code>s that are passed
and returned in a more efficient way.  It is then important to maintain
a distinction between the &ldquo;normal&rdquo; <code class="code">VECTOR_TYPE</code>s and the new
architecture-specific ones.
</p>
<p>The default implementation returns true, which is correct for most targets.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fARRAY_005fMODE"><span class="category-def">Target Hook: </span><span><code class="def-type">opt_machine_mode</code> <strong class="def-name">TARGET_ARRAY_MODE</strong> <code class="def-code-arguments">(machine_mode <var class="var">mode</var>, unsigned HOST_WIDE_INT <var class="var">nelems</var>)</code><a class="copiable-link" href="#index-TARGET_005fARRAY_005fMODE"> &para;</a></span></dt>
<dd><p>Return the mode that GCC should use for an array that has
<var class="var">nelems</var> elements, with each element having mode <var class="var">mode</var>.
Return no mode if the target has no special requirements.  In the
latter case, GCC looks for an integer mode of the appropriate size
if available and uses BLKmode otherwise.  Usually the search for the
integer mode is limited to <code class="code">MAX_FIXED_MODE_SIZE</code>, but the
<code class="code">TARGET_ARRAY_MODE_SUPPORTED_P</code> hook allows a larger mode to be
used in specific cases.
</p>
<p>The main use of this hook is to specify that an array of vectors should
also have a vector mode.  The default implementation returns no mode.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fARRAY_005fMODE_005fSUPPORTED_005fP"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_ARRAY_MODE_SUPPORTED_P</strong> <code class="def-code-arguments">(machine_mode <var class="var">mode</var>, unsigned HOST_WIDE_INT <var class="var">nelems</var>)</code><a class="copiable-link" href="#index-TARGET_005fARRAY_005fMODE_005fSUPPORTED_005fP"> &para;</a></span></dt>
<dd><p>Return true if GCC should try to use a scalar mode to store an array
of <var class="var">nelems</var> elements, given that each element has mode <var class="var">mode</var>.
Returning true here overrides the usual <code class="code">MAX_FIXED_MODE</code> limit
and allows GCC to use any defined integer mode.
</p>
<p>One use of this hook is to support vector load and store operations
that operate on several homogeneous vectors.  For example, ARM NEON
has operations like:
</p>
<div class="example smallexample">
<pre class="example-preformatted">int8x8x3_t vld3_s8 (const int8_t *)
</pre></div>

<p>where the return type is defined as:
</p>
<div class="example smallexample">
<pre class="example-preformatted">typedef struct int8x8x3_t
{
  int8x8_t val[3];
} int8x8x3_t;
</pre></div>

<p>If this hook allows <code class="code">val</code> to have a scalar mode, then
<code class="code">int8x8x3_t</code> can have the same mode.  GCC can then store
<code class="code">int8x8x3_t</code>s in registers rather than forcing them onto the stack.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fLIBGCC_005fFLOATING_005fMODE_005fSUPPORTED_005fP"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_LIBGCC_FLOATING_MODE_SUPPORTED_P</strong> <code class="def-code-arguments">(scalar_float_mode <var class="var">mode</var>)</code><a class="copiable-link" href="#index-TARGET_005fLIBGCC_005fFLOATING_005fMODE_005fSUPPORTED_005fP"> &para;</a></span></dt>
<dd><p>Define this to return nonzero if libgcc provides support for the 
floating-point mode <var class="var">mode</var>, which is known to pass 
<code class="code">TARGET_SCALAR_MODE_SUPPORTED_P</code>.  The default version of this 
hook returns true for all of <code class="code">SFmode</code>, <code class="code">DFmode</code>, 
<code class="code">XFmode</code> and <code class="code">TFmode</code>, if such modes exist.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fFLOATN_005fMODE"><span class="category-def">Target Hook: </span><span><code class="def-type">opt_scalar_float_mode</code> <strong class="def-name">TARGET_FLOATN_MODE</strong> <code class="def-code-arguments">(int <var class="var">n</var>, bool <var class="var">extended</var>)</code><a class="copiable-link" href="#index-TARGET_005fFLOATN_005fMODE"> &para;</a></span></dt>
<dd><p>Define this to return the machine mode to use for the type 
<code class="code">_Float<var class="var">n</var></code>, if <var class="var">extended</var> is false, or the type 
<code class="code">_Float<var class="var">n</var>x</code>, if <var class="var">extended</var> is true.  If such a type is not
supported, return <code class="code">opt_scalar_float_mode ()</code>.  The default version of
this hook returns <code class="code">SFmode</code> for <code class="code">_Float32</code>, <code class="code">DFmode</code> for
<code class="code">_Float64</code> and <code class="code">_Float32x</code> and <code class="code">TFmode</code> for 
<code class="code">_Float128</code>, if those modes exist and satisfy the requirements for 
those types and pass <code class="code">TARGET_SCALAR_MODE_SUPPORTED_P</code> and 
<code class="code">TARGET_LIBGCC_FLOATING_MODE_SUPPORTED_P</code>; for <code class="code">_Float64x</code>, it 
returns the first of <code class="code">XFmode</code> and <code class="code">TFmode</code> that exists and 
satisfies the same requirements; for other types, it returns 
<code class="code">opt_scalar_float_mode ()</code>.  The hook is only called for values
of <var class="var">n</var> and <var class="var">extended</var> that are valid according to
ISO/IEC TS 18661-3:2015; that is, <var class="var">n</var> is one of 32, 64, 128, or,
if <var class="var">extended</var> is false, 16 or greater than 128 and a multiple of 32.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fFLOATN_005fBUILTIN_005fP"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_FLOATN_BUILTIN_P</strong> <code class="def-code-arguments">(int <var class="var">func</var>)</code><a class="copiable-link" href="#index-TARGET_005fFLOATN_005fBUILTIN_005fP"> &para;</a></span></dt>
<dd><p>Define this to return true if the <code class="code">_Float<var class="var">n</var></code> and
<code class="code">_Float<var class="var">n</var>x</code> built-in functions should implicitly enable the
built-in function without the <code class="code">__builtin_</code> prefix in addition to the
normal built-in function with the <code class="code">__builtin_</code> prefix.  The default is
to only enable built-in functions without the <code class="code">__builtin_</code> prefix for
the GNU C langauge.  In strict ANSI/ISO mode, the built-in function without
the <code class="code">__builtin_</code> prefix is not enabled.  The argument <code class="code">FUNC</code> is the
<code class="code">enum built_in_function</code> id of the function to be enabled.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSMALL_005fREGISTER_005fCLASSES_005fFOR_005fMODE_005fP"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P</strong> <code class="def-code-arguments">(machine_mode <var class="var">mode</var>)</code><a class="copiable-link" href="#index-TARGET_005fSMALL_005fREGISTER_005fCLASSES_005fFOR_005fMODE_005fP"> &para;</a></span></dt>
<dd><p>Define this to return nonzero for machine modes for which the port has
small register classes.  If this target hook returns nonzero for a given
<var class="var">mode</var>, the compiler will try to minimize the lifetime of registers
in <var class="var">mode</var>.  The hook may be called with <code class="code">VOIDmode</code> as argument.
In this case, the hook is expected to return nonzero if it returns nonzero
for any mode.
</p>
<p>On some machines, it is risky to let hard registers live across arbitrary
insns.  Typically, these machines have instructions that require values
to be in specific registers (like an accumulator), and reload will fail
if the required hard register is used for another purpose across such an
insn.
</p>
<p>Passes before reload do not know which hard registers will be used
in an instruction, but the machine modes of the registers set or used in
the instruction are already known.  And for some machines, register
classes are small for, say, integer registers but not for floating point
registers.  For example, the AMD x86-64 architecture requires specific
registers for the legacy x86 integer instructions, but there are many
SSE registers for floating point operations.  On such targets, a good
strategy may be to return nonzero from this hook for <code class="code">INTEGRAL_MODE_P</code>
machine modes but zero for the SSE register classes.
</p>
<p>The default version of this hook returns false for any mode.  It is always
safe to redefine this hook to return with a nonzero value.  But if you
unnecessarily define it, you will reduce the amount of optimizations
that can be performed in some cases.  If you do not define this hook
to return a nonzero value when it is required, the compiler will run out
of spill registers and print a fatal error message.
</p></dd></dl>

</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Scalar-Return.html">How Scalar Function Values Are Returned</a>, Previous: <a href="Stack-Arguments.html">Passing Function Arguments on the Stack</a>, Up: <a href="Stack-and-Calling.html">Stack Layout and Calling Conventions</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Option-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>

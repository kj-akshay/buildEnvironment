<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- Copyright Â© 1988-2025 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Funding Free Software", the Front-Cover
Texts being (a) (see below), and with the Back-Cover Texts being (b)
(see below).  A copy of the license is included in the section entitled
"GNU Free Documentation License".

(a) The FSF's Front-Cover Text is:

A GNU Manual

(b) The FSF's Back-Cover Text is:

You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development. -->
<title>Values in Registers (GNU Compiler Collection (GCC) Internals)</title>

<meta name="description" content="Values in Registers (GNU Compiler Collection (GCC) Internals)">
<meta name="keywords" content="Values in Registers (GNU Compiler Collection (GCC) Internals)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Option-Index.html" rel="index" title="Option Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Registers.html" rel="up" title="Registers">
<link href="Leaf-Functions.html" rel="next" title="Leaf Functions">
<link href="Allocation-Order.html" rel="prev" title="Allocation Order">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>


</head>

<body lang="en">
<div class="subsection-level-extent" id="Values-in-Registers">
<div class="nav-panel">
<p>
Next: <a href="Leaf-Functions.html" accesskey="n" rel="next">Handling Leaf Functions</a>, Previous: <a href="Allocation-Order.html" accesskey="p" rel="prev">Order of Allocation of Registers</a>, Up: <a href="Registers.html" accesskey="u" rel="up">Register Usage</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Option-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h4 class="subsection" id="How-Values-Fit-in-Registers"><span>17.7.3 How Values Fit in Registers<a class="copiable-link" href="#How-Values-Fit-in-Registers"> &para;</a></span></h4>

<p>This section discusses the macros that describe which kinds of values
(specifically, which machine modes) each register can hold, and how many
consecutive registers are needed for a given mode.
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fHARD_005fREGNO_005fNREGS"><span class="category-def">Target Hook: </span><span><code class="def-type">unsigned int</code> <strong class="def-name">TARGET_HARD_REGNO_NREGS</strong> <code class="def-code-arguments">(unsigned int <var class="var">regno</var>, machine_mode <var class="var">mode</var>)</code><a class="copiable-link" href="#index-TARGET_005fHARD_005fREGNO_005fNREGS"> &para;</a></span></dt>
<dd><p>This hook returns the number of consecutive hard registers, starting
at register number <var class="var">regno</var>, required to hold a value of mode
<var class="var">mode</var>.  This hook must never return zero, even if a register
cannot hold the requested mode - indicate that with
<code class="code">TARGET_HARD_REGNO_MODE_OK</code> and/or
<code class="code">TARGET_CAN_CHANGE_MODE_CLASS</code> instead.
</p>
<p>The default definition returns the number of words in <var class="var">mode</var>.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-HARD_005fREGNO_005fNREGS_005fHAS_005fPADDING"><span class="category-def">Macro: </span><span><strong class="def-name">HARD_REGNO_NREGS_HAS_PADDING</strong> <var class="def-var-arguments">(<var class="var">regno</var>, <var class="var">mode</var>)</var><a class="copiable-link" href="#index-HARD_005fREGNO_005fNREGS_005fHAS_005fPADDING"> &para;</a></span></dt>
<dd><p>A C expression that is nonzero if a value of mode <var class="var">mode</var>, stored
in memory, ends with padding that causes it to take up more space than
in registers starting at register number <var class="var">regno</var> (as determined by
multiplying GCC&rsquo;s notion of the size of the register when containing
this mode by the number of registers returned by
<code class="code">TARGET_HARD_REGNO_NREGS</code>).  By default this is zero.
</p>
<p>For example, if a floating-point value is stored in three 32-bit
registers but takes up 128 bits in memory, then this would be
nonzero.
</p>
<p>This macros only needs to be defined if there are cases where
<code class="code">subreg_get_info</code>
would otherwise wrongly determine that a <code class="code">subreg</code> can be
represented by an offset to the register number, when in fact such a
<code class="code">subreg</code> would contain some of the padding not stored in
registers and so not be representable.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-HARD_005fREGNO_005fNREGS_005fWITH_005fPADDING"><span class="category-def">Macro: </span><span><strong class="def-name">HARD_REGNO_NREGS_WITH_PADDING</strong> <var class="def-var-arguments">(<var class="var">regno</var>, <var class="var">mode</var>)</var><a class="copiable-link" href="#index-HARD_005fREGNO_005fNREGS_005fWITH_005fPADDING"> &para;</a></span></dt>
<dd><p>For values of <var class="var">regno</var> and <var class="var">mode</var> for which
<code class="code">HARD_REGNO_NREGS_HAS_PADDING</code> returns nonzero, a C expression
returning the greater number of registers required to hold the value
including any padding.  In the example above, the value would be four.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-REGMODE_005fNATURAL_005fSIZE-2"><span class="category-def">Macro: </span><span><strong class="def-name">REGMODE_NATURAL_SIZE</strong> <var class="def-var-arguments">(<var class="var">mode</var>)</var><a class="copiable-link" href="#index-REGMODE_005fNATURAL_005fSIZE-2"> &para;</a></span></dt>
<dd><p>Define this macro if the natural size of registers that hold values
of mode <var class="var">mode</var> is not the word size.  It is a C expression that
should give the natural size in bytes for the specified mode.  It is
used by the register allocator to try to optimize its results.  This
happens for example on SPARC 64-bit where the natural size of
floating-point registers is still 32-bit.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fHARD_005fREGNO_005fMODE_005fOK"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_HARD_REGNO_MODE_OK</strong> <code class="def-code-arguments">(unsigned int <var class="var">regno</var>, machine_mode <var class="var">mode</var>)</code><a class="copiable-link" href="#index-TARGET_005fHARD_005fREGNO_005fMODE_005fOK"> &para;</a></span></dt>
<dd><p>This hook returns true if it is permissible to store a value
of mode <var class="var">mode</var> in hard register number <var class="var">regno</var> (or in several
registers starting with that one).  The default definition returns true
unconditionally.
</p>
<p>You need not include code to check for the numbers of fixed registers,
because the allocation mechanism considers them to be always occupied.
</p>
<a class="index-entry-id" id="index-register-pairs"></a>
<p>On some machines, double-precision values must be kept in even/odd
register pairs.  You can implement that by defining this hook to reject
odd register numbers for such modes.
</p>
<p>The minimum requirement for a mode to be OK in a register is that the
&lsquo;<samp class="samp">mov<var class="var">mode</var></samp>&rsquo; instruction pattern support moves between the
register and other hard register in the same class and that moving a
value into the register and back out not alter it.
</p>
<p>Since the same instruction used to move <code class="code">word_mode</code> will work for
all narrower integer modes, it is not necessary on any machine for
this hook to distinguish between these modes, provided you define
patterns &lsquo;<samp class="samp">movhi</samp>&rsquo;, etc., to take advantage of this.  This is
useful because of the interaction between <code class="code">TARGET_HARD_REGNO_MODE_OK</code>
and <code class="code">TARGET_MODES_TIEABLE_P</code>; it is very desirable for all integer
modes to be tieable.
</p>
<p>Many machines have special registers for floating point arithmetic.
Often people assume that floating point machine modes are allowed only
in floating point registers.  This is not true.  Any registers that
can hold integers can safely <em class="emph">hold</em> a floating point machine
mode, whether or not floating arithmetic can be done on it in those
registers.  Integer move instructions can be used to move the values.
</p>
<p>On some machines, though, the converse is true: fixed-point machine
modes may not go in floating registers.  This is true if the floating
registers normalize any value stored in them, because storing a
non-floating value there would garble it.  In this case,
<code class="code">TARGET_HARD_REGNO_MODE_OK</code> should reject fixed-point machine modes in
floating registers.  But if the floating registers do not automatically
normalize, if you can store any bit pattern in one and retrieve it
unchanged without a trap, then any machine mode may go in a floating
register, so you can define this hook to say so.
</p>
<p>The primary significance of special floating registers is rather that
they are the registers acceptable in floating point arithmetic
instructions.  However, this is of no concern to
<code class="code">TARGET_HARD_REGNO_MODE_OK</code>.  You handle it by writing the proper
constraints for those instructions.
</p>
<p>On some machines, the floating registers are especially slow to access,
so that it is better to store a value in a stack frame than in such a
register if floating point arithmetic is not being done.  As long as the
floating registers are not in class <code class="code">GENERAL_REGS</code>, they will not
be used unless some pattern&rsquo;s constraint asks for one.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-HARD_005fREGNO_005fRENAME_005fOK"><span class="category-def">Macro: </span><span><strong class="def-name">HARD_REGNO_RENAME_OK</strong> <var class="def-var-arguments">(<var class="var">from</var>, <var class="var">to</var>)</var><a class="copiable-link" href="#index-HARD_005fREGNO_005fRENAME_005fOK"> &para;</a></span></dt>
<dd><p>A C expression that is nonzero if it is OK to rename a hard register
<var class="var">from</var> to another hard register <var class="var">to</var>.
</p>
<p>One common use of this macro is to prevent renaming of a register to
another register that is not saved by a prologue in an interrupt
handler.
</p>
<p>The default is always nonzero.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fMODES_005fTIEABLE_005fP"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_MODES_TIEABLE_P</strong> <code class="def-code-arguments">(machine_mode <var class="var">mode1</var>, machine_mode <var class="var">mode2</var>)</code><a class="copiable-link" href="#index-TARGET_005fMODES_005fTIEABLE_005fP"> &para;</a></span></dt>
<dd><p>This hook returns true if a value of mode <var class="var">mode1</var> is accessible
in mode <var class="var">mode2</var> without copying.
</p>
<p>If <code class="code">TARGET_HARD_REGNO_MODE_OK (<var class="var">r</var>, <var class="var">mode1</var>)</code> and
<code class="code">TARGET_HARD_REGNO_MODE_OK (<var class="var">r</var>, <var class="var">mode2</var>)</code> are always
the same for any <var class="var">r</var>, then
<code class="code">TARGET_MODES_TIEABLE_P (<var class="var">mode1</var>, <var class="var">mode2</var>)</code>
should be true.  If they differ for any <var class="var">r</var>, you should define
this hook to return false unless some other mechanism ensures the
accessibility of the value in a narrower mode.
</p>
<p>You should define this hook to return true in as many cases as
possible since doing so will allow GCC to perform better register
allocation.  The default definition returns true unconditionally.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fHARD_005fREGNO_005fSCRATCH_005fOK"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_HARD_REGNO_SCRATCH_OK</strong> <code class="def-code-arguments">(unsigned int <var class="var">regno</var>)</code><a class="copiable-link" href="#index-TARGET_005fHARD_005fREGNO_005fSCRATCH_005fOK"> &para;</a></span></dt>
<dd><p>This target hook should return <code class="code">true</code> if it is OK to use a hard register
<var class="var">regno</var> as scratch reg in peephole2.
</p>
<p>One common use of this macro is to prevent using of a register that
is not saved by a prologue in an interrupt handler.
</p>
<p>The default version of this hook always returns <code class="code">true</code>.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-AVOID_005fCCMODE_005fCOPIES"><span class="category-def">Macro: </span><span><strong class="def-name">AVOID_CCMODE_COPIES</strong><a class="copiable-link" href="#index-AVOID_005fCCMODE_005fCOPIES"> &para;</a></span></dt>
<dd><p>Define this macro if the compiler should avoid copies to/from <code class="code">CCmode</code>
registers.  You should only define this macro if support for copying to/from
<code class="code">CCmode</code> is incomplete.
</p></dd></dl>

</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Leaf-Functions.html">Handling Leaf Functions</a>, Previous: <a href="Allocation-Order.html">Order of Allocation of Registers</a>, Up: <a href="Registers.html">Register Usage</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Option-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>

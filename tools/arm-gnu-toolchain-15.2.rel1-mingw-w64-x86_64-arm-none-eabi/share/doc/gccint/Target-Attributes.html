<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- Copyright Â© 1988-2025 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Funding Free Software", the Front-Cover
Texts being (a) (see below), and with the Back-Cover Texts being (b)
(see below).  A copy of the license is included in the section entitled
"GNU Free Documentation License".

(a) The FSF's Front-Cover Text is:

A GNU Manual

(b) The FSF's Back-Cover Text is:

You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development. -->
<title>Target Attributes (GNU Compiler Collection (GCC) Internals)</title>

<meta name="description" content="Target Attributes (GNU Compiler Collection (GCC) Internals)">
<meta name="keywords" content="Target Attributes (GNU Compiler Collection (GCC) Internals)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Option-Index.html" rel="index" title="Option Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Target-Macros.html" rel="up" title="Target Macros">
<link href="Emulated-TLS.html" rel="next" title="Emulated TLS">
<link href="Mode-Switching.html" rel="prev" title="Mode Switching">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>


</head>

<body lang="en">
<div class="section-level-extent" id="Target-Attributes">
<div class="nav-panel">
<p>
Next: <a href="Emulated-TLS.html" accesskey="n" rel="next">Emulating TLS</a>, Previous: <a href="Mode-Switching.html" accesskey="p" rel="prev">Mode Switching Instructions</a>, Up: <a href="Target-Macros.html" accesskey="u" rel="up">Target Description Macros and Functions</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Option-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="Defining-target_002dspecific-uses-of-_005f_005fattribute_005f_005f"><span>17.24 Defining target-specific uses of <code class="code">__attribute__</code><a class="copiable-link" href="#Defining-target_002dspecific-uses-of-_005f_005fattribute_005f_005f"> &para;</a></span></h3>
<a class="index-entry-id" id="index-target-attributes"></a>
<a class="index-entry-id" id="index-machine-attributes"></a>
<a class="index-entry-id" id="index-attributes_002c-target_002dspecific"></a>

<p>Target-specific attributes may be defined for functions, data and types.
These are described using the following target hooks; they also need to
be documented in <samp class="file">extend.texi</samp>.
</p>
<dl class="first-deftypevr">
<dt class="deftypevr" id="index-TARGET_005fATTRIBUTE_005fTABLE"><span class="category-def">Target Hook: </span><span><code class="def-type">array_slice&lt;const struct scoped_attribute_specs *const&gt;</code> <strong class="def-name">TARGET_ATTRIBUTE_TABLE</strong><a class="copiable-link" href="#index-TARGET_005fATTRIBUTE_005fTABLE"> &para;</a></span></dt>
<dd><p>If defined, this target hook provides an array of
&lsquo;<samp class="samp">scoped_attribute_spec</samp>&rsquo;s (defined in <samp class="file">attribs.h</samp>) that specify the
machine-specific attributes for this target.  The information includes some
of the restrictions on the entities to which these attributes are applied
and the arguments that the attributes take.
</p>
<p>In C and C++, these attributes are associated with two syntaxes:
the traditional GNU <code class="code">__attribute__</code> syntax and the standard
&lsquo;<samp class="samp">[[]]</samp>&rsquo; syntax.  Attributes that support the GNU syntax must be
placed in the <code class="code">gnu</code> namespace.  Such attributes can then also be
written &lsquo;<samp class="samp">[[gnu::&hellip;]]</samp>&rsquo;.  Attributes that use only the standard
syntax should be placed in whichever namespace the attribute specification
requires.  For example, a target might choose to support vendor-specific
&lsquo;<samp class="samp">[[]]</samp>&rsquo; attributes that the vendor places in their own namespace.
</p>
<p>Targets that only define attributes in the <code class="code">gnu</code> namespace
can uase the following shorthand to define the table:
</p>
<div class="example smallexample">
<pre class="example-preformatted">TARGET_GNU_ATTRIBUTES (<var class="var">cpu_attribute_table</var>, {
  { &quot;<var class="var">attribute1</var>&quot;, ... },
  { &quot;<var class="var">attribute2</var>&quot;, ... },
  ...,
  { &quot;<var class="var">attributen</var>&quot;, ... },
});
</pre></div>
</dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fATTRIBUTE_005fTAKES_005fIDENTIFIER_005fP"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_ATTRIBUTE_TAKES_IDENTIFIER_P</strong> <code class="def-code-arguments">(const_tree <var class="var">name</var>)</code><a class="copiable-link" href="#index-TARGET_005fATTRIBUTE_005fTAKES_005fIDENTIFIER_005fP"> &para;</a></span></dt>
<dd><p>If defined, this target hook is a function which returns true if the
machine-specific attribute named <var class="var">name</var> expects an identifier
given as its first argument to be passed on as a plain identifier, not
subjected to name lookup.  If this is not defined, the default is
false for all machine-specific attributes.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fCOMP_005fTYPE_005fATTRIBUTES"><span class="category-def">Target Hook: </span><span><code class="def-type">int</code> <strong class="def-name">TARGET_COMP_TYPE_ATTRIBUTES</strong> <code class="def-code-arguments">(const_tree <var class="var">type1</var>, const_tree <var class="var">type2</var>)</code><a class="copiable-link" href="#index-TARGET_005fCOMP_005fTYPE_005fATTRIBUTES"> &para;</a></span></dt>
<dd><p>If defined, this target hook is a function which returns zero if the attributes on
<var class="var">type1</var> and <var class="var">type2</var> are incompatible, one if they are compatible,
and two if they are nearly compatible (which causes a warning to be
generated).  If this is not defined, machine-specific attributes are
supposed always to be compatible.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSET_005fDEFAULT_005fTYPE_005fATTRIBUTES"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_SET_DEFAULT_TYPE_ATTRIBUTES</strong> <code class="def-code-arguments">(tree <var class="var">type</var>)</code><a class="copiable-link" href="#index-TARGET_005fSET_005fDEFAULT_005fTYPE_005fATTRIBUTES"> &para;</a></span></dt>
<dd><p>If defined, this target hook is a function which assigns default attributes to
the newly defined <var class="var">type</var>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fMERGE_005fTYPE_005fATTRIBUTES"><span class="category-def">Target Hook: </span><span><code class="def-type">tree</code> <strong class="def-name">TARGET_MERGE_TYPE_ATTRIBUTES</strong> <code class="def-code-arguments">(tree <var class="var">type1</var>, tree <var class="var">type2</var>)</code><a class="copiable-link" href="#index-TARGET_005fMERGE_005fTYPE_005fATTRIBUTES"> &para;</a></span></dt>
<dd><p>Define this target hook if the merging of type attributes needs special
handling.  If defined, the result is a list of the combined
<code class="code">TYPE_ATTRIBUTES</code> of <var class="var">type1</var> and <var class="var">type2</var>.  It is assumed
that <code class="code">comptypes</code> has already been called and returned 1.  This
function may call <code class="code">merge_attributes</code> to handle machine-independent
merging.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fMERGE_005fDECL_005fATTRIBUTES"><span class="category-def">Target Hook: </span><span><code class="def-type">tree</code> <strong class="def-name">TARGET_MERGE_DECL_ATTRIBUTES</strong> <code class="def-code-arguments">(tree <var class="var">olddecl</var>, tree <var class="var">newdecl</var>)</code><a class="copiable-link" href="#index-TARGET_005fMERGE_005fDECL_005fATTRIBUTES"> &para;</a></span></dt>
<dd><p>Define this target hook if the merging of decl attributes needs special
handling.  If defined, the result is a list of the combined
<code class="code">DECL_ATTRIBUTES</code> of <var class="var">olddecl</var> and <var class="var">newdecl</var>.
<var class="var">newdecl</var> is a duplicate declaration of <var class="var">olddecl</var>.  Examples of
when this is needed are when one attribute overrides another, or when an
attribute is nullified by a subsequent definition.  This function may
call <code class="code">merge_attributes</code> to handle machine-independent merging.
</p>
<a class="index-entry-id" id="index-TARGET_005fDLLIMPORT_005fDECL_005fATTRIBUTES"></a>
<p>If the only target-specific handling you require is &lsquo;<samp class="samp">dllimport</samp>&rsquo;
for Microsoft Windows targets, you should define the macro
<code class="code">TARGET_DLLIMPORT_DECL_ATTRIBUTES</code> to <code class="code">1</code>.  The compiler
will then define a function called
<code class="code">merge_dllimport_decl_attributes</code> which can then be defined as
the expansion of <code class="code">TARGET_MERGE_DECL_ATTRIBUTES</code>.  You can also
add <code class="code">handle_dll_attribute</code> in the attribute table for your port
to perform initial processing of the &lsquo;<samp class="samp">dllimport</samp>&rsquo; and
&lsquo;<samp class="samp">dllexport</samp>&rsquo; attributes.  This is done in <samp class="file">i386/cygwin.h</samp> and
<samp class="file">i386/i386.cc</samp>, for example.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fVALID_005fDLLIMPORT_005fATTRIBUTE_005fP"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_VALID_DLLIMPORT_ATTRIBUTE_P</strong> <code class="def-code-arguments">(const_tree <var class="var">decl</var>)</code><a class="copiable-link" href="#index-TARGET_005fVALID_005fDLLIMPORT_005fATTRIBUTE_005fP"> &para;</a></span></dt>
<dd><p><var class="var">decl</var> is a variable or function with <code class="code">__attribute__((dllimport))</code>
specified.  Use this hook if the target needs to add extra validation
checks to <code class="code">handle_dll_attribute</code>.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-TARGET_005fDECLSPEC"><span class="category-def">Macro: </span><span><strong class="def-name">TARGET_DECLSPEC</strong><a class="copiable-link" href="#index-TARGET_005fDECLSPEC"> &para;</a></span></dt>
<dd><p>Define this macro to a nonzero value if you want to treat
<code class="code">__declspec(X)</code> as equivalent to <code class="code">__attribute((X))</code>.  By
default, this behavior is enabled only for targets that define
<code class="code">TARGET_DLLIMPORT_DECL_ATTRIBUTES</code>.  The current implementation
of <code class="code">__declspec</code> is via a built-in macro, but you should not rely
on this implementation detail.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fINSERT_005fATTRIBUTES"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_INSERT_ATTRIBUTES</strong> <code class="def-code-arguments">(tree <var class="var">node</var>, tree *<var class="var">attr_ptr</var>)</code><a class="copiable-link" href="#index-TARGET_005fINSERT_005fATTRIBUTES"> &para;</a></span></dt>
<dd><p>Define this target hook if you want to be able to add attributes to a decl
when it is being created.  This is normally useful for back ends which
wish to implement a pragma by using the attributes which correspond to
the pragma&rsquo;s effect.  The <var class="var">node</var> argument is the decl which is being
created.  The <var class="var">attr_ptr</var> argument is a pointer to the attribute list
for this decl.  The list itself should not be modified, since it may be
shared with other decls, but attributes may be chained on the head of
the list and <code class="code">*<var class="var">attr_ptr</var></code> modified to point to the new
attributes, or a copy of the list may be made if further changes are
needed.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fHANDLE_005fGENERIC_005fATTRIBUTE"><span class="category-def">Target Hook: </span><span><code class="def-type">tree</code> <strong class="def-name">TARGET_HANDLE_GENERIC_ATTRIBUTE</strong> <code class="def-code-arguments">(tree *<var class="var">node</var>, tree <var class="var">name</var>, tree <var class="var">args</var>, int <var class="var">flags</var>, bool *<var class="var">no_add_attrs</var>)</code><a class="copiable-link" href="#index-TARGET_005fHANDLE_005fGENERIC_005fATTRIBUTE"> &para;</a></span></dt>
<dd><p>Define this target hook if you want to be able to perform additional
target-specific processing of an attribute which is handled generically
by a front end.  The arguments are the same as those which are passed to
attribute handlers.  So far this only affects the <var class="var">noinit</var> and
<var class="var">section</var> attribute.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fFUNCTION_005fATTRIBUTE_005fINLINABLE_005fP"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_FUNCTION_ATTRIBUTE_INLINABLE_P</strong> <code class="def-code-arguments">(const_tree <var class="var">fndecl</var>)</code><a class="copiable-link" href="#index-TARGET_005fFUNCTION_005fATTRIBUTE_005fINLINABLE_005fP"> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-inlining"></a>
<p>This target hook returns <code class="code">false</code> if the target-specific attributes on
<var class="var">fndecl</var> always block it getting inlined, <code class="code">true</code> otherwise.  By
default, if a function has a target specific attribute attached to it, it
will not be inlined.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fOPTION_005fVALID_005fATTRIBUTE_005fP"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_OPTION_VALID_ATTRIBUTE_P</strong> <code class="def-code-arguments">(tree <var class="var">fndecl</var>, tree <var class="var">name</var>, tree <var class="var">args</var>, int <var class="var">flags</var>)</code><a class="copiable-link" href="#index-TARGET_005fOPTION_005fVALID_005fATTRIBUTE_005fP"> &para;</a></span></dt>
<dd><p>This hook is called to parse <code class="code">attribute(target(&quot;...&quot;))</code>, which
allows setting target-specific options on individual functions.
These function-specific options may differ
from the options specified on the command line.  The hook should return
<code class="code">true</code> if the options are valid.
</p>
<p>The hook should set the <code class="code">DECL_FUNCTION_SPECIFIC_TARGET</code> field in
the function declaration to hold a pointer to a target-specific
<code class="code">struct cl_target_option</code> structure.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fOPTION_005fVALID_005fVERSION_005fATTRIBUTE_005fP"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_OPTION_VALID_VERSION_ATTRIBUTE_P</strong> <code class="def-code-arguments">(tree <var class="var">fndecl</var>, tree <var class="var">name</var>, tree <var class="var">args</var>, int <var class="var">flags</var>)</code><a class="copiable-link" href="#index-TARGET_005fOPTION_005fVALID_005fVERSION_005fATTRIBUTE_005fP"> &para;</a></span></dt>
<dd><p>This hook is called to parse <code class="code">attribute(target_version(&quot;...&quot;))</code>,
which allows setting target-specific options on individual function versions.
These function-specific options may differ
from the options specified on the command line.  The hook should return
<code class="code">true</code> if the options are valid.
</p>
<p>The hook should set the <code class="code">DECL_FUNCTION_SPECIFIC_TARGET</code> field in
the function declaration to hold a pointer to a target-specific
<code class="code">struct cl_target_option</code> structure.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-TARGET_005fCLONES_005fATTR_005fSEPARATOR"><span class="category-def">Macro: </span><span><strong class="def-name">TARGET_CLONES_ATTR_SEPARATOR</strong><a class="copiable-link" href="#index-TARGET_005fCLONES_005fATTR_005fSEPARATOR"> &para;</a></span></dt>
<dd><p>Define this char-typed macro to select a character that separates each
target specific attributes from the <code class="code">attribute(target_clones(&quot;...&quot;))</code>
attribute string.  This macro should be carefully chosen to avoid conflicts
with the target specific attributes.  The default value is <code class="code">','</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fOPTION_005fSAVE"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_OPTION_SAVE</strong> <code class="def-code-arguments">(struct cl_target_option *<var class="var">ptr</var>, struct gcc_options *<var class="var">opts</var>, struct gcc_options *<var class="var">opts_set</var>)</code><a class="copiable-link" href="#index-TARGET_005fOPTION_005fSAVE"> &para;</a></span></dt>
<dd><p>This hook is called to save any additional target-specific information
in the <code class="code">struct cl_target_option</code> structure for function-specific
options from the <code class="code">struct gcc_options</code> structure.
See <a class="xref" href="Option-file-format.html">Option file format</a>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fOPTION_005fRESTORE"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_OPTION_RESTORE</strong> <code class="def-code-arguments">(struct gcc_options *<var class="var">opts</var>, struct gcc_options *<var class="var">opts_set</var>, struct cl_target_option *<var class="var">ptr</var>)</code><a class="copiable-link" href="#index-TARGET_005fOPTION_005fRESTORE"> &para;</a></span></dt>
<dd><p>This hook is called to restore any additional target-specific
information in the <code class="code">struct cl_target_option</code> structure for
function-specific options to the <code class="code">struct gcc_options</code> structure.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fOPTION_005fPOST_005fSTREAM_005fIN"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_OPTION_POST_STREAM_IN</strong> <code class="def-code-arguments">(struct cl_target_option *<var class="var">ptr</var>)</code><a class="copiable-link" href="#index-TARGET_005fOPTION_005fPOST_005fSTREAM_005fIN"> &para;</a></span></dt>
<dd><p>This hook is called to update target-specific information in the
<code class="code">struct cl_target_option</code> structure after it is streamed in from
LTO bytecode.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fOPTION_005fPRINT"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_OPTION_PRINT</strong> <code class="def-code-arguments">(FILE *<var class="var">file</var>, int <var class="var">indent</var>, struct cl_target_option *<var class="var">ptr</var>)</code><a class="copiable-link" href="#index-TARGET_005fOPTION_005fPRINT"> &para;</a></span></dt>
<dd><p>This hook is called to print any additional target-specific
information in the <code class="code">struct cl_target_option</code> structure for
function-specific options.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fOPTION_005fPRAGMA_005fPARSE"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_OPTION_PRAGMA_PARSE</strong> <code class="def-code-arguments">(tree <var class="var">args</var>, tree <var class="var">pop_target</var>)</code><a class="copiable-link" href="#index-TARGET_005fOPTION_005fPRAGMA_005fPARSE"> &para;</a></span></dt>
<dd><p>This target hook parses the options for <code class="code">#pragma GCC target</code>, which
sets the target-specific options for functions that occur later in the
input stream.  The options accepted should be the same as those handled by the
<code class="code">TARGET_OPTION_VALID_ATTRIBUTE_P</code> hook.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fOPTION_005fOVERRIDE"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_OPTION_OVERRIDE</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fOPTION_005fOVERRIDE"> &para;</a></span></dt>
<dd><p>Sometimes certain combinations of command options do not make sense on
a particular target machine.  You can override the hook
<code class="code">TARGET_OPTION_OVERRIDE</code> to take account of this.  This hooks is called
once just after all the command options have been parsed.
</p>
<p>Don&rsquo;t use this hook to turn on various extra optimizations for
<samp class="option">-O</samp>.  That is what <code class="code">TARGET_OPTION_OPTIMIZATION</code> is for.
</p>
<p>If you need to do something whenever the optimization level is
changed via the optimize attribute or pragma, see
<code class="code">TARGET_OVERRIDE_OPTIONS_AFTER_CHANGE</code>
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fOPTION_005fFUNCTION_005fVERSIONS"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_OPTION_FUNCTION_VERSIONS</strong> <code class="def-code-arguments">(tree <var class="var">decl1</var>, tree <var class="var">decl2</var>)</code><a class="copiable-link" href="#index-TARGET_005fOPTION_005fFUNCTION_005fVERSIONS"> &para;</a></span></dt>
<dd><p>This target hook returns <code class="code">true</code> if <var class="var">DECL1</var> and <var class="var">DECL2</var> are
versions of the same function.  <var class="var">DECL1</var> and <var class="var">DECL2</var> are function
versions if and only if they have the same function signature and
different target specific attributes, that is, they are compiled for
different target machines.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fCAN_005fINLINE_005fP"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_CAN_INLINE_P</strong> <code class="def-code-arguments">(tree <var class="var">caller</var>, tree <var class="var">callee</var>)</code><a class="copiable-link" href="#index-TARGET_005fCAN_005fINLINE_005fP"> &para;</a></span></dt>
<dd><p>This target hook returns <code class="code">false</code> if the <var class="var">caller</var> function
cannot inline <var class="var">callee</var>, based on target specific information.  By
default, inlining is not allowed if the callee function has function
specific target options and the caller does not use the same options.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fUPDATE_005fIPA_005fFN_005fTARGET_005fINFO"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_UPDATE_IPA_FN_TARGET_INFO</strong> <code class="def-code-arguments">(unsigned int&amp; <var class="var">info</var>, const gimple* <var class="var">stmt</var>)</code><a class="copiable-link" href="#index-TARGET_005fUPDATE_005fIPA_005fFN_005fTARGET_005fINFO"> &para;</a></span></dt>
<dd><p>Allow target to analyze all gimple statements for the given function to
record and update some target specific information for inlining.  A typical
example is that a caller with one isa feature disabled is normally not
allowed to inline a callee with that same isa feature enabled even which is
attributed by always_inline, but with the conservative analysis on all
statements of the callee if we are able to guarantee the callee does not
exploit any instructions from the mismatch isa feature, it would be safe to
allow the caller to inline the callee.
<var class="var">info</var> is one <code class="code">unsigned int</code> value to record information in which
one set bit indicates one corresponding feature is detected in the analysis,
<var class="var">stmt</var> is the statement being analyzed.  Return true if target still
need to analyze the subsequent statements, otherwise return false to stop
subsequent analysis.
The default version of this hook returns false.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fNEED_005fIPA_005fFN_005fTARGET_005fINFO"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_NEED_IPA_FN_TARGET_INFO</strong> <code class="def-code-arguments">(const_tree <var class="var">decl</var>, unsigned int&amp; <var class="var">info</var>)</code><a class="copiable-link" href="#index-TARGET_005fNEED_005fIPA_005fFN_005fTARGET_005fINFO"> &para;</a></span></dt>
<dd><p>Allow target to check early whether it is necessary to analyze all gimple
statements in the given function to update target specific information for
inlining.  See hook <code class="code">update_ipa_fn_target_info</code> for usage example of
target specific information.  This hook is expected to be invoked ahead of
the iterating with hook <code class="code">update_ipa_fn_target_info</code>.
<var class="var">decl</var> is the function being analyzed, <var class="var">info</var> is the same as what
in hook <code class="code">update_ipa_fn_target_info</code>, target can do one time update
into <var class="var">info</var> without iterating for some case.  Return true if target
decides to analyze all gimple statements to collect information, otherwise
return false.
The default version of this hook returns false.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fRELAYOUT_005fFUNCTION"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_RELAYOUT_FUNCTION</strong> <code class="def-code-arguments">(tree <var class="var">fndecl</var>)</code><a class="copiable-link" href="#index-TARGET_005fRELAYOUT_005fFUNCTION"> &para;</a></span></dt>
<dd><p>This target hook fixes function <var class="var">fndecl</var> after attributes are processed.
Default does nothing. On ARM, the default function&rsquo;s alignment is updated
with the attribute target.
</p></dd></dl>

</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Emulated-TLS.html">Emulating TLS</a>, Previous: <a href="Mode-Switching.html">Mode Switching Instructions</a>, Up: <a href="Target-Macros.html">Target Description Macros and Functions</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Option-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>

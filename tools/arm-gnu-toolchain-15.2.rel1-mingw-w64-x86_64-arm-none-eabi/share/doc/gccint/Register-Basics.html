<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- Copyright Â© 1988-2025 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Funding Free Software", the Front-Cover
Texts being (a) (see below), and with the Back-Cover Texts being (b)
(see below).  A copy of the license is included in the section entitled
"GNU Free Documentation License".

(a) The FSF's Front-Cover Text is:

A GNU Manual

(b) The FSF's Back-Cover Text is:

You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development. -->
<title>Register Basics (GNU Compiler Collection (GCC) Internals)</title>

<meta name="description" content="Register Basics (GNU Compiler Collection (GCC) Internals)">
<meta name="keywords" content="Register Basics (GNU Compiler Collection (GCC) Internals)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Option-Index.html" rel="index" title="Option Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Registers.html" rel="up" title="Registers">
<link href="Allocation-Order.html" rel="next" title="Allocation Order">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>


</head>

<body lang="en">
<div class="subsection-level-extent" id="Register-Basics">
<div class="nav-panel">
<p>
Next: <a href="Allocation-Order.html" accesskey="n" rel="next">Order of Allocation of Registers</a>, Up: <a href="Registers.html" accesskey="u" rel="up">Register Usage</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Option-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h4 class="subsection" id="Basic-Characteristics-of-Registers"><span>17.7.1 Basic Characteristics of Registers<a class="copiable-link" href="#Basic-Characteristics-of-Registers"> &para;</a></span></h4>

<p>Registers have various characteristics.
</p>
<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-FIRST_005fPSEUDO_005fREGISTER"><span class="category-def">Macro: </span><span><strong class="def-name">FIRST_PSEUDO_REGISTER</strong><a class="copiable-link" href="#index-FIRST_005fPSEUDO_005fREGISTER"> &para;</a></span></dt>
<dd><p>Number of hardware registers known to the compiler.  They receive
numbers 0 through <code class="code">FIRST_PSEUDO_REGISTER-1</code>; thus, the first
pseudo register&rsquo;s number really is assigned the number
<code class="code">FIRST_PSEUDO_REGISTER</code>.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-FIXED_005fREGISTERS"><span class="category-def">Macro: </span><span><strong class="def-name">FIXED_REGISTERS</strong><a class="copiable-link" href="#index-FIXED_005fREGISTERS"> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-fixed-register"></a>
<p>An initializer that says which registers are used for fixed purposes
all throughout the compiled code and are therefore not available for
general allocation.  These would include the stack pointer, the frame
pointer (except on machines where that can be used as a general
register when no frame pointer is needed), the program counter on
machines where that is considered one of the addressable registers,
and any other numbered register with a standard use.
</p>
<p>This information is expressed as a sequence of numbers, separated by
commas and surrounded by braces.  The <var class="var">n</var>th number is 1 if
register <var class="var">n</var> is fixed, 0 otherwise.
</p>
<p>The table initialized from this macro, and the table initialized by
the following one, may be overridden at run time either automatically,
by the actions of the macro <code class="code">CONDITIONAL_REGISTER_USAGE</code>, or by
the user with the command options <samp class="option">-ffixed-<var class="var">reg</var></samp>,
<samp class="option">-fcall-used-<var class="var">reg</var></samp> and <samp class="option">-fcall-saved-<var class="var">reg</var></samp>.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-CALL_005fUSED_005fREGISTERS"><span class="category-def">Macro: </span><span><strong class="def-name">CALL_USED_REGISTERS</strong><a class="copiable-link" href="#index-CALL_005fUSED_005fREGISTERS"> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-call_002dused-register"></a>
<a class="index-entry-id" id="index-call_002dclobbered-register"></a>
<a class="index-entry-id" id="index-call_002dsaved-register"></a>
<p>Like <code class="code">FIXED_REGISTERS</code> but has 1 for each register that is
clobbered (in general) by function calls as well as for fixed
registers.  This macro therefore identifies the registers that are not
available for general allocation of values that must live across
function calls.
</p>
<p>If a register has 0 in <code class="code">CALL_USED_REGISTERS</code>, the compiler
automatically saves it on function entry and restores it on function
exit, if the register is used within the function.
</p>
<p>Exactly one of <code class="code">CALL_USED_REGISTERS</code> and <code class="code">CALL_REALLY_USED_REGISTERS</code>
must be defined.  Modern ports should define <code class="code">CALL_REALLY_USED_REGISTERS</code>.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-CALL_005fREALLY_005fUSED_005fREGISTERS"><span class="category-def">Macro: </span><span><strong class="def-name">CALL_REALLY_USED_REGISTERS</strong><a class="copiable-link" href="#index-CALL_005fREALLY_005fUSED_005fREGISTERS"> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-call_002dused-register-1"></a>
<a class="index-entry-id" id="index-call_002dclobbered-register-1"></a>
<a class="index-entry-id" id="index-call_002dsaved-register-1"></a>
<p>Like <code class="code">CALL_USED_REGISTERS</code> except this macro doesn&rsquo;t require
that the entire set of <code class="code">FIXED_REGISTERS</code> be included.
(<code class="code">CALL_USED_REGISTERS</code> must be a superset of <code class="code">FIXED_REGISTERS</code>).
</p>
<p>Exactly one of <code class="code">CALL_USED_REGISTERS</code> and <code class="code">CALL_REALLY_USED_REGISTERS</code>
must be defined.  Modern ports should define <code class="code">CALL_REALLY_USED_REGISTERS</code>.
</p></dd></dl>

<a class="index-entry-id" id="index-call_002dused-register-2"></a>
<a class="index-entry-id" id="index-call_002dclobbered-register-2"></a>
<a class="index-entry-id" id="index-call_002dsaved-register-2"></a>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fFNTYPE_005fABI"><span class="category-def">Target Hook: </span><span><code class="def-type">const predefined_function_abi &amp;</code> <strong class="def-name">TARGET_FNTYPE_ABI</strong> <code class="def-code-arguments">(const_tree <var class="var">type</var>)</code><a class="copiable-link" href="#index-TARGET_005fFNTYPE_005fABI"> &para;</a></span></dt>
<dd><p>Return the ABI used by a function with type <var class="var">type</var>; see the
definition of <code class="code">predefined_function_abi</code> for details of the ABI
descriptor.  Targets only need to define this hook if they support
interoperability between several ABIs in the same translation unit.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fINSN_005fCALLEE_005fABI"><span class="category-def">Target Hook: </span><span><code class="def-type">const predefined_function_abi &amp;</code> <strong class="def-name">TARGET_INSN_CALLEE_ABI</strong> <code class="def-code-arguments">(const rtx_insn *<var class="var">insn</var>)</code><a class="copiable-link" href="#index-TARGET_005fINSN_005fCALLEE_005fABI"> &para;</a></span></dt>
<dd><p>This hook returns a description of the ABI used by the target of
call instruction <var class="var">insn</var>; see the definition of
<code class="code">predefined_function_abi</code> for details of the ABI descriptor.
Only the global function <code class="code">insn_callee_abi</code> should call this hook
directly.
</p>
<p>Targets only need to define this hook if they support
interoperability between several ABIs in the same translation unit.
</p></dd></dl>

<a class="index-entry-id" id="index-call_002dused-register-3"></a>
<a class="index-entry-id" id="index-call_002dclobbered-register-3"></a>
<a class="index-entry-id" id="index-call_002dsaved-register-3"></a>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fHARD_005fREGNO_005fCALL_005fPART_005fCLOBBERED"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_HARD_REGNO_CALL_PART_CLOBBERED</strong> <code class="def-code-arguments">(unsigned int <var class="var">abi_id</var>, unsigned int <var class="var">regno</var>, machine_mode <var class="var">mode</var>)</code><a class="copiable-link" href="#index-TARGET_005fHARD_005fREGNO_005fCALL_005fPART_005fCLOBBERED"> &para;</a></span></dt>
<dd><p>ABIs usually specify that calls must preserve the full contents
of a particular register, or that calls can alter any part of a
particular register.  This information is captured by the target macro
<code class="code">CALL_REALLY_USED_REGISTERS</code>.  However, some ABIs specify that calls
must preserve certain bits of a particular register but can alter others.
This hook should return true if this applies to at least one of the
registers in &lsquo;<samp class="samp">(reg:<var class="var">mode</var> <var class="var">regno</var>)</samp>&rsquo;, and if as a result the
call would alter part of the <var class="var">mode</var> value.  For example, if a call
preserves the low 32 bits of a 64-bit hard register <var class="var">regno</var> but can
clobber the upper 32 bits, this hook should return true for a 64-bit mode
but false for a 32-bit mode.
</p>
<p>The value of <var class="var">abi_id</var> comes from the <code class="code">predefined_function_abi</code>
structure that describes the ABI of the call; see the definition of the
structure for more details.  If (as is usual) the target uses the same ABI
for all functions in a translation unit, <var class="var">abi_id</var> is always 0.
</p>
<p>The default implementation returns false, which is correct
for targets that don&rsquo;t have partly call-clobbered registers.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fGET_005fMULTILIB_005fABI_005fNAME"><span class="category-def">Target Hook: </span><span><code class="def-type">const char *</code> <strong class="def-name">TARGET_GET_MULTILIB_ABI_NAME</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fGET_005fMULTILIB_005fABI_005fNAME"> &para;</a></span></dt>
<dd><p>This hook returns name of multilib ABI name.
</p></dd></dl>

<a class="index-entry-id" id="index-fixed_005fregs"></a>
<a class="index-entry-id" id="index-call_005fused_005fregs"></a>
<a class="index-entry-id" id="index-global_005fregs"></a>
<a class="index-entry-id" id="index-reg_005fnames"></a>
<a class="index-entry-id" id="index-reg_005fclass_005fcontents"></a>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fCONDITIONAL_005fREGISTER_005fUSAGE"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_CONDITIONAL_REGISTER_USAGE</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fCONDITIONAL_005fREGISTER_005fUSAGE"> &para;</a></span></dt>
<dd><p>This hook may conditionally modify five variables
<code class="code">fixed_regs</code>, <code class="code">call_used_regs</code>, <code class="code">global_regs</code>,
<code class="code">reg_names</code>, and <code class="code">reg_class_contents</code>, to take into account
any dependence of these register sets on target flags.  The first three
of these are of type <code class="code">char []</code> (interpreted as boolean vectors).
<code class="code">global_regs</code> is a <code class="code">const char *[]</code>, and
<code class="code">reg_class_contents</code> is a <code class="code">HARD_REG_SET</code>.  Before the macro is
called, <code class="code">fixed_regs</code>, <code class="code">call_used_regs</code>,
<code class="code">reg_class_contents</code>, and <code class="code">reg_names</code> have been initialized
from <code class="code">FIXED_REGISTERS</code>, <code class="code">CALL_USED_REGISTERS</code>,
<code class="code">REG_CLASS_CONTENTS</code>, and <code class="code">REGISTER_NAMES</code>, respectively.
<code class="code">global_regs</code> has been cleared, and any <samp class="option">-ffixed-<var class="var">reg</var></samp>,
<samp class="option">-fcall-used-<var class="var">reg</var></samp> and <samp class="option">-fcall-saved-<var class="var">reg</var></samp>
command options have been applied.
</p>
<a class="index-entry-id" id="index-disabling-certain-registers"></a>
<a class="index-entry-id" id="index-controlling-register-usage"></a>
<p>If the usage of an entire class of registers depends on the target
flags, you may indicate this to GCC by using this macro to modify
<code class="code">fixed_regs</code> and <code class="code">call_used_regs</code> to 1 for each of the
registers in the classes which should not be used by GCC.  Also make
<code class="code">define_register_constraint</code>s return <code class="code">NO_REGS</code> for constraints
that shouldn&rsquo;t be used.
</p>
<p>(However, if this class is not included in <code class="code">GENERAL_REGS</code> and all
of the insn patterns whose constraints permit this class are
controlled by target switches, then GCC will automatically avoid using
these registers when the target switches are opposed to them.)
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-INCOMING_005fREGNO"><span class="category-def">Macro: </span><span><strong class="def-name">INCOMING_REGNO</strong> <var class="def-var-arguments">(<var class="var">out</var>)</var><a class="copiable-link" href="#index-INCOMING_005fREGNO"> &para;</a></span></dt>
<dd><p>Define this macro if the target machine has register windows.  This C
expression returns the register number as seen by the called function
corresponding to the register number <var class="var">out</var> as seen by the calling
function.  Return <var class="var">out</var> if register number <var class="var">out</var> is not an
outbound register.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-OUTGOING_005fREGNO"><span class="category-def">Macro: </span><span><strong class="def-name">OUTGOING_REGNO</strong> <var class="def-var-arguments">(<var class="var">in</var>)</var><a class="copiable-link" href="#index-OUTGOING_005fREGNO"> &para;</a></span></dt>
<dd><p>Define this macro if the target machine has register windows.  This C
expression returns the register number as seen by the calling function
corresponding to the register number <var class="var">in</var> as seen by the called
function.  Return <var class="var">in</var> if register number <var class="var">in</var> is not an inbound
register.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-LOCAL_005fREGNO"><span class="category-def">Macro: </span><span><strong class="def-name">LOCAL_REGNO</strong> <var class="def-var-arguments">(<var class="var">regno</var>)</var><a class="copiable-link" href="#index-LOCAL_005fREGNO"> &para;</a></span></dt>
<dd><p>Define this macro if the target machine has register windows.  This C
expression returns true if the register is call-saved but is in the
register window.  Unlike most call-saved registers, such registers
need not be explicitly restored on function exit or during non-local
gotos.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-PC_005fREGNUM"><span class="category-def">Macro: </span><span><strong class="def-name">PC_REGNUM</strong><a class="copiable-link" href="#index-PC_005fREGNUM"> &para;</a></span></dt>
<dd><p>If the program counter has a register number, define this as that
register number.  Otherwise, do not define it.
</p></dd></dl>

</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Allocation-Order.html">Order of Allocation of Registers</a>, Up: <a href="Registers.html">Register Usage</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Option-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>

<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- Copyright Â© 1988-2025 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Funding Free Software", the Front-Cover
Texts being (a) (see below), and with the Back-Cover Texts being (b)
(see below).  A copy of the license is included in the section entitled
"GNU Free Documentation License".

(a) The FSF's Front-Cover Text is:

A GNU Manual

(b) The FSF's Back-Cover Text is:

You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development. -->
<title>Number of iterations (GNU Compiler Collection (GCC) Internals)</title>

<meta name="description" content="Number of iterations (GNU Compiler Collection (GCC) Internals)">
<meta name="keywords" content="Number of iterations (GNU Compiler Collection (GCC) Internals)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Option-Index.html" rel="index" title="Option Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Loop-Analysis-and-Representation.html" rel="up" title="Loop Analysis and Representation">
<link href="Dependency-analysis.html" rel="next" title="Dependency analysis">
<link href="loop_002div.html" rel="prev" title="loop-iv">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
span:hover a.copiable-link {visibility: visible}
ul.mark-bullet {list-style-type: disc}
-->
</style>


</head>

<body lang="en">
<div class="section-level-extent" id="Number-of-iterations">
<div class="nav-panel">
<p>
Next: <a href="Dependency-analysis.html" accesskey="n" rel="next">Data Dependency Analysis</a>, Previous: <a href="loop_002div.html" accesskey="p" rel="prev">IV analysis on RTL</a>, Up: <a href="Loop-Analysis-and-Representation.html" accesskey="u" rel="up">Analysis and Representation of Loops</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Option-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="Number-of-iterations-analysis"><span>15.7 Number of iterations analysis<a class="copiable-link" href="#Number-of-iterations-analysis"> &para;</a></span></h3>
<a class="index-entry-id" id="index-Number-of-iterations-analysis"></a>

<p>Both on GIMPLE and on RTL, there are functions available to determine
the number of iterations of a loop, with a similar interface.  The
number of iterations of a loop in GCC is defined as the number of
executions of the loop latch.  In many cases, it is not possible to
determine the number of iterations unconditionally &ndash; the determined
number is correct only if some assumptions are satisfied.  The analysis
tries to verify these conditions using the information contained in the
program; if it fails, the conditions are returned together with the
result.  The following information and conditions are provided by the
analysis:
</p>
<ul class="itemize mark-bullet">
<li><code class="code">assumptions</code>: If this condition is false, the rest of
the information is invalid.
</li><li><code class="code">noloop_assumptions</code> on RTL, <code class="code">may_be_zero</code> on GIMPLE: If
this condition is true, the loop exits in the first iteration.
</li><li><code class="code">infinite</code>: If this condition is true, the loop is infinite.
This condition is only available on RTL.  On GIMPLE, conditions for
finiteness of the loop are included in <code class="code">assumptions</code>.
</li><li><code class="code">niter_expr</code> on RTL, <code class="code">niter</code> on GIMPLE: The expression
that gives number of iterations.  The number of iterations is defined as
the number of executions of the loop latch.
</li></ul>

<p>Both on GIMPLE and on RTL, it necessary for the induction variable
analysis framework to be initialized (SCEV on GIMPLE, loop-iv on RTL).
On GIMPLE, the results are stored to <code class="code">struct tree_niter_desc</code>
structure.  Number of iterations before the loop is exited through a
given exit can be determined using <code class="code">number_of_iterations_exit</code>
function.  On RTL, the results are returned in <code class="code">struct niter_desc</code>
structure.  The corresponding function is named
<code class="code">check_simple_exit</code>.  There are also functions that pass through
all the exits of a loop and try to find one with easy to determine
number of iterations &ndash; <code class="code">find_loop_niter</code> on GIMPLE and
<code class="code">find_simple_exit</code> on RTL.  Finally, there are functions that
provide the same information, but additionally cache it, so that
repeated calls to number of iterations are not so costly &ndash;
<code class="code">number_of_latch_executions</code> on GIMPLE and <code class="code">get_simple_loop_desc</code>
on RTL.
</p>
<p>Note that some of these functions may behave slightly differently than
others &ndash; some of them return only the expression for the number of
iterations, and fail if there are some assumptions.  The function
<code class="code">number_of_latch_executions</code> works only for single-exit loops.
The function <code class="code">number_of_cond_exit_executions</code> can be used to
determine number of executions of the exit condition of a single-exit
loop (i.e., the <code class="code">number_of_latch_executions</code> increased by one).
</p>
<p>On GIMPLE, below constraint flags affect semantics of some APIs of number
of iterations analyzer:
</p>
<ul class="itemize mark-bullet">
<li><code class="code">LOOP_C_INFINITE</code>: If this constraint flag is set, the loop
is known to be infinite.  APIs like <code class="code">number_of_iterations_exit</code> can
return false directly without doing any analysis.
</li><li><code class="code">LOOP_C_FINITE</code>: If this constraint flag is set, the loop is
known to be finite, in other words, loop&rsquo;s number of iterations can be
computed with <code class="code">assumptions</code> be true.
</li></ul>

<p>Generally, the constraint flags are set/cleared by consumers which are
loop optimizers.  It&rsquo;s also the consumers&rsquo; responsibility to set/clear
constraints correctly.  Failing to do that might result in hard to track
down bugs in scev/niter consumers.  One typical use case is vectorizer:
it drives number of iterations analyzer by setting <code class="code">LOOP_C_FINITE</code>
and vectorizes possibly infinite loop by versioning loop with analysis
result.  In return, constraints set by consumers can also help number of
iterations analyzer in following optimizers.  For example, <code class="code">niter</code>
of a loop versioned under <code class="code">assumptions</code> is valid unconditionally.
</p>
<p>Other constraints may be added in the future, for example, a constraint
indicating that loops&rsquo; latch must roll thus <code class="code">may_be_zero</code> would be
false unconditionally.
</p>
</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Dependency-analysis.html">Data Dependency Analysis</a>, Previous: <a href="loop_002div.html">IV analysis on RTL</a>, Up: <a href="Loop-Analysis-and-Representation.html">Analysis and Representation of Loops</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Option-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>

<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- Copyright Â© 1988-2025 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Funding Free Software", the Front-Cover
Texts being (a) (see below), and with the Back-Cover Texts being (b)
(see below).  A copy of the license is included in the section entitled
"GNU Free Documentation License".

(a) The FSF's Front-Cover Text is:

A GNU Manual

(b) The FSF's Back-Cover Text is:

You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development. -->
<title>Machine Modes (GNU Compiler Collection (GCC) Internals)</title>

<meta name="description" content="Machine Modes (GNU Compiler Collection (GCC) Internals)">
<meta name="keywords" content="Machine Modes (GNU Compiler Collection (GCC) Internals)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Option-Index.html" rel="index" title="Option Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="RTL.html" rel="up" title="RTL">
<link href="Constants.html" rel="next" title="Constants">
<link href="Flags.html" rel="prev" title="Flags">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
span:hover a.copiable-link {visibility: visible}
-->
</style>


</head>

<body lang="en">
<div class="section-level-extent" id="Machine-Modes">
<div class="nav-panel">
<p>
Next: <a href="Constants.html" accesskey="n" rel="next">Constant Expression Types</a>, Previous: <a href="Flags.html" accesskey="p" rel="prev">Flags in an RTL Expression</a>, Up: <a href="RTL.html" accesskey="u" rel="up">RTL Representation</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Option-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="Machine-Modes-1"><span>13.6 Machine Modes<a class="copiable-link" href="#Machine-Modes-1"> &para;</a></span></h3>
<a class="index-entry-id" id="index-machine-modes"></a>

<a class="index-entry-id" id="index-machine_005fmode"></a>
<p>A machine mode describes a size of data object and the representation used
for it.  In the C code, machine modes are represented by an enumeration
type, <code class="code">machine_mode</code>, defined in <samp class="file">machmode.def</samp>.  Each RTL
expression has room for a machine mode and so do certain kinds of tree
expressions (declarations and types, to be precise).
</p>
<p>In debugging dumps and machine descriptions, the machine mode of an RTL
expression is written after the expression code with a colon to separate
them.  The letters &lsquo;<samp class="samp">mode</samp>&rsquo; which appear at the end of each machine mode
name are omitted.  For example, <code class="code">(reg:SI 38)</code> is a <code class="code">reg</code>
expression with machine mode <code class="code">SImode</code>.  If the mode is
<code class="code">VOIDmode</code>, it is not written at all.
</p>
<p>Here is a table of machine modes.  The term &ldquo;byte&rdquo; below refers to an
object of <code class="code">BITS_PER_UNIT</code> bits (see <a class="pxref" href="Storage-Layout.html">Storage Layout</a>).
</p>
<dl class="table">
<dt><a id="index-BImode"></a><span><code class="code">BImode</code><a class="copiable-link" href="#index-BImode"> &para;</a></span></dt>
<dd><p>&ldquo;Bit&rdquo; mode represents a single bit, for predicate registers.
</p>
</dd>
<dt><a id="index-QImode"></a><span><code class="code">QImode</code><a class="copiable-link" href="#index-QImode"> &para;</a></span></dt>
<dd><p>&ldquo;Quarter-Integer&rdquo; mode represents a single byte treated as an integer.
</p>
</dd>
<dt><a id="index-HImode"></a><span><code class="code">HImode</code><a class="copiable-link" href="#index-HImode"> &para;</a></span></dt>
<dd><p>&ldquo;Half-Integer&rdquo; mode represents a two-byte integer.
</p>
</dd>
<dt><a id="index-PSImode"></a><span><code class="code">PSImode</code><a class="copiable-link" href="#index-PSImode"> &para;</a></span></dt>
<dd><p>&ldquo;Partial Single Integer&rdquo; mode represents an integer which occupies
four bytes but which doesn&rsquo;t really use all four.  On some machines,
this is the right mode to use for pointers.
</p>
</dd>
<dt><a id="index-SImode"></a><span><code class="code">SImode</code><a class="copiable-link" href="#index-SImode"> &para;</a></span></dt>
<dd><p>&ldquo;Single Integer&rdquo; mode represents a four-byte integer.
</p>
</dd>
<dt><a id="index-PDImode"></a><span><code class="code">PDImode</code><a class="copiable-link" href="#index-PDImode"> &para;</a></span></dt>
<dd><p>&ldquo;Partial Double Integer&rdquo; mode represents an integer which occupies
eight bytes but which doesn&rsquo;t really use all eight.  On some machines,
this is the right mode to use for certain pointers.
</p>
</dd>
<dt><a id="index-DImode"></a><span><code class="code">DImode</code><a class="copiable-link" href="#index-DImode"> &para;</a></span></dt>
<dd><p>&ldquo;Double Integer&rdquo; mode represents an eight-byte integer.
</p>
</dd>
<dt><a id="index-TImode"></a><span><code class="code">TImode</code><a class="copiable-link" href="#index-TImode"> &para;</a></span></dt>
<dd><p>&ldquo;Tetra Integer&rdquo; (?) mode represents a sixteen-byte integer.
</p>
</dd>
<dt><a id="index-OImode"></a><span><code class="code">OImode</code><a class="copiable-link" href="#index-OImode"> &para;</a></span></dt>
<dd><p>&ldquo;Octa Integer&rdquo; (?) mode represents a thirty-two-byte integer.
</p>
</dd>
<dt><a id="index-XImode"></a><span><code class="code">XImode</code><a class="copiable-link" href="#index-XImode"> &para;</a></span></dt>
<dd><p>&ldquo;Hexadeca Integer&rdquo; (?) mode represents a sixty-four-byte integer.
</p>
</dd>
<dt><a id="index-QFmode"></a><span><code class="code">QFmode</code><a class="copiable-link" href="#index-QFmode"> &para;</a></span></dt>
<dd><p>&ldquo;Quarter-Floating&rdquo; mode represents a quarter-precision (single byte)
floating point number.
</p>
</dd>
<dt><a id="index-HFmode"></a><span><code class="code">HFmode</code><a class="copiable-link" href="#index-HFmode"> &para;</a></span></dt>
<dd><p>&ldquo;Half-Floating&rdquo; mode represents a half-precision (two byte) floating
point number.
</p>
</dd>
<dt><a id="index-TQFmode"></a><span><code class="code">TQFmode</code><a class="copiable-link" href="#index-TQFmode"> &para;</a></span></dt>
<dd><p>&ldquo;Three-Quarter-Floating&rdquo; (?) mode represents a three-quarter-precision
(three byte) floating point number.
</p>
</dd>
<dt><a id="index-SFmode"></a><span><code class="code">SFmode</code><a class="copiable-link" href="#index-SFmode"> &para;</a></span></dt>
<dd><p>&ldquo;Single Floating&rdquo; mode represents a four byte floating point number.
In the common case, of a processor with IEEE arithmetic and 8-bit bytes,
this is a single-precision IEEE floating point number; it can also be
used for double-precision (on processors with 16-bit bytes) and
single-precision VAX and IBM types.
</p>
</dd>
<dt><a id="index-DFmode"></a><span><code class="code">DFmode</code><a class="copiable-link" href="#index-DFmode"> &para;</a></span></dt>
<dd><p>&ldquo;Double Floating&rdquo; mode represents an eight byte floating point number.
In the common case, of a processor with IEEE arithmetic and 8-bit bytes,
this is a double-precision IEEE floating point number.
</p>
</dd>
<dt><a id="index-XFmode"></a><span><code class="code">XFmode</code><a class="copiable-link" href="#index-XFmode"> &para;</a></span></dt>
<dd><p>&ldquo;Extended Floating&rdquo; mode represents an IEEE extended floating point
number.  This mode only has 80 meaningful bits (ten bytes).  Some
processors require such numbers to be padded to twelve bytes, others
to sixteen; this mode is used for either.
</p>
</dd>
<dt><a id="index-SDmode"></a><span><code class="code">SDmode</code><a class="copiable-link" href="#index-SDmode"> &para;</a></span></dt>
<dd><p>&ldquo;Single Decimal Floating&rdquo; mode represents a four byte decimal
floating point number (as distinct from conventional binary floating
point).
</p>
</dd>
<dt><a id="index-DDmode"></a><span><code class="code">DDmode</code><a class="copiable-link" href="#index-DDmode"> &para;</a></span></dt>
<dd><p>&ldquo;Double Decimal Floating&rdquo; mode represents an eight byte decimal
floating point number.
</p>
</dd>
<dt><a id="index-TDmode"></a><span><code class="code">TDmode</code><a class="copiable-link" href="#index-TDmode"> &para;</a></span></dt>
<dd><p>&ldquo;Tetra Decimal Floating&rdquo; mode represents a sixteen byte decimal
floating point number all 128 of whose bits are meaningful.
</p>
</dd>
<dt><a id="index-TFmode"></a><span><code class="code">TFmode</code><a class="copiable-link" href="#index-TFmode"> &para;</a></span></dt>
<dd><p>&ldquo;Tetra Floating&rdquo; mode represents a sixteen byte floating point number
all 128 of whose bits are meaningful.  One common use is the
IEEE quad-precision format.
</p>
</dd>
<dt><a id="index-QQmode"></a><span><code class="code">QQmode</code><a class="copiable-link" href="#index-QQmode"> &para;</a></span></dt>
<dd><p>&ldquo;Quarter-Fractional&rdquo; mode represents a single byte treated as a signed
fractional number.  The default format is &ldquo;s.7&rdquo;.
</p>
</dd>
<dt><a id="index-HQmode"></a><span><code class="code">HQmode</code><a class="copiable-link" href="#index-HQmode"> &para;</a></span></dt>
<dd><p>&ldquo;Half-Fractional&rdquo; mode represents a two-byte signed fractional number.
The default format is &ldquo;s.15&rdquo;.
</p>
</dd>
<dt><a id="index-SQmode"></a><span><code class="code">SQmode</code><a class="copiable-link" href="#index-SQmode"> &para;</a></span></dt>
<dd><p>&ldquo;Single Fractional&rdquo; mode represents a four-byte signed fractional number.
The default format is &ldquo;s.31&rdquo;.
</p>
</dd>
<dt><a id="index-DQmode"></a><span><code class="code">DQmode</code><a class="copiable-link" href="#index-DQmode"> &para;</a></span></dt>
<dd><p>&ldquo;Double Fractional&rdquo; mode represents an eight-byte signed fractional number.
The default format is &ldquo;s.63&rdquo;.
</p>
</dd>
<dt><a id="index-TQmode"></a><span><code class="code">TQmode</code><a class="copiable-link" href="#index-TQmode"> &para;</a></span></dt>
<dd><p>&ldquo;Tetra Fractional&rdquo; mode represents a sixteen-byte signed fractional number.
The default format is &ldquo;s.127&rdquo;.
</p>
</dd>
<dt><a id="index-UQQmode"></a><span><code class="code">UQQmode</code><a class="copiable-link" href="#index-UQQmode"> &para;</a></span></dt>
<dd><p>&ldquo;Unsigned Quarter-Fractional&rdquo; mode represents a single byte treated as an
unsigned fractional number.  The default format is &ldquo;.8&rdquo;.
</p>
</dd>
<dt><a id="index-UHQmode"></a><span><code class="code">UHQmode</code><a class="copiable-link" href="#index-UHQmode"> &para;</a></span></dt>
<dd><p>&ldquo;Unsigned Half-Fractional&rdquo; mode represents a two-byte unsigned fractional
number.  The default format is &ldquo;.16&rdquo;.
</p>
</dd>
<dt><a id="index-USQmode"></a><span><code class="code">USQmode</code><a class="copiable-link" href="#index-USQmode"> &para;</a></span></dt>
<dd><p>&ldquo;Unsigned Single Fractional&rdquo; mode represents a four-byte unsigned fractional
number.  The default format is &ldquo;.32&rdquo;.
</p>
</dd>
<dt><a id="index-UDQmode"></a><span><code class="code">UDQmode</code><a class="copiable-link" href="#index-UDQmode"> &para;</a></span></dt>
<dd><p>&ldquo;Unsigned Double Fractional&rdquo; mode represents an eight-byte unsigned
fractional number.  The default format is &ldquo;.64&rdquo;.
</p>
</dd>
<dt><a id="index-UTQmode"></a><span><code class="code">UTQmode</code><a class="copiable-link" href="#index-UTQmode"> &para;</a></span></dt>
<dd><p>&ldquo;Unsigned Tetra Fractional&rdquo; mode represents a sixteen-byte unsigned
fractional number.  The default format is &ldquo;.128&rdquo;.
</p>
</dd>
<dt><a id="index-HAmode"></a><span><code class="code">HAmode</code><a class="copiable-link" href="#index-HAmode"> &para;</a></span></dt>
<dd><p>&ldquo;Half-Accumulator&rdquo; mode represents a two-byte signed accumulator.
The default format is &ldquo;s8.7&rdquo;.
</p>
</dd>
<dt><a id="index-SAmode"></a><span><code class="code">SAmode</code><a class="copiable-link" href="#index-SAmode"> &para;</a></span></dt>
<dd><p>&ldquo;Single Accumulator&rdquo; mode represents a four-byte signed accumulator.
The default format is &ldquo;s16.15&rdquo;.
</p>
</dd>
<dt><a id="index-DAmode"></a><span><code class="code">DAmode</code><a class="copiable-link" href="#index-DAmode"> &para;</a></span></dt>
<dd><p>&ldquo;Double Accumulator&rdquo; mode represents an eight-byte signed accumulator.
The default format is &ldquo;s32.31&rdquo;.
</p>
</dd>
<dt><a id="index-TAmode"></a><span><code class="code">TAmode</code><a class="copiable-link" href="#index-TAmode"> &para;</a></span></dt>
<dd><p>&ldquo;Tetra Accumulator&rdquo; mode represents a sixteen-byte signed accumulator.
The default format is &ldquo;s64.63&rdquo;.
</p>
</dd>
<dt><a id="index-UHAmode"></a><span><code class="code">UHAmode</code><a class="copiable-link" href="#index-UHAmode"> &para;</a></span></dt>
<dd><p>&ldquo;Unsigned Half-Accumulator&rdquo; mode represents a two-byte unsigned accumulator.
The default format is &ldquo;8.8&rdquo;.
</p>
</dd>
<dt><a id="index-USAmode"></a><span><code class="code">USAmode</code><a class="copiable-link" href="#index-USAmode"> &para;</a></span></dt>
<dd><p>&ldquo;Unsigned Single Accumulator&rdquo; mode represents a four-byte unsigned
accumulator.  The default format is &ldquo;16.16&rdquo;.
</p>
</dd>
<dt><a id="index-UDAmode"></a><span><code class="code">UDAmode</code><a class="copiable-link" href="#index-UDAmode"> &para;</a></span></dt>
<dd><p>&ldquo;Unsigned Double Accumulator&rdquo; mode represents an eight-byte unsigned
accumulator.  The default format is &ldquo;32.32&rdquo;.
</p>
</dd>
<dt><a id="index-UTAmode"></a><span><code class="code">UTAmode</code><a class="copiable-link" href="#index-UTAmode"> &para;</a></span></dt>
<dd><p>&ldquo;Unsigned Tetra Accumulator&rdquo; mode represents a sixteen-byte unsigned
accumulator.  The default format is &ldquo;64.64&rdquo;.
</p>
</dd>
<dt><a id="index-CCmode"></a><span><code class="code">CCmode</code><a class="copiable-link" href="#index-CCmode"> &para;</a></span></dt>
<dd><p>&ldquo;Condition Code&rdquo; mode represents the value of a condition code, which
is a machine-specific set of bits used to represent the result of a
comparison operation.  Other machine-specific modes may also be used for
the condition code.  (see <a class="pxref" href="Condition-Code.html">Condition Code Status</a>).
</p>
</dd>
<dt><a id="index-BLKmode"></a><span><code class="code">BLKmode</code><a class="copiable-link" href="#index-BLKmode"> &para;</a></span></dt>
<dd><p>&ldquo;Block&rdquo; mode represents values that are aggregates to which none of
the other modes apply.  In RTL, only memory references can have this mode,
and only if they appear in string-move or vector instructions.  On machines
which have no such instructions, <code class="code">BLKmode</code> will not appear in RTL.
</p>
</dd>
<dt><a id="index-VOIDmode"></a><span><code class="code">VOIDmode</code><a class="copiable-link" href="#index-VOIDmode"> &para;</a></span></dt>
<dd><p>Void mode means the absence of a mode or an unspecified mode.
For example, RTL expressions of code <code class="code">const_int</code> have mode
<code class="code">VOIDmode</code> because they can be taken to have whatever mode the context
requires.  In debugging dumps of RTL, <code class="code">VOIDmode</code> is expressed by
the absence of any mode.
</p>
</dd>
<dt><a class="index-entry-id" id="index-HCmode"></a>
<a class="index-entry-id" id="index-SCmode"></a>
<a class="index-entry-id" id="index-DCmode"></a>
<a class="index-entry-id" id="index-XCmode"></a>
<a class="index-entry-id" id="index-TCmode"></a>
<a id="index-QCmode"></a><span><code class="code">QCmode, HCmode, SCmode, DCmode, XCmode, TCmode</code><a class="copiable-link" href="#index-QCmode"> &para;</a></span></dt>
<dd><p>These modes stand for a complex number represented as a pair of floating
point values.  The floating point values are in <code class="code">QFmode</code>,
<code class="code">HFmode</code>, <code class="code">SFmode</code>, <code class="code">DFmode</code>, <code class="code">XFmode</code>, and
<code class="code">TFmode</code>, respectively.
</p>
</dd>
<dt><a class="index-entry-id" id="index-CHImode"></a>
<a class="index-entry-id" id="index-CSImode"></a>
<a class="index-entry-id" id="index-CDImode"></a>
<a class="index-entry-id" id="index-CTImode"></a>
<a class="index-entry-id" id="index-COImode"></a>
<a class="index-entry-id" id="index-CPSImode"></a>
<a id="index-CQImode"></a><span><code class="code">CQImode, CHImode, CSImode, CDImode, CTImode, COImode, CPSImode</code><a class="copiable-link" href="#index-CQImode"> &para;</a></span></dt>
<dd><p>These modes stand for a complex number represented as a pair of integer
values.  The integer values are in <code class="code">QImode</code>, <code class="code">HImode</code>,
<code class="code">SImode</code>, <code class="code">DImode</code>, <code class="code">TImode</code>, <code class="code">OImode</code>, and <code class="code">PSImode</code>,
respectively.
</p>
</dd>
<dt><a class="index-entry-id" id="index-BND64mode"></a>
<a id="index-BND32mode"></a><span><code class="code">BND32mode BND64mode</code><a class="copiable-link" href="#index-BND32mode"> &para;</a></span></dt>
<dd><p>These modes stand for bounds for pointer of 32 and 64 bit size respectively.
Mode size is double pointer mode size.
</p></dd>
</dl>

<p>The machine description defines <code class="code">Pmode</code> as a C macro which expands
into the machine mode used for addresses.  Normally this is the mode
whose size is <code class="code">BITS_PER_WORD</code>, <code class="code">SImode</code> on 32-bit machines.
</p>
<p>The only modes which a machine description <i class="i">must</i> support are
<code class="code">QImode</code>, and the modes corresponding to <code class="code">BITS_PER_WORD</code>,
C type <code class="code">float</code> and C type <code class="code">double</code>.
The compiler will attempt to use <code class="code">DImode</code> for 8-byte structures and
unions, but this can be prevented by overriding the definition of
<code class="code">MAX_FIXED_MODE_SIZE</code>.  Alternatively, you can have the compiler
use <code class="code">TImode</code> for 16-byte structures and unions.  Likewise, you can
arrange for the C type <code class="code">short int</code> to avoid using <code class="code">HImode</code>.
</p>
<a class="index-entry-id" id="index-mode-classes"></a>
<p>Very few explicit references to machine modes remain in the compiler and
these few references will soon be removed.  Instead, the machine modes
are divided into mode classes.  These are represented by the enumeration
type <code class="code">enum mode_class</code> defined in <samp class="file">machmode.h</samp>.  The possible
mode classes are:
</p>
<dl class="table">
<dt><a id="index-MODE_005fINT"></a><span><code class="code">MODE_INT</code><a class="copiable-link" href="#index-MODE_005fINT"> &para;</a></span></dt>
<dd><p>Integer modes.  By default these are <code class="code">BImode</code>, <code class="code">QImode</code>,
<code class="code">HImode</code>, <code class="code">SImode</code>, <code class="code">DImode</code>, <code class="code">TImode</code>, and
<code class="code">OImode</code>.
</p>
</dd>
<dt><a id="index-MODE_005fPARTIAL_005fINT"></a><span><code class="code">MODE_PARTIAL_INT</code><a class="copiable-link" href="#index-MODE_005fPARTIAL_005fINT"> &para;</a></span></dt>
<dd><p>The &ldquo;partial integer&rdquo; modes, <code class="code">PQImode</code>, <code class="code">PHImode</code>,
<code class="code">PSImode</code> and <code class="code">PDImode</code>.
</p>
</dd>
<dt><a id="index-MODE_005fFLOAT"></a><span><code class="code">MODE_FLOAT</code><a class="copiable-link" href="#index-MODE_005fFLOAT"> &para;</a></span></dt>
<dd><p>Floating point modes.  By default these are <code class="code">QFmode</code>,
<code class="code">HFmode</code>, <code class="code">TQFmode</code>, <code class="code">SFmode</code>, <code class="code">DFmode</code>,
<code class="code">XFmode</code> and <code class="code">TFmode</code>.
</p>
</dd>
<dt><a id="index-MODE_005fDECIMAL_005fFLOAT"></a><span><code class="code">MODE_DECIMAL_FLOAT</code><a class="copiable-link" href="#index-MODE_005fDECIMAL_005fFLOAT"> &para;</a></span></dt>
<dd><p>Decimal floating point modes.  By default these are <code class="code">SDmode</code>,
<code class="code">DDmode</code> and <code class="code">TDmode</code>.
</p>
</dd>
<dt><a id="index-MODE_005fFRACT"></a><span><code class="code">MODE_FRACT</code><a class="copiable-link" href="#index-MODE_005fFRACT"> &para;</a></span></dt>
<dd><p>Signed fractional modes.  By default these are <code class="code">QQmode</code>, <code class="code">HQmode</code>,
<code class="code">SQmode</code>, <code class="code">DQmode</code> and <code class="code">TQmode</code>.
</p>
</dd>
<dt><a id="index-MODE_005fUFRACT"></a><span><code class="code">MODE_UFRACT</code><a class="copiable-link" href="#index-MODE_005fUFRACT"> &para;</a></span></dt>
<dd><p>Unsigned fractional modes.  By default these are <code class="code">UQQmode</code>, <code class="code">UHQmode</code>,
<code class="code">USQmode</code>, <code class="code">UDQmode</code> and <code class="code">UTQmode</code>.
</p>
</dd>
<dt><a id="index-MODE_005fACCUM"></a><span><code class="code">MODE_ACCUM</code><a class="copiable-link" href="#index-MODE_005fACCUM"> &para;</a></span></dt>
<dd><p>Signed accumulator modes.  By default these are <code class="code">HAmode</code>,
<code class="code">SAmode</code>, <code class="code">DAmode</code> and <code class="code">TAmode</code>.
</p>
</dd>
<dt><a id="index-MODE_005fUACCUM"></a><span><code class="code">MODE_UACCUM</code><a class="copiable-link" href="#index-MODE_005fUACCUM"> &para;</a></span></dt>
<dd><p>Unsigned accumulator modes.  By default these are <code class="code">UHAmode</code>,
<code class="code">USAmode</code>, <code class="code">UDAmode</code> and <code class="code">UTAmode</code>.
</p>
</dd>
<dt><a id="index-MODE_005fCOMPLEX_005fINT"></a><span><code class="code">MODE_COMPLEX_INT</code><a class="copiable-link" href="#index-MODE_005fCOMPLEX_005fINT"> &para;</a></span></dt>
<dd><p>Complex integer modes.  (These are not currently implemented).
</p>
</dd>
<dt><a id="index-MODE_005fCOMPLEX_005fFLOAT"></a><span><code class="code">MODE_COMPLEX_FLOAT</code><a class="copiable-link" href="#index-MODE_005fCOMPLEX_005fFLOAT"> &para;</a></span></dt>
<dd><p>Complex floating point modes.  By default these are <code class="code">QCmode</code>,
<code class="code">HCmode</code>, <code class="code">SCmode</code>, <code class="code">DCmode</code>, <code class="code">XCmode</code>, and
<code class="code">TCmode</code>.
</p>
</dd>
<dt><a id="index-MODE_005fCC"></a><span><code class="code">MODE_CC</code><a class="copiable-link" href="#index-MODE_005fCC"> &para;</a></span></dt>
<dd><p>Modes representing condition code values.  These are <code class="code">CCmode</code> plus
any <code class="code">CC_MODE</code> modes listed in the <samp class="file"><var class="var">machine</var>-modes.def</samp>.
See <a class="xref" href="Jump-Patterns.html">Defining Jump Instruction Patterns</a>,
also see <a class="ref" href="Condition-Code.html">Condition Code Status</a>.
</p>
</dd>
<dt><a id="index-MODE_005fPOINTER_005fBOUNDS"></a><span><code class="code">MODE_POINTER_BOUNDS</code><a class="copiable-link" href="#index-MODE_005fPOINTER_005fBOUNDS"> &para;</a></span></dt>
<dd><p>Pointer bounds modes.  Used to represent values of pointer bounds type.
Operations in these modes may be executed as NOPs depending on hardware
features and environment setup.
</p>
</dd>
<dt><a id="index-MODE_005fOPAQUE"></a><span><code class="code">MODE_OPAQUE</code><a class="copiable-link" href="#index-MODE_005fOPAQUE"> &para;</a></span></dt>
<dd><p>This is a mode class for modes that don&rsquo;t want to provide operations
other than register moves, memory moves, loads, stores, and
<code class="code">unspec</code>s. They have a size and precision and that&rsquo;s all.
</p>
</dd>
<dt><a id="index-MODE_005fRANDOM"></a><span><code class="code">MODE_RANDOM</code><a class="copiable-link" href="#index-MODE_005fRANDOM"> &para;</a></span></dt>
<dd><p>This is a catchall mode class for modes which don&rsquo;t fit into the above
classes.  Currently <code class="code">VOIDmode</code> and <code class="code">BLKmode</code> are in
<code class="code">MODE_RANDOM</code>.
</p></dd>
</dl>

<a class="index-entry-id" id="index-machine-mode-wrapper-classes"></a>
<p><code class="code">machmode.h</code> also defines various wrapper classes that combine a
<code class="code">machine_mode</code> with a static assertion that a particular
condition holds.  The classes are:
</p>
<dl class="table">
<dt><a id="index-scalar_005fint_005fmode"></a><span><code class="code">scalar_int_mode</code><a class="copiable-link" href="#index-scalar_005fint_005fmode"> &para;</a></span></dt>
<dd><p>A mode that has class <code class="code">MODE_INT</code> or <code class="code">MODE_PARTIAL_INT</code>.
</p>
</dd>
<dt><a id="index-scalar_005ffloat_005fmode"></a><span><code class="code">scalar_float_mode</code><a class="copiable-link" href="#index-scalar_005ffloat_005fmode"> &para;</a></span></dt>
<dd><p>A mode that has class <code class="code">MODE_FLOAT</code> or <code class="code">MODE_DECIMAL_FLOAT</code>.
</p>
</dd>
<dt><a id="index-scalar_005fmode"></a><span><code class="code">scalar_mode</code><a class="copiable-link" href="#index-scalar_005fmode"> &para;</a></span></dt>
<dd><p>A mode that holds a single numerical value.  In practice this means
that the mode is a <code class="code">scalar_int_mode</code>, is a <code class="code">scalar_float_mode</code>,
or has class <code class="code">MODE_FRACT</code>, <code class="code">MODE_UFRACT</code>, <code class="code">MODE_ACCUM</code>,
<code class="code">MODE_UACCUM</code> or <code class="code">MODE_POINTER_BOUNDS</code>.
</p>
</dd>
<dt><a id="index-complex_005fmode"></a><span><code class="code">complex_mode</code><a class="copiable-link" href="#index-complex_005fmode"> &para;</a></span></dt>
<dd><p>A mode that has class <code class="code">MODE_COMPLEX_INT</code> or <code class="code">MODE_COMPLEX_FLOAT</code>.
</p>
</dd>
<dt><a id="index-fixed_005fsize_005fmode"></a><span><code class="code">fixed_size_mode</code><a class="copiable-link" href="#index-fixed_005fsize_005fmode"> &para;</a></span></dt>
<dd><p>A mode whose size is known at compile time.
</p></dd>
</dl>

<p>Named modes use the most constrained of the available wrapper classes,
if one exists, otherwise they use <code class="code">machine_mode</code>.  For example,
<code class="code">QImode</code> is a <code class="code">scalar_int_mode</code>, <code class="code">SFmode</code> is a
<code class="code">scalar_float_mode</code> and <code class="code">BLKmode</code> is a plain
<code class="code">machine_mode</code>.  It is possible to refer to any mode as a raw
<code class="code">machine_mode</code> by adding the <code class="code">E_</code> prefix, where <code class="code">E</code>
stands for &ldquo;enumeration&rdquo;.  For example, the raw <code class="code">machine_mode</code>
names of the modes just mentioned are <code class="code">E_QImode</code>, <code class="code">E_SFmode</code>
and <code class="code">E_BLKmode</code> respectively.
</p>
<p>The wrapper classes implicitly convert to <code class="code">machine_mode</code> and to any
wrapper class that represents a more general condition; for example
<code class="code">scalar_int_mode</code> and <code class="code">scalar_float_mode</code> both convert
to <code class="code">scalar_mode</code> and all three convert to <code class="code">fixed_size_mode</code>.
The classes act like <code class="code">machine_mode</code>s that accept only certain
named modes.
</p>
<a class="index-entry-id" id="index-opt_005fmode"></a>
<p><samp class="file">machmode.h</samp> also defines a template class <code class="code">opt_mode&lt;<var class="var">T</var>&gt;</code>
that holds a <code class="code">T</code> or nothing, where <code class="code">T</code> can be either
<code class="code">machine_mode</code> or one of the wrapper classes above.  The main
operations on an <code class="code">opt_mode&lt;<var class="var">T</var>&gt;</code> <var class="var">x</var> are as follows:
</p>
<dl class="table">
<dt>&lsquo;<samp class="samp"><var class="var">x</var>.exists ()</samp>&rsquo;</dt>
<dd><p>Return true if <var class="var">x</var> holds a mode rather than nothing.
</p>
</dd>
<dt>&lsquo;<samp class="samp"><var class="var">x</var>.exists (&amp;<var class="var">y</var>)</samp>&rsquo;</dt>
<dd><p>Return true if <var class="var">x</var> holds a mode rather than nothing, storing the
mode in <var class="var">y</var> if so.  <var class="var">y</var> must be assignment-compatible with <var class="var">T</var>.
</p>
</dd>
<dt>&lsquo;<samp class="samp"><var class="var">x</var>.require ()</samp>&rsquo;</dt>
<dd><p>Assert that <var class="var">x</var> holds a mode rather than nothing and return that mode.
</p>
</dd>
<dt>&lsquo;<samp class="samp"><var class="var">x</var> = <var class="var">y</var></samp>&rsquo;</dt>
<dd><p>Set <var class="var">x</var> to <var class="var">y</var>, where <var class="var">y</var> is a <var class="var">T</var> or implicitly converts
to a <var class="var">T</var>.
</p></dd>
</dl>

<p>The default constructor sets an <code class="code">opt_mode&lt;<var class="var">T</var>&gt;</code> to nothing.
There is also a constructor that takes an initial value of type <var class="var">T</var>.
</p>
<p>It is possible to use the <samp class="file">is-a.h</samp> accessors on a <code class="code">machine_mode</code>
or machine mode wrapper <var class="var">x</var>:
</p>
<dl class="table">
<dt><a id="index-is_005fa"></a><span>&lsquo;<samp class="samp">is_a &lt;<var class="var">T</var>&gt; (<var class="var">x</var>)</samp>&rsquo;<a class="copiable-link" href="#index-is_005fa"> &para;</a></span></dt>
<dd><p>Return true if <var class="var">x</var> meets the conditions for wrapper class <var class="var">T</var>.
</p>
</dd>
<dt>&lsquo;<samp class="samp">is_a &lt;<var class="var">T</var>&gt; (<var class="var">x</var>, &amp;<var class="var">y</var>)</samp>&rsquo;</dt>
<dd><p>Return true if <var class="var">x</var> meets the conditions for wrapper class <var class="var">T</var>,
storing it in <var class="var">y</var> if so.  <var class="var">y</var> must be assignment-compatible with
<var class="var">T</var>.
</p>
</dd>
<dt>&lsquo;<samp class="samp">as_a &lt;<var class="var">T</var>&gt; (<var class="var">x</var>)</samp>&rsquo;</dt>
<dd><p>Assert that <var class="var">x</var> meets the conditions for wrapper class <var class="var">T</var>
and return it as a <var class="var">T</var>.
</p>
</dd>
<dt>&lsquo;<samp class="samp">dyn_cast &lt;<var class="var">T</var>&gt; (<var class="var">x</var>)</samp>&rsquo;</dt>
<dd><p>Return an <code class="code">opt_mode&lt;<var class="var">T</var>&gt;</code> that holds <var class="var">x</var> if <var class="var">x</var> meets
the conditions for wrapper class <var class="var">T</var> and that holds nothing otherwise.
</p></dd>
</dl>

<p>The purpose of these wrapper classes is to give stronger static type
checking.  For example, if a function takes a <code class="code">scalar_int_mode</code>,
a caller that has a general <code class="code">machine_mode</code> must either check or
assert that the code is indeed a scalar integer first, using one of
the functions above.
</p>
<p>The wrapper classes are normal C++ classes, with user-defined
constructors.  Sometimes it is useful to have a POD version of
the same type, particularly if the type appears in a <code class="code">union</code>.
The template class <code class="code">pod_mode&lt;<var class="var">T</var>&gt;</code> provides a POD version
of wrapper class <var class="var">T</var>.  It is assignment-compatible with <var class="var">T</var>
and implicitly converts to both <code class="code">machine_mode</code> and <var class="var">T</var>.
</p>
<p>Here are some C macros that relate to machine modes:
</p>
<dl class="table">
<dt><a id="index-GET_005fMODE"></a><span><code class="code">GET_MODE (<var class="var">x</var>)</code><a class="copiable-link" href="#index-GET_005fMODE"> &para;</a></span></dt>
<dd><p>Returns the machine mode of the RTX <var class="var">x</var>.
</p>
</dd>
<dt><a id="index-PUT_005fMODE"></a><span><code class="code">PUT_MODE (<var class="var">x</var>, <var class="var">newmode</var>)</code><a class="copiable-link" href="#index-PUT_005fMODE"> &para;</a></span></dt>
<dd><p>Alters the machine mode of the RTX <var class="var">x</var> to be <var class="var">newmode</var>.
</p>
</dd>
<dt><a id="index-NUM_005fMACHINE_005fMODES"></a><span><code class="code">NUM_MACHINE_MODES</code><a class="copiable-link" href="#index-NUM_005fMACHINE_005fMODES"> &para;</a></span></dt>
<dd><p>Stands for the number of machine modes available on the target
machine.  This is one greater than the largest numeric value of any
machine mode.
</p>
</dd>
<dt><a id="index-GET_005fMODE_005fNAME"></a><span><code class="code">GET_MODE_NAME (<var class="var">m</var>)</code><a class="copiable-link" href="#index-GET_005fMODE_005fNAME"> &para;</a></span></dt>
<dd><p>Returns the name of mode <var class="var">m</var> as a string.
</p>
</dd>
<dt><a id="index-GET_005fMODE_005fCLASS"></a><span><code class="code">GET_MODE_CLASS (<var class="var">m</var>)</code><a class="copiable-link" href="#index-GET_005fMODE_005fCLASS"> &para;</a></span></dt>
<dd><p>Returns the mode class of mode <var class="var">m</var>.
</p>
</dd>
<dt><a id="index-GET_005fMODE_005fWIDER_005fMODE"></a><span><code class="code">GET_MODE_WIDER_MODE (<var class="var">m</var>)</code><a class="copiable-link" href="#index-GET_005fMODE_005fWIDER_005fMODE"> &para;</a></span></dt>
<dd><p>Returns the next wider natural mode.  For example, the expression
<code class="code">GET_MODE_WIDER_MODE (QImode)</code> returns <code class="code">HImode</code>.
</p>
</dd>
<dt><a id="index-GET_005fMODE_005fSIZE"></a><span><code class="code">GET_MODE_SIZE (<var class="var">m</var>)</code><a class="copiable-link" href="#index-GET_005fMODE_005fSIZE"> &para;</a></span></dt>
<dd><p>Returns the size in bytes of a datum of mode <var class="var">m</var>.
</p>
</dd>
<dt><a id="index-GET_005fMODE_005fBITSIZE"></a><span><code class="code">GET_MODE_BITSIZE (<var class="var">m</var>)</code><a class="copiable-link" href="#index-GET_005fMODE_005fBITSIZE"> &para;</a></span></dt>
<dd><p>Returns the size in bits of a datum of mode <var class="var">m</var>.
</p>
</dd>
<dt><a id="index-GET_005fMODE_005fIBIT"></a><span><code class="code">GET_MODE_IBIT (<var class="var">m</var>)</code><a class="copiable-link" href="#index-GET_005fMODE_005fIBIT"> &para;</a></span></dt>
<dd><p>Returns the number of integral bits of a datum of fixed-point mode <var class="var">m</var>.
</p>
</dd>
<dt><a id="index-GET_005fMODE_005fFBIT"></a><span><code class="code">GET_MODE_FBIT (<var class="var">m</var>)</code><a class="copiable-link" href="#index-GET_005fMODE_005fFBIT"> &para;</a></span></dt>
<dd><p>Returns the number of fractional bits of a datum of fixed-point mode <var class="var">m</var>.
</p>
</dd>
<dt><a id="index-GET_005fMODE_005fMASK"></a><span><code class="code">GET_MODE_MASK (<var class="var">m</var>)</code><a class="copiable-link" href="#index-GET_005fMODE_005fMASK"> &para;</a></span></dt>
<dd><p>Returns a bitmask containing 1 for all bits in a word that fit within
mode <var class="var">m</var>.  This macro can only be used for modes whose bitsize is
less than or equal to <code class="code">HOST_BITS_PER_INT</code>.
</p>
</dd>
<dt><a id="index-GET_005fMODE_005fALIGNMENT"></a><span><code class="code">GET_MODE_ALIGNMENT (<var class="var">m</var>)</code><a class="copiable-link" href="#index-GET_005fMODE_005fALIGNMENT"> &para;</a></span></dt>
<dd><p>Return the required alignment, in bits, for an object of mode <var class="var">m</var>.
</p>
</dd>
<dt><a id="index-GET_005fMODE_005fINNER"></a><span><code class="code">GET_MODE_INNER (<var class="var">m</var>)</code><a class="copiable-link" href="#index-GET_005fMODE_005fINNER"> &para;</a></span></dt>
<dd><p>Returns the mode of the basic parts of mode <var class="var">m</var>.  For vector modes
this is the mode of the vector elements.  For complex modes it is the
mode of the real and imaginary parts.  For other modes it is mode <var class="var">m</var>
itself.
</p>
</dd>
<dt><a id="index-GET_005fMODE_005fUNIT_005fSIZE"></a><span><code class="code">GET_MODE_UNIT_SIZE (<var class="var">m</var>)</code><a class="copiable-link" href="#index-GET_005fMODE_005fUNIT_005fSIZE"> &para;</a></span></dt>
<dd><p>Returns the size in bytes of the subunits of a datum of mode <var class="var">m</var>.
This is the same as <code class="code">GET_MODE_SIZE</code> except in the case of complex
modes.  For them, the unit size is the size of the real or imaginary
part.
</p>
</dd>
<dt><a id="index-GET_005fMODE_005fNUNITS"></a><span><code class="code">GET_MODE_NUNITS (<var class="var">m</var>)</code><a class="copiable-link" href="#index-GET_005fMODE_005fNUNITS"> &para;</a></span></dt>
<dd><p>Returns the number of units contained in a mode, i.e.,
<code class="code">GET_MODE_SIZE</code> divided by <code class="code">GET_MODE_UNIT_SIZE</code>.
</p>
</dd>
<dt><a id="index-GET_005fCLASS_005fNARROWEST_005fMODE"></a><span><code class="code">GET_CLASS_NARROWEST_MODE (<var class="var">c</var>)</code><a class="copiable-link" href="#index-GET_005fCLASS_005fNARROWEST_005fMODE"> &para;</a></span></dt>
<dd><p>Returns the narrowest mode in mode class <var class="var">c</var>.
</p></dd>
</dl>

<p>The following 3 variables are defined on every target.   They can be
used to allocate buffers that are guaranteed to be large enough to
hold any value that can be represented on the target.   The first two
can be overridden by defining them in the target&rsquo;s mode.def file,
however, the value must be a constant that can determined very early
in the compilation process.   The third symbol cannot be overridden.
</p>
<dl class="table">
<dt><a id="index-BITS_005fPER_005fUNIT"></a><span><code class="code">BITS_PER_UNIT</code><a class="copiable-link" href="#index-BITS_005fPER_005fUNIT"> &para;</a></span></dt>
<dd><p>The number of bits in an addressable storage unit (byte).  If you do
not define this, the default is 8.
</p>
</dd>
<dt><a id="index-MAX_005fBITSIZE_005fMODE_005fANY_005fINT"></a><span><code class="code">MAX_BITSIZE_MODE_ANY_INT</code><a class="copiable-link" href="#index-MAX_005fBITSIZE_005fMODE_005fANY_005fINT"> &para;</a></span></dt>
<dd><p>The maximum bitsize of any mode that is used in integer math.  This
should be overridden by the target if it uses large integers as
containers for larger vectors but otherwise never uses the contents to
compute integer values.
</p>
</dd>
<dt><a id="index-MAX_005fBITSIZE_005fMODE_005fANY_005fMODE"></a><span><code class="code">MAX_BITSIZE_MODE_ANY_MODE</code><a class="copiable-link" href="#index-MAX_005fBITSIZE_005fMODE_005fANY_005fMODE"> &para;</a></span></dt>
<dd><p>The bitsize of the largest mode on the target.  The default value is
the largest mode size given in the mode definition file, which is
always correct for targets whose modes have a fixed size.  Targets
that might increase the size of a mode beyond this default should define
<code class="code">MAX_BITSIZE_MODE_ANY_MODE</code> to the actual upper limit in
<samp class="file"><var class="var">machine</var>-modes.def</samp>.
</p></dd>
</dl>

<a class="index-entry-id" id="index-byte_005fmode"></a>
<a class="index-entry-id" id="index-word_005fmode"></a>
<p>The global variables <code class="code">byte_mode</code> and <code class="code">word_mode</code> contain modes
whose classes are <code class="code">MODE_INT</code> and whose bitsizes are either
<code class="code">BITS_PER_UNIT</code> or <code class="code">BITS_PER_WORD</code>, respectively.  On 32-bit
machines, these are <code class="code">QImode</code> and <code class="code">SImode</code>, respectively.
</p>
</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Constants.html">Constant Expression Types</a>, Previous: <a href="Flags.html">Flags in an RTL Expression</a>, Up: <a href="RTL.html">RTL Representation</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Option-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>

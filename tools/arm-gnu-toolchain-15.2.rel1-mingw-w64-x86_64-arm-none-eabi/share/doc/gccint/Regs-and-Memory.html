<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- Copyright Â© 1988-2025 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Funding Free Software", the Front-Cover
Texts being (a) (see below), and with the Back-Cover Texts being (b)
(see below).  A copy of the license is included in the section entitled
"GNU Free Documentation License".

(a) The FSF's Front-Cover Text is:

A GNU Manual

(b) The FSF's Back-Cover Text is:

You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development. -->
<title>Regs and Memory (GNU Compiler Collection (GCC) Internals)</title>

<meta name="description" content="Regs and Memory (GNU Compiler Collection (GCC) Internals)">
<meta name="keywords" content="Regs and Memory (GNU Compiler Collection (GCC) Internals)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Option-Index.html" rel="index" title="Option Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="RTL.html" rel="up" title="RTL">
<link href="Arithmetic.html" rel="next" title="Arithmetic">
<link href="Constants.html" rel="prev" title="Constants">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
ul.mark-bullet {list-style-type: disc}
-->
</style>


</head>

<body lang="en">
<div class="section-level-extent" id="Regs-and-Memory">
<div class="nav-panel">
<p>
Next: <a href="Arithmetic.html" accesskey="n" rel="next">RTL Expressions for Arithmetic</a>, Previous: <a href="Constants.html" accesskey="p" rel="prev">Constant Expression Types</a>, Up: <a href="RTL.html" accesskey="u" rel="up">RTL Representation</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Option-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="Registers-and-Memory"><span>13.8 Registers and Memory<a class="copiable-link" href="#Registers-and-Memory"> &para;</a></span></h3>
<a class="index-entry-id" id="index-RTL-register-expressions"></a>
<a class="index-entry-id" id="index-RTL-memory-expressions"></a>

<p>Here are the RTL expression types for describing access to machine
registers and to main memory.
</p>
<dl class="table">
<dt><a class="index-entry-id" id="index-hard-registers"></a>
<a class="index-entry-id" id="index-pseudo-registers"></a>
<a id="index-reg"></a><span><code class="code">(reg:<var class="var">m</var> <var class="var">n</var>)</code><a class="copiable-link" href="#index-reg"> &para;</a></span></dt>
<dd><p>For small values of the integer <var class="var">n</var> (those that are less than
<code class="code">FIRST_PSEUDO_REGISTER</code>), this stands for a reference to machine
register number <var class="var">n</var>: a <em class="dfn">hard register</em>.  For larger values of
<var class="var">n</var>, it stands for a temporary value or <em class="dfn">pseudo register</em>.
The compiler&rsquo;s strategy is to generate code assuming an unlimited
number of such pseudo registers, and later convert them into hard
registers or into memory references.
</p>
<p><var class="var">m</var> is the machine mode of the reference.  It is necessary because
machines can generally refer to each register in more than one mode.
For example, a register may contain a full word but there may be
instructions to refer to it as a half word or as a single byte, as
well as instructions to refer to it as a floating point number of
various precisions.
</p>
<p>Even for a register that the machine can access in only one mode,
the mode must always be specified.
</p>
<p>The symbol <code class="code">FIRST_PSEUDO_REGISTER</code> is defined by the machine
description, since the number of hard registers on the machine is an
invariant characteristic of the machine.  Note, however, that not
all of the machine registers must be general registers.  All the
machine registers that can be used for storage of data are given
hard register numbers, even those that can be used only in certain
instructions or can hold only certain types of data.
</p>
<p>A hard register may be accessed in various modes throughout one
function, but each pseudo register is given a natural mode
and is accessed only in that mode.  When it is necessary to describe
an access to a pseudo register using a nonnatural mode, a <code class="code">subreg</code>
expression is used.
</p>
<p>A <code class="code">reg</code> expression with a machine mode that specifies more than
one word of data may actually stand for several consecutive registers.
If in addition the register number specifies a hardware register, then
it actually represents several consecutive hardware registers starting
with the specified one.
</p>
<p>Each pseudo register number used in a function&rsquo;s RTL code is
represented by a unique <code class="code">reg</code> expression.
</p>
<a class="index-entry-id" id="index-FIRST_005fVIRTUAL_005fREGISTER"></a>
<a class="index-entry-id" id="index-LAST_005fVIRTUAL_005fREGISTER"></a>
<p>Some pseudo register numbers, those within the range of
<code class="code">FIRST_VIRTUAL_REGISTER</code> to <code class="code">LAST_VIRTUAL_REGISTER</code> only
appear during the RTL generation phase and are eliminated before the
optimization phases.  These represent locations in the stack frame that
cannot be determined until RTL generation for the function has been
completed.  The following virtual register numbers are defined:
</p>
<dl class="table">
<dt><a id="index-VIRTUAL_005fINCOMING_005fARGS_005fREGNUM"></a><span><code class="code">VIRTUAL_INCOMING_ARGS_REGNUM</code><a class="copiable-link" href="#index-VIRTUAL_005fINCOMING_005fARGS_005fREGNUM"> &para;</a></span></dt>
<dd><p>This points to the first word of the incoming arguments passed on the
stack.  Normally these arguments are placed there by the caller, but the
callee may have pushed some arguments that were previously passed in
registers.
</p>
<a class="index-entry-id" id="index-FIRST_005fPARM_005fOFFSET-and-virtual-registers"></a>
<a class="index-entry-id" id="index-ARG_005fPOINTER_005fREGNUM-and-virtual-registers"></a>
<p>When RTL generation is complete, this virtual register is replaced
by the sum of the register given by <code class="code">ARG_POINTER_REGNUM</code> and the
value of <code class="code">FIRST_PARM_OFFSET</code>.
</p>
</dd>
<dt><a class="index-entry-id" id="index-FRAME_005fGROWS_005fDOWNWARD-and-virtual-registers"></a>
<a id="index-VIRTUAL_005fSTACK_005fVARS_005fREGNUM"></a><span><code class="code">VIRTUAL_STACK_VARS_REGNUM</code><a class="copiable-link" href="#index-VIRTUAL_005fSTACK_005fVARS_005fREGNUM"> &para;</a></span></dt>
<dd><p>If <code class="code">FRAME_GROWS_DOWNWARD</code> is defined to a nonzero value, this points
to immediately above the first variable on the stack.  Otherwise, it points
to the first variable on the stack.
</p>
<a class="index-entry-id" id="index-TARGET_005fSTARTING_005fFRAME_005fOFFSET-and-virtual-registers"></a>
<a class="index-entry-id" id="index-FRAME_005fPOINTER_005fREGNUM-and-virtual-registers"></a>
<p><code class="code">VIRTUAL_STACK_VARS_REGNUM</code> is replaced with the sum of the
register given by <code class="code">FRAME_POINTER_REGNUM</code> and the value
<code class="code">TARGET_STARTING_FRAME_OFFSET</code>.
</p>
</dd>
<dt><a id="index-VIRTUAL_005fSTACK_005fDYNAMIC_005fREGNUM"></a><span><code class="code">VIRTUAL_STACK_DYNAMIC_REGNUM</code><a class="copiable-link" href="#index-VIRTUAL_005fSTACK_005fDYNAMIC_005fREGNUM"> &para;</a></span></dt>
<dd><p>This points to the location of dynamically allocated memory on the stack
immediately after the stack pointer has been adjusted by the amount of
memory desired.
</p>
<a class="index-entry-id" id="index-STACK_005fDYNAMIC_005fOFFSET-and-virtual-registers"></a>
<a class="index-entry-id" id="index-STACK_005fPOINTER_005fREGNUM-and-virtual-registers"></a>
<p>This virtual register is replaced by the sum of the register given by
<code class="code">STACK_POINTER_REGNUM</code> and the value <code class="code">STACK_DYNAMIC_OFFSET</code>.
</p>
</dd>
<dt><a id="index-VIRTUAL_005fOUTGOING_005fARGS_005fREGNUM"></a><span><code class="code">VIRTUAL_OUTGOING_ARGS_REGNUM</code><a class="copiable-link" href="#index-VIRTUAL_005fOUTGOING_005fARGS_005fREGNUM"> &para;</a></span></dt>
<dd><p>This points to the location in the stack at which outgoing arguments
should be written when the stack is pre-pushed (arguments pushed using
push insns should always use <code class="code">STACK_POINTER_REGNUM</code>).
</p>
<a class="index-entry-id" id="index-STACK_005fPOINTER_005fOFFSET-and-virtual-registers"></a>
<p>This virtual register is replaced by the sum of the register given by
<code class="code">STACK_POINTER_REGNUM</code> and the value <code class="code">STACK_POINTER_OFFSET</code>.
</p></dd>
</dl>

</dd>
<dt><a id="index-subreg"></a><span><code class="code">(subreg:<var class="var">m1</var> <var class="var">reg:m2</var> <var class="var">bytenum</var>)</code><a class="copiable-link" href="#index-subreg"> &para;</a></span></dt>
<dd>
<p><code class="code">subreg</code> expressions are used to refer to a register in a machine
mode other than its natural one, or to refer to one register of
a multi-part <code class="code">reg</code> that actually refers to several registers.
</p>
<p>Each pseudo register has a natural mode.  If it is necessary to
operate on it in a different mode, the register must be
enclosed in a <code class="code">subreg</code>.
</p>
<p>There are currently three supported types for the first operand of a
<code class="code">subreg</code>:
</p><ul class="itemize mark-bullet">
<li>pseudo registers
This is the most common case.  Most <code class="code">subreg</code>s have pseudo
<code class="code">reg</code>s as their first operand.

</li><li>mem
<code class="code">subreg</code>s of <code class="code">mem</code> were common in earlier versions of GCC and
are still supported.  During the reload pass these are replaced by plain
<code class="code">mem</code>s.  On machines that do not do instruction scheduling, use of
<code class="code">subreg</code>s of <code class="code">mem</code> are still used, but this is no longer
recommended.  Such <code class="code">subreg</code>s are considered to be
<code class="code">register_operand</code>s rather than <code class="code">memory_operand</code>s before and
during reload.  Because of this, the scheduling passes cannot properly
schedule instructions with <code class="code">subreg</code>s of <code class="code">mem</code>, so for machines
that do scheduling, <code class="code">subreg</code>s of <code class="code">mem</code> should never be used.
To support this, the combine and recog passes have explicit code to
inhibit the creation of <code class="code">subreg</code>s of <code class="code">mem</code> when
<code class="code">INSN_SCHEDULING</code> is defined.

<p>The use of <code class="code">subreg</code>s of <code class="code">mem</code> after the reload pass is an area
that is not well understood and should be avoided.  There is still some
code in the compiler to support this, but this code has possibly rotted.
This use of <code class="code">subreg</code>s is discouraged and will most likely not be
supported in the future.
</p>
</li><li>hard registers
It is seldom necessary to wrap hard registers in <code class="code">subreg</code>s; such
registers would normally reduce to a single <code class="code">reg</code> rtx.  This use of
<code class="code">subreg</code>s is discouraged and may not be supported in the future.

</li></ul>

<p><code class="code">subreg</code>s of <code class="code">subreg</code>s are not supported.  Using
<code class="code">simplify_gen_subreg</code> is the recommended way to avoid this problem.
</p>
<p><code class="code">subreg</code>s come in two distinct flavors, each having its own
usage and rules:
</p>
<dl class="table">
<dt>Paradoxical subregs</dt>
<dd><p>When <var class="var">m1</var> is strictly wider than <var class="var">m2</var>, the <code class="code">subreg</code>
expression is called <em class="dfn">paradoxical</em>.  The canonical test for this
class of <code class="code">subreg</code> is:
</p>
<div class="example smallexample">
<pre class="example-preformatted">paradoxical_subreg_p (<var class="var">m1</var>, <var class="var">m2</var>)
</pre></div>

<p>Paradoxical <code class="code">subreg</code>s can be used as both lvalues and rvalues.
When used as an lvalue, the low-order bits of the source value
are stored in <var class="var">reg</var> and the high-order bits are discarded.
When used as an rvalue, the low-order bits of the <code class="code">subreg</code> are
taken from <var class="var">reg</var> while the high-order bits may or may not be
defined.
</p>
<p>The high-order bits of rvalues are defined in the following circumstances:
</p>
<ul class="itemize mark-bullet">
<li><code class="code">subreg</code>s of <code class="code">mem</code>
When <var class="var">m2</var> is smaller than a word, the macro <code class="code">LOAD_EXTEND_OP</code>,
can control how the high-order bits are defined.

</li><li><code class="code">subreg</code> of <code class="code">reg</code>s
The upper bits are defined when <code class="code">SUBREG_PROMOTED_VAR_P</code> is true.
<code class="code">SUBREG_PROMOTED_UNSIGNED_P</code> describes what the upper bits hold.
Such subregs usually represent local variables, register variables
and parameter pseudo variables that have been promoted to a wider mode.

</li></ul>

<p><var class="var">bytenum</var> is always zero for a paradoxical <code class="code">subreg</code>, even on
big-endian targets.
</p>
<p>For example, the paradoxical <code class="code">subreg</code>:
</p>
<div class="example smallexample">
<pre class="example-preformatted">(set (subreg:SI (reg:HI <var class="var">x</var>) 0) <var class="var">y</var>)
</pre></div>

<p>stores the lower 2 bytes of <var class="var">y</var> in <var class="var">x</var> and discards the upper
2 bytes.  A subsequent:
</p>
<div class="example smallexample">
<pre class="example-preformatted">(set <var class="var">z</var> (subreg:SI (reg:HI <var class="var">x</var>) 0))
</pre></div>

<p>would set the lower two bytes of <var class="var">z</var> to <var class="var">y</var> and set the upper
two bytes to an unknown value assuming <code class="code">SUBREG_PROMOTED_VAR_P</code> is
false.
</p>
</dd>
<dt>Normal subregs</dt>
<dd><p>When <var class="var">m1</var> is at least as narrow as <var class="var">m2</var> the <code class="code">subreg</code>
expression is called <em class="dfn">normal</em>.
</p>
<a class="index-entry-id" id="index-REGMODE_005fNATURAL_005fSIZE"></a>
<p>Normal <code class="code">subreg</code>s restrict consideration to certain bits of
<var class="var">reg</var>.  For this purpose, <var class="var">reg</var> is divided into
individually-addressable blocks in which each block has:
</p>
<div class="example smallexample">
<pre class="example-preformatted">REGMODE_NATURAL_SIZE (<var class="var">m2</var>)
</pre></div>

<p>bytes.  Usually the value is <code class="code">UNITS_PER_WORD</code>; that is,
most targets usually treat each word of a register as being
independently addressable.
</p>
<p>There are two types of normal <code class="code">subreg</code>.  If <var class="var">m1</var> is known
to be no bigger than a block, the <code class="code">subreg</code> refers to the
least-significant part (or <em class="dfn">lowpart</em>) of one block of <var class="var">reg</var>.
If <var class="var">m1</var> is known to be larger than a block, the <code class="code">subreg</code> refers
to two or more complete blocks.
</p>
<p>When used as an lvalue, <code class="code">subreg</code> is a block-based accessor.
Storing to a <code class="code">subreg</code> modifies all the blocks of <var class="var">reg</var> that
overlap the <code class="code">subreg</code>, but it leaves the other blocks of <var class="var">reg</var>
alone.
</p>
<p>When storing to a normal <code class="code">subreg</code> that is smaller than a block,
the other bits of the referenced block are usually left in an undefined
state.  This laxity makes it easier to generate efficient code for
such instructions.  To represent an instruction that preserves all the
bits outside of those in the <code class="code">subreg</code>, use <code class="code">strict_low_part</code>
or <code class="code">zero_extract</code> around the <code class="code">subreg</code>.
</p>
<p><var class="var">bytenum</var> must identify the offset of the first byte of the
<code class="code">subreg</code> from the start of <var class="var">reg</var>, assuming that <var class="var">reg</var> is
laid out in memory order.  The memory order of bytes is defined by
two target macros, <code class="code">WORDS_BIG_ENDIAN</code> and <code class="code">BYTES_BIG_ENDIAN</code>:
</p>
<ul class="itemize mark-bullet">
<li><a class="index-entry-id" id="index-WORDS_005fBIG_005fENDIAN_002c-effect-on-subreg"></a>
<code class="code">WORDS_BIG_ENDIAN</code>, if set to 1, says that byte number zero is
part of the most significant word; otherwise, it is part of the least
significant word.

</li><li><a class="index-entry-id" id="index-BYTES_005fBIG_005fENDIAN_002c-effect-on-subreg"></a>
<code class="code">BYTES_BIG_ENDIAN</code>, if set to 1, says that byte number zero is
the most significant byte within a word; otherwise, it is the least
significant byte within a word.
</li></ul>

<a class="index-entry-id" id="index-FLOAT_005fWORDS_005fBIG_005fENDIAN_002c-_0028lack-of_0029-effect-on-subreg"></a>
<p>On a few targets, <code class="code">FLOAT_WORDS_BIG_ENDIAN</code> disagrees with
<code class="code">WORDS_BIG_ENDIAN</code>.  However, most parts of the compiler treat
floating point values as if they had the same endianness as integer
values.  This works because they handle them solely as a collection of
integer values, with no particular numerical value.  Only real.cc and
the runtime libraries care about <code class="code">FLOAT_WORDS_BIG_ENDIAN</code>.
</p>
<p>Thus,
</p>
<div class="example smallexample">
<pre class="example-preformatted">(subreg:HI (reg:SI <var class="var">x</var>) 2)
</pre></div>

<p>on a <code class="code">BYTES_BIG_ENDIAN</code>, &lsquo;<samp class="samp">UNITS_PER_WORD == 4</samp>&rsquo; target is the same as
</p>
<div class="example smallexample">
<pre class="example-preformatted">(subreg:HI (reg:SI <var class="var">x</var>) 0)
</pre></div>

<p>on a little-endian, &lsquo;<samp class="samp">UNITS_PER_WORD == 4</samp>&rsquo; target.  Both
<code class="code">subreg</code>s access the lower two bytes of register <var class="var">x</var>.
</p>
<p>Note that the byte offset is a polynomial integer; it may not be a
compile-time constant on targets with variable-sized modes.  However,
the restrictions above mean that there are only a certain set of
acceptable offsets for a given combination of <var class="var">m1</var> and <var class="var">m2</var>.
The compiler can always tell which blocks a valid subreg occupies, and
whether the subreg is a lowpart of a block.
</p>
</dd>
</dl>

<p>A <code class="code">MODE_PARTIAL_INT</code> mode behaves as if it were as wide as the
corresponding <code class="code">MODE_INT</code> mode, except that it has a number of
undefined bits, which are determined by the precision of the
mode.
</p>
<p>For example, on a little-endian target which defines <code class="code">PSImode</code>
to have a precision of 20 bits:
</p>
<div class="example smallexample">
<pre class="example-preformatted">(subreg:PSI (reg:SI 0) 0)
</pre></div>

<p>accesses the low 20 bits of &lsquo;<samp class="samp">(reg:SI 0)</samp>&rsquo;.
</p>
<a class="index-entry-id" id="index-REGMODE_005fNATURAL_005fSIZE-1"></a>
<p>Continuing with a <code class="code">PSImode</code> precision of 20 bits, if we assume
&lsquo;<samp class="samp">REGMODE_NATURAL_SIZE (DImode) &lt;= 4</samp>&rsquo;,
then the following two <code class="code">subreg</code>s:
</p>
<div class="example smallexample">
<pre class="example-preformatted">(subreg:PSI (reg:DI 0) 0)
(subreg:PSI (reg:DI 0) 4)
</pre></div>

<p>represent accesses to the low 20 bits of the two halves of
&lsquo;<samp class="samp">(reg:DI 0)</samp>&rsquo;.
</p>
<p>If &lsquo;<samp class="samp">REGMODE_NATURAL_SIZE (PSImode) &lt;= 2</samp>&rsquo; then these two <code class="code">subreg</code>s:
</p>
<div class="example smallexample">
<pre class="example-preformatted">(subreg:HI (reg:PSI 0) 0)
(subreg:HI (reg:PSI 0) 2)
</pre></div>

<p>represent independent 2-byte accesses that together span the whole
of &lsquo;<samp class="samp">(reg:PSI 0)</samp>&rsquo;.  Storing to the first <code class="code">subreg</code> does not
affect the value of the second, and vice versa, so the assignment:
</p>
<div class="example smallexample">
<pre class="example-preformatted">(set (subreg:HI (reg:PSI 0) 0) (reg:HI 4))
</pre></div>

<p>sets the low 16 bits of &lsquo;<samp class="samp">(reg:PSI 0)</samp>&rsquo; to &lsquo;<samp class="samp">(reg:HI 4)</samp>&rsquo;, and
the high 4 defined bits of &lsquo;<samp class="samp">(reg:PSI 0)</samp>&rsquo; retain their
original value.  The behavior here is the same as for
normal <code class="code">subreg</code>s, when there are no
<code class="code">MODE_PARTIAL_INT</code> modes involved.
</p>
<a class="index-entry-id" id="index-TARGET_005fCAN_005fCHANGE_005fMODE_005fCLASS-and-subreg-semantics"></a>
<p>The rules above apply to both pseudo <var class="var">reg</var>s and hard <var class="var">reg</var>s.
If the semantics are not correct for particular combinations of
<var class="var">m1</var>, <var class="var">m2</var> and hard <var class="var">reg</var>, the target-specific code
must ensure that those combinations are never used.  For example:
</p>
<div class="example smallexample">
<pre class="example-preformatted">TARGET_CAN_CHANGE_MODE_CLASS (<var class="var">m2</var>, <var class="var">m1</var>, <var class="var">class</var>)
</pre></div>

<p>must be false for every class <var class="var">class</var> that includes <var class="var">reg</var>.
</p>
<p>GCC must be able to determine at compile time whether a subreg is
paradoxical, whether it occupies a whole number of blocks, or whether
it is a lowpart of a block.  This means that certain combinations of
variable-sized mode are not permitted.  For example, if <var class="var">m2</var>
holds <var class="var">n</var> <code class="code">SI</code> values, where <var class="var">n</var> is greater than zero,
it is not possible to form a <code class="code">DI</code> <code class="code">subreg</code> of it; such a
<code class="code">subreg</code> would be paradoxical when <var class="var">n</var> is 1 but not when
<var class="var">n</var> is greater than 1.
</p>
<a class="index-entry-id" id="index-SUBREG_005fREG"></a>
<a class="index-entry-id" id="index-SUBREG_005fBYTE"></a>
<p>The first operand of a <code class="code">subreg</code> expression is customarily accessed
with the <code class="code">SUBREG_REG</code> macro and the second operand is customarily
accessed with the <code class="code">SUBREG_BYTE</code> macro.
</p>
<p>It has been several years since a platform in which
<code class="code">BYTES_BIG_ENDIAN</code> not equal to <code class="code">WORDS_BIG_ENDIAN</code> has
been tested.  Anyone wishing to support such a platform in the future
may be confronted with code rot.
</p>
</dd>
<dt><a class="index-entry-id" id="index-scratch-operands"></a>
<a id="index-scratch"></a><span><code class="code">(scratch:<var class="var">m</var>)</code><a class="copiable-link" href="#index-scratch"> &para;</a></span></dt>
<dd><p>This represents a scratch register that will be required for the
execution of a single instruction and not used subsequently.  It is
converted into a <code class="code">reg</code> by either the local register allocator or
the reload pass.
</p>
<p><code class="code">scratch</code> is usually present inside a <code class="code">clobber</code> operation
(see <a class="pxref" href="Side-Effects.html">Side Effect Expressions</a>).
</p>
<p>On some machines, the condition code register is given a register number
and a <code class="code">reg</code> is used.
Other machines store condition codes in general
registers; in such cases a pseudo register should be used.
</p>
<p>Some machines, such as the SPARC and RS/6000, have two sets of
arithmetic instructions, one that sets and one that does not set the
condition code.  This is best handled by normally generating the
instruction that does not set the condition code, and making a pattern
that both performs the arithmetic and sets the condition code register.
For examples, search for &lsquo;<samp class="samp">addcc</samp>&rsquo; and &lsquo;<samp class="samp">andcc</samp>&rsquo; in <samp class="file">sparc.md</samp>.
</p>
</dd>
<dt><a class="index-entry-id" id="index-program-counter"></a>
<a id="index-pc"></a><span><code class="code">(pc)</code><a class="copiable-link" href="#index-pc"> &para;</a></span></dt>
<dd><p>This represents the machine&rsquo;s program counter.  It has no operands and
may not have a machine mode.  <code class="code">(pc)</code> may be validly used only in
certain specific contexts in jump instructions.
</p>
<a class="index-entry-id" id="index-pc_005frtx"></a>
<p>There is only one expression object of code <code class="code">pc</code>; it is the value
of the variable <code class="code">pc_rtx</code>.  Any attempt to create an expression of
code <code class="code">pc</code> will return <code class="code">pc_rtx</code>.
</p>
<p>All instructions that do not jump alter the program counter implicitly
by incrementing it, but there is no need to mention this in the RTL.
</p>
</dd>
<dt><a id="index-mem"></a><span><code class="code">(mem:<var class="var">m</var> <var class="var">addr</var> <var class="var">alias</var>)</code><a class="copiable-link" href="#index-mem"> &para;</a></span></dt>
<dd><p>This RTX represents a reference to main memory at an address
represented by the expression <var class="var">addr</var>.  <var class="var">m</var> specifies how large
a unit of memory is accessed.  <var class="var">alias</var> specifies an alias set for the
reference.  In general two items are in different alias sets if they cannot
reference the same memory address.
</p>
<p>The construct <code class="code">(mem:BLK (scratch))</code> is considered to alias all
other memories.  Thus it may be used as a memory barrier in epilogue
stack deallocation patterns.
</p>
</dd>
<dt><a id="index-concat"></a><span><code class="code">(concat<var class="var">m</var> <var class="var">rtx</var> <var class="var">rtx</var>)</code><a class="copiable-link" href="#index-concat"> &para;</a></span></dt>
<dd><p>This RTX represents the concatenation of two other RTXs.  This is used
for complex values.  It should only appear in the RTL attached to
declarations and during RTL generation.  It should not appear in the
ordinary insn chain.
</p>
</dd>
<dt><a id="index-concatn"></a><span><code class="code">(concatn<var class="var">m</var> [<var class="var">rtx</var> &hellip;])</code><a class="copiable-link" href="#index-concatn"> &para;</a></span></dt>
<dd><p>This RTX represents the concatenation of all the <var class="var">rtx</var> to make a
single value.  Like <code class="code">concat</code>, this should only appear in
declarations, and not in the insn chain.
</p></dd>
</dl>

</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Arithmetic.html">RTL Expressions for Arithmetic</a>, Previous: <a href="Constants.html">Constant Expression Types</a>, Up: <a href="RTL.html">RTL Representation</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Option-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>

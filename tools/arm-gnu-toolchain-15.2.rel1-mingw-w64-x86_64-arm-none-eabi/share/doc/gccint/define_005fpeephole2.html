<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- Copyright Â© 1988-2025 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Funding Free Software", the Front-Cover
Texts being (a) (see below), and with the Back-Cover Texts being (b)
(see below).  A copy of the license is included in the section entitled
"GNU Free Documentation License".

(a) The FSF's Front-Cover Text is:

A GNU Manual

(b) The FSF's Back-Cover Text is:

You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development. -->
<title>define_peephole2 (GNU Compiler Collection (GCC) Internals)</title>

<meta name="description" content="define_peephole2 (GNU Compiler Collection (GCC) Internals)">
<meta name="keywords" content="define_peephole2 (GNU Compiler Collection (GCC) Internals)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Option-Index.html" rel="index" title="Option Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Peephole-Definitions.html" rel="up" title="Peephole Definitions">
<link href="define_005fpeephole.html" rel="prev" title="define_peephole">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span.r {font-family: initial; font-weight: normal; font-style: normal}
span:hover a.copiable-link {visibility: visible}
-->
</style>


</head>

<body lang="en">
<div class="subsection-level-extent" id="define_005fpeephole2">
<div class="nav-panel">
<p>
Previous: <a href="define_005fpeephole.html" accesskey="p" rel="prev">RTL to Text Peephole Optimizers</a>, Up: <a href="Peephole-Definitions.html" accesskey="u" rel="up">Machine-Specific Peephole Optimizers</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Option-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h4 class="subsection" id="RTL-to-RTL-Peephole-Optimizers"><span>16.19.2 RTL to RTL Peephole Optimizers<a class="copiable-link" href="#RTL-to-RTL-Peephole-Optimizers"> &para;</a></span></h4>
<a class="index-entry-id" id="index-define_005fpeephole2"></a>

<p>The <code class="code">define_peephole2</code> definition tells the compiler how to
substitute one sequence of instructions for another sequence,
what additional scratch registers may be needed and what their
lifetimes must be.
</p>
<div class="example smallexample">
<pre class="example-preformatted">(define_peephole2
  [<var class="var">insn-pattern-1</var>
   <var class="var">insn-pattern-2</var>
   ...]
  &quot;<var class="var">condition</var>&quot;
  [<var class="var">new-insn-pattern-1</var>
   <var class="var">new-insn-pattern-2</var>
   ...]
  &quot;<var class="var">preparation-statements</var>&quot;)
</pre></div>

<p>The definition is almost identical to <code class="code">define_split</code>
(see <a class="pxref" href="Insn-Splitting.html">Defining How to Split Instructions</a>) except that the pattern to match is not a
single instruction, but a sequence of instructions.
</p>
<p>It is possible to request additional scratch registers for use in the
output template.  If appropriate registers are not free, the pattern
will simply not match.
</p>
<a class="index-entry-id" id="index-match_005fscratch-1"></a>
<a class="index-entry-id" id="index-match_005fdup-1"></a>
<p>Scratch registers are requested with a <code class="code">match_scratch</code> pattern at
the top level of the input pattern.  The allocated register (initially) will
be dead at the point requested within the original sequence.  If the scratch
is used at more than a single point, a <code class="code">match_dup</code> pattern at the
top level of the input pattern marks the last position in the input sequence
at which the register must be available.
</p>
<p>Here is an example from the IA-32 machine description:
</p>
<div class="example smallexample">
<pre class="example-preformatted">(define_peephole2
  [(match_scratch:SI 2 &quot;r&quot;)
   (parallel [(set (match_operand:SI 0 &quot;register_operand&quot; &quot;&quot;)
                   (match_operator:SI 3 &quot;arith_or_logical_operator&quot;
                     [(match_dup 0)
                      (match_operand:SI 1 &quot;memory_operand&quot; &quot;&quot;)]))
              (clobber (reg:CC 17))])]
  &quot;! optimize_size &amp;&amp; ! TARGET_READ_MODIFY&quot;
  [(set (match_dup 2) (match_dup 1))
   (parallel [(set (match_dup 0)
                   (match_op_dup 3 [(match_dup 0) (match_dup 2)]))
              (clobber (reg:CC 17))])]
  &quot;&quot;)
</pre></div>

<p>This pattern tries to split a load from its use in the hopes that we&rsquo;ll be
able to schedule around the memory load latency.  It allocates a single
<code class="code">SImode</code> register of class <code class="code">GENERAL_REGS</code> (<code class="code">&quot;r&quot;</code>) that needs
to be live only at the point just before the arithmetic.
</p>
<p>A real example requiring extended scratch lifetimes is harder to come by,
so here&rsquo;s a silly made-up example:
</p>
<div class="example smallexample">
<pre class="example-preformatted">(define_peephole2
  [(match_scratch:SI 4 &quot;r&quot;)
   (set (match_operand:SI 0 &quot;&quot; &quot;&quot;) (match_operand:SI 1 &quot;&quot; &quot;&quot;))
   (set (match_operand:SI 2 &quot;&quot; &quot;&quot;) (match_dup 1))
   (match_dup 4)
   (set (match_operand:SI 3 &quot;&quot; &quot;&quot;) (match_dup 1))]
  &quot;/* <span class="r">determine 1 does not overlap 0 and 2</span> */&quot;
  [(set (match_dup 4) (match_dup 1))
   (set (match_dup 0) (match_dup 4))
   (set (match_dup 2) (match_dup 4))
   (set (match_dup 3) (match_dup 4))]
  &quot;&quot;)
</pre></div>

<p>If we had not added the <code class="code">(match_dup 4)</code> in the middle of the input
sequence, it might have been the case that the register we chose at the
beginning of the sequence is killed by the first or second <code class="code">set</code>.
</p>
<p>There are two special macros defined for use in the preparation statements:
<code class="code">DONE</code> and <code class="code">FAIL</code>.  Use them with a following semicolon,
as a statement.
</p>
<dl class="table">
<dt><a id="index-DONE-2"></a><span><code class="code">DONE</code><a class="copiable-link" href="#index-DONE-2"> &para;</a></span></dt>
<dd><p>Use the <code class="code">DONE</code> macro to end RTL generation for the peephole.  The
only RTL insns generated as replacement for the matched input insn will
be those already emitted by explicit calls to <code class="code">emit_insn</code> within
the preparation statements; the replacement pattern is not used.
</p>
</dd>
<dt><a id="index-FAIL-2"></a><span><code class="code">FAIL</code><a class="copiable-link" href="#index-FAIL-2"> &para;</a></span></dt>
<dd><p>Make the <code class="code">define_peephole2</code> fail on this occasion.  When a <code class="code">define_peephole2</code>
fails, it means that the replacement was not truly available for the
particular inputs it was given.  In that case, GCC may still apply a
later <code class="code">define_peephole2</code> that also matches the given insn pattern.
(Note that this is different from <code class="code">define_split</code>, where <code class="code">FAIL</code>
prevents the input insn from being split at all.)
</p></dd>
</dl>

<p>If the preparation falls through (invokes neither <code class="code">DONE</code> nor
<code class="code">FAIL</code>), then the <code class="code">define_peephole2</code> uses the replacement
template.
</p>
<p>Insns are scanned in forward order from beginning to end for each basic
block.  Matches are attempted in order of <code class="code">define_peephole2</code>
appearance in the <samp class="file">md</samp> file.  After a successful replacement,
scanning for further opportunities for <code class="code">define_peephole2</code>, resumes
with the first generated replacement insn as the first insn to be
matched against all <code class="code">define_peephole2</code>.  For the example above,
after its successful replacement, the first insn that can be matched by
a <code class="code">define_peephole2</code> is <code class="code">(set (match_dup 4) (match_dup 1))</code>.
</p>
</div>
<hr>
<div class="nav-panel">
<p>
Previous: <a href="define_005fpeephole.html">RTL to Text Peephole Optimizers</a>, Up: <a href="Peephole-Definitions.html">Machine-Specific Peephole Optimizers</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Option-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>

<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- Copyright Â© 1988-2025 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Funding Free Software", the Front-Cover
Texts being (a) (see below), and with the Back-Cover Texts being (b)
(see below).  A copy of the license is included in the section entitled
"GNU Free Documentation License".

(a) The FSF's Front-Cover Text is:

A GNU Manual

(b) The FSF's Back-Cover Text is:

You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development. -->
<title>RTL Objects (GNU Compiler Collection (GCC) Internals)</title>

<meta name="description" content="RTL Objects (GNU Compiler Collection (GCC) Internals)">
<meta name="keywords" content="RTL Objects (GNU Compiler Collection (GCC) Internals)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Option-Index.html" rel="index" title="Option Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="RTL.html" rel="up" title="RTL">
<link href="RTL-Classes.html" rel="next" title="RTL Classes">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
span:hover a.copiable-link {visibility: visible}
-->
</style>


</head>

<body lang="en">
<div class="section-level-extent" id="RTL-Objects">
<div class="nav-panel">
<p>
Next: <a href="RTL-Classes.html" accesskey="n" rel="next">RTL Classes and Formats</a>, Up: <a href="RTL.html" accesskey="u" rel="up">RTL Representation</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Option-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="RTL-Object-Types"><span>13.1 RTL Object Types<a class="copiable-link" href="#RTL-Object-Types"> &para;</a></span></h3>
<a class="index-entry-id" id="index-RTL-object-types"></a>

<a class="index-entry-id" id="index-RTL-integers"></a>
<a class="index-entry-id" id="index-RTL-strings"></a>
<a class="index-entry-id" id="index-RTL-vectors"></a>
<a class="index-entry-id" id="index-RTL-expression"></a>
<a class="index-entry-id" id="index-RTX-_0028See-RTL_0029"></a>
<p>RTL uses five kinds of objects: expressions, integers, wide integers,
strings and vectors.  Expressions are the most important ones.  An RTL
expression (&ldquo;RTX&rdquo;, for short) is a C structure, but it is usually
referred to with a pointer; a type that is given the typedef name
<code class="code">rtx</code>.
</p>
<p>An integer is simply an <code class="code">int</code>; their written form uses decimal
digits.  A wide integer is an integral object whose type is
<code class="code">HOST_WIDE_INT</code>; their written form uses decimal digits.
</p>
<p>A string is a sequence of characters.  In core it is represented as a
<code class="code">char *</code> in usual C fashion, and it is written in C syntax as well.
However, strings in RTL may never be null.  If you write an empty string in
a machine description, it is represented in core as a null pointer rather
than as a pointer to a null character.  In certain contexts, these null
pointers instead of strings are valid.  Within RTL code, strings are most
commonly found inside <code class="code">symbol_ref</code> expressions, but they appear in
other contexts in the RTL expressions that make up machine descriptions.
</p>
<p>In a machine description, strings are normally written with double
quotes, as you would in C.  However, strings in machine descriptions may
extend over many lines, which is invalid C, and adjacent string
constants are not concatenated as they are in C.  Any string constant
may be surrounded with a single set of parentheses.  Sometimes this
makes the machine description easier to read.
</p>
<p>There is also a special syntax for strings, which can be useful when C
code is embedded in a machine description.  Wherever a string can
appear, it is also valid to write a C-style brace block.  The entire
brace block, including the outermost pair of braces, is considered to be
the string constant.  Double quote characters inside the braces are not
special.  Therefore, if you write string constants in the C code, you
need not escape each quote character with a backslash. Note escaped quotes
are treated the same as a plain quote character and if you need a escaped
quote in a C string, you need an extra backslash to escape the backslash
like <code class="code">&quot;a=\\&quot;c\\&quot;;&quot;</code>.
</p>
<p>A vector contains an arbitrary number of pointers to expressions.  The
number of elements in the vector is explicitly present in the vector.
The written form of a vector consists of square brackets
(&lsquo;<samp class="samp">[&hellip;]</samp>&rsquo;) surrounding the elements, in sequence and with
whitespace separating them.  Vectors of length zero are not created;
null pointers are used instead.
</p>
<a class="index-entry-id" id="index-expression-codes"></a>
<a class="index-entry-id" id="index-codes_002c-RTL-expression"></a>
<a class="index-entry-id" id="index-GET_005fCODE"></a>
<a class="index-entry-id" id="index-PUT_005fCODE"></a>
<p>Expressions are classified by <em class="dfn">expression codes</em> (also called RTX
codes).  The expression code is a name defined in <samp class="file">rtl.def</samp>, which is
also (in uppercase) a C enumeration constant.  The possible expression
codes and their meanings are machine-independent.  The code of an RTX can
be extracted with the macro <code class="code">GET_CODE (<var class="var">x</var>)</code> and altered with
<code class="code">PUT_CODE (<var class="var">x</var>, <var class="var">newcode</var>)</code>.
</p>
<p>The expression code determines how many operands the expression contains,
and what kinds of objects they are.  In RTL, unlike Lisp, you cannot tell
by looking at an operand what kind of object it is.  Instead, you must know
from its context&mdash;from the expression code of the containing expression.
For example, in an expression of code <code class="code">subreg</code>, the first operand is
to be regarded as an expression and the second operand as a polynomial
integer.  In an expression of code <code class="code">plus</code>, there are two operands,
both of which are to be regarded as expressions.  In a <code class="code">symbol_ref</code>
expression, there is one operand, which is to be regarded as a string.
</p>
<p>Expressions are written as parentheses containing the name of the
expression type, its flags and machine mode if any, and then the operands
of the expression (separated by spaces).
</p>
<p>Expression code names in the &lsquo;<samp class="samp">md</samp>&rsquo; file are written in lowercase,
but when they appear in C code they are written in uppercase.  In this
manual, they are shown as follows: <code class="code">const_int</code>.
</p>
<a class="index-entry-id" id="index-_0028nil_0029"></a>
<a class="index-entry-id" id="index-nil"></a>
<p>In a few contexts a null pointer is valid where an expression is normally
wanted.  The written form of this is <code class="code">(nil)</code>.
</p>
</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="RTL-Classes.html">RTL Classes and Formats</a>, Up: <a href="RTL.html">RTL Representation</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Option-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>

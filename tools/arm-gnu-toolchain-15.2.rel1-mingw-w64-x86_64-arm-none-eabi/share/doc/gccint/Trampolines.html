<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- Copyright Â© 1988-2025 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Funding Free Software", the Front-Cover
Texts being (a) (see below), and with the Back-Cover Texts being (b)
(see below).  A copy of the license is included in the section entitled
"GNU Free Documentation License".

(a) The FSF's Front-Cover Text is:

A GNU Manual

(b) The FSF's Back-Cover Text is:

You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development. -->
<title>Trampolines (GNU Compiler Collection (GCC) Internals)</title>

<meta name="description" content="Trampolines (GNU Compiler Collection (GCC) Internals)">
<meta name="keywords" content="Trampolines (GNU Compiler Collection (GCC) Internals)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Option-Index.html" rel="index" title="Option Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Target-Macros.html" rel="up" title="Target Macros">
<link href="Library-Calls.html" rel="next" title="Library Calls">
<link href="Varargs.html" rel="prev" title="Varargs">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>


</head>

<body lang="en">
<div class="section-level-extent" id="Trampolines">
<div class="nav-panel">
<p>
Next: <a href="Library-Calls.html" accesskey="n" rel="next">Implicit Calls to Library Routines</a>, Previous: <a href="Varargs.html" accesskey="p" rel="prev">Implementing the Varargs Macros</a>, Up: <a href="Target-Macros.html" accesskey="u" rel="up">Target Description Macros and Functions</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Option-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="Support-for-Nested-Functions"><span>17.11 Support for Nested Functions<a class="copiable-link" href="#Support-for-Nested-Functions"> &para;</a></span></h3>
<a class="index-entry-id" id="index-support-for-nested-functions"></a>
<a class="index-entry-id" id="index-trampolines-for-nested-functions"></a>
<a class="index-entry-id" id="index-descriptors-for-nested-functions"></a>
<a class="index-entry-id" id="index-nested-functions_002c-support-for"></a>

<p>Taking the address of a nested function requires special compiler
handling to ensure that the static chain register is loaded when
the function is invoked via an indirect call.
</p>
<p>GCC has traditionally supported nested functions by creating an
executable <em class="dfn">trampoline</em> at run time when the address of a nested
function is taken.  This is a small piece of code which normally
resides on the stack, in the stack frame of the containing function.
The trampoline loads the static chain register and then jumps to the
real address of the nested function.
</p>
<p>The use of trampolines requires an executable stack, which is a
security risk.  To avoid this problem, GCC also supports another
strategy: using descriptors for nested functions.  Under this model,
taking the address of a nested function results in a pointer to a
non-executable function descriptor object.  Initializing the static chain
from the descriptor is handled at indirect call sites.
</p>
<p>On some targets, including HPPA and IA-64, function descriptors may be
mandated by the ABI or be otherwise handled in a target-specific way
by the back end in its code generation strategy for indirect calls.
GCC also provides its own generic descriptor implementation to support the
<samp class="option">-fno-trampolines</samp> option.  In this case runtime detection of
function descriptors at indirect call sites relies on descriptor
pointers being tagged with a bit that is never set in bare function
addresses.  Since GCC&rsquo;s generic function descriptors are
not ABI-compliant, this option is typically used only on a
per-language basis (notably by Ada) or when it can otherwise be
applied to the whole program.
</p>
<p>For languages other than Ada, the <code class="code">-ftrampolines</code> and
<code class="code">-fno-trampolines</code> options currently have no effect, and
trampolines are always generated on platforms that need them
for nested functions.
</p>
<p>Define the following hook if your backend either implements ABI-specified
descriptor support, or can use GCC&rsquo;s generic descriptor implementation
for nested functions.
</p>
<dl class="first-deftypevr">
<dt class="deftypevr" id="index-TARGET_005fCUSTOM_005fFUNCTION_005fDESCRIPTORS"><span class="category-def">Target Hook: </span><span><code class="def-type">int</code> <strong class="def-name">TARGET_CUSTOM_FUNCTION_DESCRIPTORS</strong><a class="copiable-link" href="#index-TARGET_005fCUSTOM_005fFUNCTION_005fDESCRIPTORS"> &para;</a></span></dt>
<dd><p>If the target can use GCC&rsquo;s generic descriptor mechanism for nested
functions, define this hook to a power of 2 representing an unused bit
in function pointers which can be used to differentiate descriptors at
run time.  This value gives the number of bytes by which descriptor
pointers are misaligned compared to function pointers.  For example, on
targets that require functions to be aligned to a 4-byte boundary, a
value of either 1 or 2 is appropriate unless the architecture already
reserves the bit for another purpose, such as on ARM.
</p>
<p>Define this hook to 0 if the target implements ABI support for
function descriptors in its standard calling sequence, like for example
HPPA or IA-64.
</p>
<p>Using descriptors for nested functions
eliminates the need for trampolines that reside on the stack and require
it to be made executable.
</p></dd></dl>

<p>The following macros tell GCC how to generate code to allocate and
initialize an executable trampoline.  You can also use this interface
if your back end needs to create ABI-specified non-executable descriptors; in
this case the &quot;trampoline&quot; created is the descriptor containing data only.
</p>
<p>The instructions in an executable trampoline must do two things: load
a constant address into the static chain register, and jump to the real
address of the nested function.  On CISC machines such as the m68k,
this requires two instructions, a move immediate and a jump.  Then the
two addresses exist in the trampoline as word-long immediate operands.
On RISC machines, it is often necessary to load each address into a
register in two parts.  Then pieces of each address form separate
immediate operands.
</p>
<p>The code generated to initialize the trampoline must store the variable
parts&mdash;the static chain value and the function address&mdash;into the
immediate operands of the instructions.  On a CISC machine, this is
simply a matter of copying each address to a memory reference at the
proper offset from the start of the trampoline.  On a RISC machine, it
may be necessary to take out pieces of the address and store them
separately.
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fASM_005fTRAMPOLINE_005fTEMPLATE"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_ASM_TRAMPOLINE_TEMPLATE</strong> <code class="def-code-arguments">(FILE *<var class="var">f</var>)</code><a class="copiable-link" href="#index-TARGET_005fASM_005fTRAMPOLINE_005fTEMPLATE"> &para;</a></span></dt>
<dd><p>This hook is called by <code class="code">assemble_trampoline_template</code> to output,
on the stream <var class="var">f</var>, assembler code for a block of data that contains
the constant parts of a trampoline.  This code should not include a
label&mdash;the label is taken care of automatically.
</p>
<p>If you do not define this hook, it means no template is needed
for the target.  Do not define this hook on systems where the block move
code to copy the trampoline into place would be larger than the code
to generate it on the spot.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-TRAMPOLINE_005fSECTION"><span class="category-def">Macro: </span><span><strong class="def-name">TRAMPOLINE_SECTION</strong><a class="copiable-link" href="#index-TRAMPOLINE_005fSECTION"> &para;</a></span></dt>
<dd><p>Return the section into which the trampoline template is to be placed
(see <a class="pxref" href="Sections.html">Dividing the Output into Sections (Texts, Data, &hellip;)</a>).  The default value is <code class="code">readonly_data_section</code>.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-TRAMPOLINE_005fSIZE"><span class="category-def">Macro: </span><span><strong class="def-name">TRAMPOLINE_SIZE</strong><a class="copiable-link" href="#index-TRAMPOLINE_005fSIZE"> &para;</a></span></dt>
<dd><p>A C expression for the size in bytes of the trampoline, as an integer.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-TRAMPOLINE_005fALIGNMENT"><span class="category-def">Macro: </span><span><strong class="def-name">TRAMPOLINE_ALIGNMENT</strong><a class="copiable-link" href="#index-TRAMPOLINE_005fALIGNMENT"> &para;</a></span></dt>
<dd><p>Alignment required for trampolines, in bits.
</p>
<p>If you don&rsquo;t define this macro, the value of <code class="code">FUNCTION_ALIGNMENT</code>
is used for aligning trampolines.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fTRAMPOLINE_005fINIT"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_TRAMPOLINE_INIT</strong> <code class="def-code-arguments">(rtx <var class="var">m_tramp</var>, tree <var class="var">fndecl</var>, rtx <var class="var">static_chain</var>)</code><a class="copiable-link" href="#index-TARGET_005fTRAMPOLINE_005fINIT"> &para;</a></span></dt>
<dd><p>This hook is called to initialize a trampoline.
<var class="var">m_tramp</var> is an RTX for the memory block for the trampoline; <var class="var">fndecl</var>
is the <code class="code">FUNCTION_DECL</code> for the nested function; <var class="var">static_chain</var> is an
RTX for the static chain value that should be passed to the function
when it is called.
</p>
<p>If the target defines <code class="code">TARGET_ASM_TRAMPOLINE_TEMPLATE</code>, then the
first thing this hook should do is emit a block move into <var class="var">m_tramp</var>
from the memory block returned by <code class="code">assemble_trampoline_template</code>.
Note that the block move need only cover the constant parts of the
trampoline.  If the target isolates the variable parts of the trampoline
to the end, not all <code class="code">TRAMPOLINE_SIZE</code> bytes need be copied.
</p>
<p>If the target requires any other actions, such as flushing caches
(possibly calling function maybe_emit_call_builtin___clear_cache) or
enabling stack execution, these actions should be performed after
initializing the trampoline proper.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fEMIT_005fCALL_005fBUILTIN_005f_005f_005fCLEAR_005fCACHE"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_EMIT_CALL_BUILTIN___CLEAR_CACHE</strong> <code class="def-code-arguments">(rtx <var class="var">begin</var>, rtx <var class="var">end</var>)</code><a class="copiable-link" href="#index-TARGET_005fEMIT_005fCALL_005fBUILTIN_005f_005f_005fCLEAR_005fCACHE"> &para;</a></span></dt>
<dd><p>On targets that do not define a <code class="code">clear_cache</code> insn expander,
but that define the <code class="code">CLEAR_CACHE_INSN</code> macro,
maybe_emit_call_builtin___clear_cache relies on this target hook
to clear an address range in the instruction cache.
</p>
<p>The default implementation calls the <code class="code">__clear_cache</code> builtin,
taking the assembler name from the builtin declaration.  Overriding
definitions may call alternate functions, with alternate calling
conventions, or emit alternate RTX to perform the job.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fTRAMPOLINE_005fADJUST_005fADDRESS"><span class="category-def">Target Hook: </span><span><code class="def-type">rtx</code> <strong class="def-name">TARGET_TRAMPOLINE_ADJUST_ADDRESS</strong> <code class="def-code-arguments">(rtx <var class="var">addr</var>)</code><a class="copiable-link" href="#index-TARGET_005fTRAMPOLINE_005fADJUST_005fADDRESS"> &para;</a></span></dt>
<dd><p>This hook should perform any machine-specific adjustment in
the address of the trampoline.  Its argument contains the address of the
memory block that was passed to <code class="code">TARGET_TRAMPOLINE_INIT</code>.  In case
the address to be used for a function call should be different from the
address at which the template was stored, the different address should
be returned; otherwise <var class="var">addr</var> should be returned unchanged.
If this hook is not defined, <var class="var">addr</var> will be used for function calls.
</p></dd></dl>

<p>Implementing trampolines is difficult on many machines because they have
separate instruction and data caches.  Writing into a stack location
fails to clear the memory in the instruction cache, so when the program
jumps to that location, it executes the old contents.
</p>
<p>Here are two possible solutions.  One is to clear the relevant parts of
the instruction cache whenever a trampoline is set up.  The other is to
make all trampolines identical, by having them jump to a standard
subroutine.  The former technique makes trampoline execution faster; the
latter makes initialization faster.
</p>
<p>To clear the instruction cache when a trampoline is initialized, define
the following macro.
</p>
<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-CLEAR_005fINSN_005fCACHE"><span class="category-def">Macro: </span><span><strong class="def-name">CLEAR_INSN_CACHE</strong> <var class="def-var-arguments">(<var class="var">beg</var>, <var class="var">end</var>)</var><a class="copiable-link" href="#index-CLEAR_005fINSN_005fCACHE"> &para;</a></span></dt>
<dd><p>If defined, expands to a C expression clearing the <em class="emph">instruction
cache</em> in the specified interval.  The definition of this macro would
typically be a series of <code class="code">asm</code> statements.  Both <var class="var">beg</var> and
<var class="var">end</var> are pointer expressions.
</p></dd></dl>

<p>To use a standard subroutine, define the following macro.  In addition,
you must make sure that the instructions in a trampoline fill an entire
cache line with identical instructions, or else ensure that the
beginning of the trampoline code is always aligned at the same point in
its cache line.  Look in <samp class="file">m68k.h</samp> as a guide.
</p>
<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-TRANSFER_005fFROM_005fTRAMPOLINE"><span class="category-def">Macro: </span><span><strong class="def-name">TRANSFER_FROM_TRAMPOLINE</strong><a class="copiable-link" href="#index-TRANSFER_005fFROM_005fTRAMPOLINE"> &para;</a></span></dt>
<dd><p>Define this macro if trampolines need a special subroutine to do their
work.  The macro should expand to a series of <code class="code">asm</code> statements
which will be compiled with GCC.  They go in a library function named
<code class="code">__transfer_from_trampoline</code>.
</p>
<p>If you need to avoid executing the ordinary prologue code of a compiled
C function when you jump to the subroutine, you can do so by placing a
special label of your own in the assembler code.  Use one <code class="code">asm</code>
statement to generate an assembler label, and another to make the label
global.  Then trampolines can use that label to jump directly to your
special assembler code.
</p></dd></dl>

</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Library-Calls.html">Implicit Calls to Library Routines</a>, Previous: <a href="Varargs.html">Implementing the Varargs Macros</a>, Up: <a href="Target-Macros.html">Target Description Macros and Functions</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Option-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>

<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- Copyright Â© 1988-2025 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Funding Free Software", the Front-Cover
Texts being (a) (see below), and with the Back-Cover Texts being (b)
(see below).  A copy of the license is included in the section entitled
"GNU Free Documentation License".

(a) The FSF's Front-Cover Text is:

A GNU Manual

(b) The FSF's Back-Cover Text is:

You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development. -->
<title>Basic Statements (GNU Compiler Collection (GCC) Internals)</title>

<meta name="description" content="Basic Statements (GNU Compiler Collection (GCC) Internals)">
<meta name="keywords" content="Basic Statements (GNU Compiler Collection (GCC) Internals)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Option-Index.html" rel="index" title="Option Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Statements.html" rel="up" title="Statements">
<link href="Blocks.html" rel="next" title="Blocks">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
-->
</style>


</head>

<body lang="en">
<div class="subsection-level-extent" id="Basic-Statements">
<div class="nav-panel">
<p>
Next: <a href="Blocks.html" accesskey="n" rel="next">Blocks</a>, Up: <a href="Statements.html" accesskey="u" rel="up">Statements</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Option-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h4 class="subsection" id="Basic-Statements-1"><span>10.7.1 Basic Statements<a class="copiable-link" href="#Basic-Statements-1"> &para;</a></span></h4>
<a class="index-entry-id" id="index-Basic-Statements"></a>

<dl class="table">
<dt><code class="code">ASM_EXPR</code></dt>
<dd>
<p>Used to represent an inline assembly statement.  For an inline assembly
statement like:
</p><div class="example smallexample">
<pre class="example-preformatted">asm (&quot;mov x, y&quot;);
</pre></div>
<p>The <code class="code">ASM_STRING</code> macro will return a <code class="code">STRING_CST</code> node for
<code class="code">&quot;mov x, y&quot;</code>.  If the original statement made use of the
extended-assembly syntax, then <code class="code">ASM_OUTPUTS</code>,
<code class="code">ASM_INPUTS</code>, and <code class="code">ASM_CLOBBERS</code> will be the outputs, inputs,
and clobbers for the statement, represented as <code class="code">STRING_CST</code> nodes.
The extended-assembly syntax looks like:
</p><div class="example smallexample">
<pre class="example-preformatted">asm (&quot;fsinx %1,%0&quot; : &quot;=f&quot; (result) : &quot;f&quot; (angle));
</pre></div>
<p>The first string is the <code class="code">ASM_STRING</code>, containing the instruction
template.  The next two strings are the output and inputs, respectively;
this statement has no clobbers.  All of the strings will be
<code class="code">NUL</code>-terminated, and will contain no embedded <code class="code">NUL</code>-characters.
</p>
<p><code class="code">ASM_BASIC_P</code> indicates whether the assembly statement used the
&ldquo;basic&rdquo; syntax (as for the first example above) or whether it used
the extended syntax (as for the second example above).  In many cases
this information could be inferred from other accessors, but the flag
is necessary to distinguish extended statements that have no operands
from basic statements.  A key difference between the two is that
<code class="code">%</code> substitution is applied to <code class="code">ASM_STRING</code> for extended
statements but not for basic statements.
</p>
<p>If the assembly statement is declared <code class="code">volatile</code>, or if the
statement was not an extended assembly statement, and is therefore
implicitly volatile, then the predicate <code class="code">ASM_VOLATILE_P</code> will hold
of the <code class="code">ASM_EXPR</code>.
</p>
</dd>
<dt><code class="code">DECL_EXPR</code></dt>
<dd>
<p>Used to represent a local declaration.  The <code class="code">DECL_EXPR_DECL</code> macro
can be used to obtain the entity declared.  This declaration may be a
<code class="code">LABEL_DECL</code>, indicating that the label declared is a local label.
(As an extension, GCC allows the declaration of labels with scope.)  In
C, this declaration may be a <code class="code">FUNCTION_DECL</code>, indicating the
use of the GCC nested function extension.  For more information,
see <a class="pxref" href="Functions.html">Functions</a>.
</p>
</dd>
<dt><code class="code">LABEL_EXPR</code></dt>
<dd>
<p>Used to represent a label.  The <code class="code">LABEL_DECL</code> declared by this
statement can be obtained with the <code class="code">LABEL_EXPR_LABEL</code> macro.  The
<code class="code">IDENTIFIER_NODE</code> giving the name of the label can be obtained from
the <code class="code">LABEL_DECL</code> with <code class="code">DECL_NAME</code>.
</p>
</dd>
<dt><code class="code">GOTO_EXPR</code></dt>
<dd>
<p>Used to represent a <code class="code">goto</code> statement.  The <code class="code">GOTO_DESTINATION</code> will
usually be a <code class="code">LABEL_DECL</code>.  However, if the &ldquo;computed goto&rdquo; extension
has been used, the <code class="code">GOTO_DESTINATION</code> will be an arbitrary expression
indicating the destination.  This expression will always have pointer type.
</p>
</dd>
<dt><code class="code">RETURN_EXPR</code></dt>
<dd>
<p>Used to represent a <code class="code">return</code> statement.  Operand 0 represents the
value to return.  It should either be the <code class="code">RESULT_DECL</code> for the
containing function, or a <code class="code">MODIFY_EXPR</code> or <code class="code">INIT_EXPR</code>
setting the function&rsquo;s <code class="code">RESULT_DECL</code>.  It will be
<code class="code">NULL_TREE</code> if the statement was just
</p><div class="example smallexample">
<pre class="example-preformatted">return;
</pre></div>

</dd>
<dt><code class="code">LOOP_EXPR</code></dt>
<dd><p>These nodes represent &ldquo;infinite&rdquo; loops.  The <code class="code">LOOP_EXPR_BODY</code>
represents the body of the loop.  It should be executed forever, unless
an <code class="code">EXIT_EXPR</code> is encountered.
</p>
</dd>
<dt><code class="code">EXIT_EXPR</code></dt>
<dd><p>These nodes represent conditional exits from the nearest enclosing
<code class="code">LOOP_EXPR</code>.  The single operand is the condition; if it is
nonzero, then the loop should be exited.  An <code class="code">EXIT_EXPR</code> will only
appear within a <code class="code">LOOP_EXPR</code>.
</p>
</dd>
<dt><code class="code">SWITCH_EXPR</code></dt>
<dd>
<p>Used to represent a <code class="code">switch</code> statement.  The <code class="code">SWITCH_COND</code>
is the expression on which the switch is occurring.  The
<code class="code">SWITCH_BODY</code> is the body of the switch statement.
<code class="code">SWITCH_ALL_CASES_P</code> is true if the switch includes a default
label or the case label ranges cover all possible values of the
condition expression.
</p>
<p>Note that <code class="code">TREE_TYPE</code> for a <code class="code">SWITCH_EXPR</code> represents the
original type of switch expression as given in the source, before any
compiler conversions, instead of the type of the switch expression
itself (which is not meaningful).
</p>
</dd>
<dt><code class="code">CASE_LABEL_EXPR</code></dt>
<dd>
<p>Use to represent a <code class="code">case</code> label, range of <code class="code">case</code> labels, or a
<code class="code">default</code> label.  If <code class="code">CASE_LOW</code> is <code class="code">NULL_TREE</code>, then this is a
<code class="code">default</code> label.  Otherwise, if <code class="code">CASE_HIGH</code> is <code class="code">NULL_TREE</code>, then
this is an ordinary <code class="code">case</code> label.  In this case, <code class="code">CASE_LOW</code> is
an expression giving the value of the label.  Both <code class="code">CASE_LOW</code> and
<code class="code">CASE_HIGH</code> are <code class="code">INTEGER_CST</code> nodes.  These values will have
the same type as the condition expression in the switch statement.
</p>
<p>Otherwise, if both <code class="code">CASE_LOW</code> and <code class="code">CASE_HIGH</code> are defined, the
statement is a range of case labels.  Such statements originate with the
extension that allows users to write things of the form:
</p><div class="example smallexample">
<pre class="example-preformatted">case 2 ... 5:
</pre></div>
<p>The first value will be <code class="code">CASE_LOW</code>, while the second will be
<code class="code">CASE_HIGH</code>.
</p>
</dd>
<dt><code class="code">DEBUG_BEGIN_STMT</code></dt>
<dd>
<p>Marks the beginning of a source statement, for purposes of debug
information generation.
</p>
</dd>
</dl>


</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Blocks.html">Blocks</a>, Up: <a href="Statements.html">Statements</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Option-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>

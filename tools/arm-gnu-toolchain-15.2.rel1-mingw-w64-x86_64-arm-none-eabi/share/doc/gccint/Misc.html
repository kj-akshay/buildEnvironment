<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- Copyright Â© 1988-2025 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Funding Free Software", the Front-Cover
Texts being (a) (see below), and with the Back-Cover Texts being (b)
(see below).  A copy of the license is included in the section entitled
"GNU Free Documentation License".

(a) The FSF's Front-Cover Text is:

A GNU Manual

(b) The FSF's Back-Cover Text is:

You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development. -->
<title>Misc (GNU Compiler Collection (GCC) Internals)</title>

<meta name="description" content="Misc (GNU Compiler Collection (GCC) Internals)">
<meta name="keywords" content="Misc (GNU Compiler Collection (GCC) Internals)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Option-Index.html" rel="index" title="Option Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Target-Macros.html" rel="up" title="Target Macros">
<link href="Named-Address-Spaces.html" rel="prev" title="Named Address Spaces">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
ul.mark-bullet {list-style-type: disc}
-->
</style>


</head>

<body lang="en">
<div class="section-level-extent" id="Misc">
<div class="nav-panel">
<p>
Previous: <a href="Named-Address-Spaces.html" accesskey="p" rel="prev">Adding support for named address spaces</a>, Up: <a href="Target-Macros.html" accesskey="u" rel="up">Target Description Macros and Functions</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Option-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="Miscellaneous-Parameters"><span>17.32 Miscellaneous Parameters<a class="copiable-link" href="#Miscellaneous-Parameters"> &para;</a></span></h3>
<a class="index-entry-id" id="index-parameters_002c-miscellaneous"></a>

<p>Here are several miscellaneous parameters.
</p>
<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-HAS_005fLONG_005fCOND_005fBRANCH"><span class="category-def">Macro: </span><span><strong class="def-name">HAS_LONG_COND_BRANCH</strong><a class="copiable-link" href="#index-HAS_005fLONG_005fCOND_005fBRANCH"> &para;</a></span></dt>
<dd><p>Define this boolean macro to indicate whether or not your architecture
has conditional branches that can span all of memory.  It is used in
conjunction with an optimization that partitions hot and cold basic
blocks into separate sections of the executable.  If this macro is
set to false, gcc will convert any conditional branches that attempt
to cross between sections into unconditional branches or indirect jumps.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-HAS_005fLONG_005fUNCOND_005fBRANCH"><span class="category-def">Macro: </span><span><strong class="def-name">HAS_LONG_UNCOND_BRANCH</strong><a class="copiable-link" href="#index-HAS_005fLONG_005fUNCOND_005fBRANCH"> &para;</a></span></dt>
<dd><p>Define this boolean macro to indicate whether or not your architecture
has unconditional branches that can span all of memory.  It is used in
conjunction with an optimization that partitions hot and cold basic
blocks into separate sections of the executable.  If this macro is
set to false, gcc will convert any unconditional branches that attempt
to cross between sections into indirect jumps.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-CASE_005fVECTOR_005fMODE"><span class="category-def">Macro: </span><span><strong class="def-name">CASE_VECTOR_MODE</strong><a class="copiable-link" href="#index-CASE_005fVECTOR_005fMODE"> &para;</a></span></dt>
<dd><p>An alias for a machine mode name.  This is the machine mode that
elements of a jump-table should have.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-CASE_005fVECTOR_005fSHORTEN_005fMODE"><span class="category-def">Macro: </span><span><strong class="def-name">CASE_VECTOR_SHORTEN_MODE</strong> <var class="def-var-arguments">(<var class="var">min_offset</var>, <var class="var">max_offset</var>, <var class="var">body</var>)</var><a class="copiable-link" href="#index-CASE_005fVECTOR_005fSHORTEN_005fMODE"> &para;</a></span></dt>
<dd><p>Optional: return the preferred mode for an <code class="code">addr_diff_vec</code>
when the minimum and maximum offset are known.  If you define this,
it enables extra code in branch shortening to deal with <code class="code">addr_diff_vec</code>.
To make this work, you also have to define <code class="code">INSN_ALIGN</code> and
make the alignment for <code class="code">addr_diff_vec</code> explicit.
The <var class="var">body</var> argument is provided so that the offset_unsigned and scale
flags can be updated.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-CASE_005fVECTOR_005fPC_005fRELATIVE"><span class="category-def">Macro: </span><span><strong class="def-name">CASE_VECTOR_PC_RELATIVE</strong><a class="copiable-link" href="#index-CASE_005fVECTOR_005fPC_005fRELATIVE"> &para;</a></span></dt>
<dd><p>Define this macro to be a C expression to indicate when jump-tables
should contain relative addresses.  You need not define this macro if
jump-tables never contain relative addresses, or jump-tables should
contain relative addresses only when <samp class="option">-fPIC</samp> or <samp class="option">-fPIC</samp>
is in effect.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fCASE_005fVALUES_005fTHRESHOLD"><span class="category-def">Target Hook: </span><span><code class="def-type">unsigned int</code> <strong class="def-name">TARGET_CASE_VALUES_THRESHOLD</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fCASE_005fVALUES_005fTHRESHOLD"> &para;</a></span></dt>
<dd><p>This function return the smallest number of different values for which it
is best to use a jump-table instead of a tree of conditional branches.
The default is four for machines with a <code class="code">casesi</code> instruction and
five otherwise.  This is best for most machines.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-WORD_005fREGISTER_005fOPERATIONS"><span class="category-def">Macro: </span><span><strong class="def-name">WORD_REGISTER_OPERATIONS</strong><a class="copiable-link" href="#index-WORD_005fREGISTER_005fOPERATIONS"> &para;</a></span></dt>
<dd><p>Define this macro to 1 if operations between registers with integral mode
smaller than a word are always performed on the entire register.  To be
more explicit, if you start with a pair of <code class="code">word_mode</code> registers with
known values and you do a subword, for example <code class="code">QImode</code>, addition on
the low part of the registers, then the compiler may consider that the
result has a known value in <code class="code">word_mode</code> too if the macro is defined
to 1.  Most RISC machines have this property and most CISC machines do not.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fMIN_005fARITHMETIC_005fPRECISION"><span class="category-def">Target Hook: </span><span><code class="def-type">unsigned int</code> <strong class="def-name">TARGET_MIN_ARITHMETIC_PRECISION</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fMIN_005fARITHMETIC_005fPRECISION"> &para;</a></span></dt>
<dd><p>On some RISC architectures with 64-bit registers, the processor also
maintains 32-bit condition codes that make it possible to do real 32-bit
arithmetic, although the operations are performed on the full registers.
</p>
<p>On such architectures, defining this hook to 32 tells the compiler to try
using 32-bit arithmetical operations setting the condition codes instead
of doing full 64-bit arithmetic.
</p>
<p>More generally, define this hook on RISC architectures if you want the
compiler to try using arithmetical operations setting the condition codes
with a precision lower than the word precision.
</p>
<p>You need not define this hook if <code class="code">WORD_REGISTER_OPERATIONS</code> is not
defined to 1.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-LOAD_005fEXTEND_005fOP"><span class="category-def">Macro: </span><span><strong class="def-name">LOAD_EXTEND_OP</strong> <var class="def-var-arguments">(<var class="var">mem_mode</var>)</var><a class="copiable-link" href="#index-LOAD_005fEXTEND_005fOP"> &para;</a></span></dt>
<dd><p>Define this macro to be a C expression indicating when insns that read
memory in <var class="var">mem_mode</var>, an integral mode narrower than a word, set the
bits outside of <var class="var">mem_mode</var> to be either the sign-extension or the
zero-extension of the data read.  Return <code class="code">SIGN_EXTEND</code> for values
of <var class="var">mem_mode</var> for which the
insn sign-extends, <code class="code">ZERO_EXTEND</code> for which it zero-extends, and
<code class="code">UNKNOWN</code> for other modes.
</p>
<p>This macro is not called with <var class="var">mem_mode</var> non-integral or with a width
greater than or equal to <code class="code">BITS_PER_WORD</code>, so you may return any
value in this case.  Do not define this macro if it would always return
<code class="code">UNKNOWN</code>.  On machines where this macro is defined, you will normally
define it as the constant <code class="code">SIGN_EXTEND</code> or <code class="code">ZERO_EXTEND</code>.
</p>
<p>You may return a non-<code class="code">UNKNOWN</code> value even if for some hard registers
the sign extension is not performed, if for the <code class="code">REGNO_REG_CLASS</code>
of these hard registers <code class="code">TARGET_CAN_CHANGE_MODE_CLASS</code> returns false
when the <var class="var">from</var> mode is <var class="var">mem_mode</var> and the <var class="var">to</var> mode is any
integral mode larger than this but not larger than <code class="code">word_mode</code>.
</p>
<p>You must return <code class="code">UNKNOWN</code> if for some hard registers that allow this
mode, <code class="code">TARGET_CAN_CHANGE_MODE_CLASS</code> says that they cannot change to
<code class="code">word_mode</code>, but that they can change to another integral mode that
is larger then <var class="var">mem_mode</var> but still smaller than <code class="code">word_mode</code>.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-SHORT_005fIMMEDIATES_005fSIGN_005fEXTEND"><span class="category-def">Macro: </span><span><strong class="def-name">SHORT_IMMEDIATES_SIGN_EXTEND</strong><a class="copiable-link" href="#index-SHORT_005fIMMEDIATES_005fSIGN_005fEXTEND"> &para;</a></span></dt>
<dd><p>Define this macro to 1 if loading short immediate values into registers sign
extends.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fMIN_005fDIVISIONS_005fFOR_005fRECIP_005fMUL"><span class="category-def">Target Hook: </span><span><code class="def-type">unsigned int</code> <strong class="def-name">TARGET_MIN_DIVISIONS_FOR_RECIP_MUL</strong> <code class="def-code-arguments">(machine_mode <var class="var">mode</var>)</code><a class="copiable-link" href="#index-TARGET_005fMIN_005fDIVISIONS_005fFOR_005fRECIP_005fMUL"> &para;</a></span></dt>
<dd><p>When <samp class="option">-ffast-math</samp> is in effect, GCC tries to optimize
divisions by the same divisor, by turning them into multiplications by
the reciprocal.  This target hook specifies the minimum number of divisions
that should be there for GCC to perform the optimization for a variable
of mode <var class="var">mode</var>.  The default implementation returns 3 if the machine
has an instruction for the division, and 2 if it does not.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-MOVE_005fMAX"><span class="category-def">Macro: </span><span><strong class="def-name">MOVE_MAX</strong><a class="copiable-link" href="#index-MOVE_005fMAX"> &para;</a></span></dt>
<dd><p>The maximum number of bytes that a single instruction can move quickly
between memory and registers or between two memory locations.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-MAX_005fMOVE_005fMAX"><span class="category-def">Macro: </span><span><strong class="def-name">MAX_MOVE_MAX</strong><a class="copiable-link" href="#index-MAX_005fMOVE_005fMAX"> &para;</a></span></dt>
<dd><p>The maximum number of bytes that a single instruction can move quickly
between memory and registers or between two memory locations.  If this
is undefined, the default is <code class="code">MOVE_MAX</code>.  Otherwise, it is the
constant value that is the largest value that <code class="code">MOVE_MAX</code> can have
at run-time.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-SHIFT_005fCOUNT_005fTRUNCATED"><span class="category-def">Macro: </span><span><strong class="def-name">SHIFT_COUNT_TRUNCATED</strong><a class="copiable-link" href="#index-SHIFT_005fCOUNT_005fTRUNCATED"> &para;</a></span></dt>
<dd><p>A C expression that is nonzero if on this machine the number of bits
actually used for the count of a shift operation is equal to the number
of bits needed to represent the size of the object being shifted.  When
this macro is nonzero, the compiler will assume that it is safe to omit
a sign-extend, zero-extend, and certain bitwise &lsquo;and&rsquo; instructions that
truncates the count of a shift operation.  On machines that have
instructions that act on bit-fields at variable positions, which may
include &lsquo;bit test&rsquo; instructions, a nonzero <code class="code">SHIFT_COUNT_TRUNCATED</code>
also enables deletion of truncations of the values that serve as
arguments to bit-field instructions.
</p>
<p>If both types of instructions truncate the count (for shifts) and
position (for bit-field operations), or if no variable-position bit-field
instructions exist, you should define this macro.
</p>
<p>However, on some machines, such as the 80386 and the 680x0, truncation
only applies to shift operations and not the (real or pretended)
bit-field operations.  Define <code class="code">SHIFT_COUNT_TRUNCATED</code> to be zero on
such machines.  Instead, add patterns to the <samp class="file">md</samp> file that include
the implied truncation of the shift instructions.
</p>
<p>You need not define this macro if it would always have the value of zero.
</p></dd></dl>

<a class="anchor" id="TARGET_005fSHIFT_005fTRUNCATION_005fMASK"></a><dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSHIFT_005fTRUNCATION_005fMASK"><span class="category-def">Target Hook: </span><span><code class="def-type">unsigned HOST_WIDE_INT</code> <strong class="def-name">TARGET_SHIFT_TRUNCATION_MASK</strong> <code class="def-code-arguments">(machine_mode <var class="var">mode</var>)</code><a class="copiable-link" href="#index-TARGET_005fSHIFT_005fTRUNCATION_005fMASK"> &para;</a></span></dt>
<dd><p>This function describes how the standard shift patterns for <var class="var">mode</var>
deal with shifts by negative amounts or by more than the width of the mode.
See <a class="xref" href="Standard-Names.html#shift-patterns">shift patterns</a>.
</p>
<p>On many machines, the shift patterns will apply a mask <var class="var">m</var> to the
shift count, meaning that a fixed-width shift of <var class="var">x</var> by <var class="var">y</var> is
equivalent to an arbitrary-width shift of <var class="var">x</var> by <var class="var">y &amp; m</var>.  If
this is true for mode <var class="var">mode</var>, the function should return <var class="var">m</var>,
otherwise it should return 0.  A return value of 0 indicates that no
particular behavior is guaranteed.
</p>
<p>Note that, unlike <code class="code">SHIFT_COUNT_TRUNCATED</code>, this function does
<em class="emph">not</em> apply to general shift rtxes; it applies only to instructions
that are generated by the named shift patterns.
</p>
<p>The default implementation of this function returns
<code class="code">GET_MODE_BITSIZE (<var class="var">mode</var>) - 1</code> if <code class="code">SHIFT_COUNT_TRUNCATED</code>
and 0 otherwise.  This definition is always safe, but if
<code class="code">SHIFT_COUNT_TRUNCATED</code> is false, and some shift patterns
nevertheless truncate the shift count, you may get better code
by overriding it.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fTRULY_005fNOOP_005fTRUNCATION"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_TRULY_NOOP_TRUNCATION</strong> <code class="def-code-arguments">(poly_uint64 <var class="var">outprec</var>, poly_uint64 <var class="var">inprec</var>)</code><a class="copiable-link" href="#index-TARGET_005fTRULY_005fNOOP_005fTRUNCATION"> &para;</a></span></dt>
<dd><p>This hook returns true if it is safe to &ldquo;convert&rdquo; a value of
<var class="var">inprec</var> bits to one of <var class="var">outprec</var> bits (where <var class="var">outprec</var> is
smaller than <var class="var">inprec</var>) by merely operating on it as if it had only
<var class="var">outprec</var> bits.  The default returns true unconditionally, which
is correct for most machines.  When <code class="code">TARGET_TRULY_NOOP_TRUNCATION</code>
returns false, the machine description should provide a <code class="code">trunc</code>
optab to specify the RTL that performs the required truncation.
</p>
<p>If <code class="code">TARGET_MODES_TIEABLE_P</code> returns false for a pair of modes,
suboptimal code can result if this hook returns true for the corresponding
mode sizes.  Making this hook return false in such cases may improve things.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fMODE_005fREP_005fEXTENDED"><span class="category-def">Target Hook: </span><span><code class="def-type">int</code> <strong class="def-name">TARGET_MODE_REP_EXTENDED</strong> <code class="def-code-arguments">(scalar_int_mode <var class="var">mode</var>, scalar_int_mode <var class="var">rep_mode</var>)</code><a class="copiable-link" href="#index-TARGET_005fMODE_005fREP_005fEXTENDED"> &para;</a></span></dt>
<dd><p>The representation of an integral mode can be such that the values
are always extended to a wider integral mode.  Return
<code class="code">SIGN_EXTEND</code> if values of <var class="var">mode</var> are represented in
sign-extended form to <var class="var">rep_mode</var>.  Return <code class="code">UNKNOWN</code>
otherwise.  (Currently, none of the targets use zero-extended
representation this way so unlike <code class="code">LOAD_EXTEND_OP</code>,
<code class="code">TARGET_MODE_REP_EXTENDED</code> is expected to return either
<code class="code">SIGN_EXTEND</code> or <code class="code">UNKNOWN</code>.  Also no target extends
<var class="var">mode</var> to <var class="var">rep_mode</var> so that <var class="var">rep_mode</var> is not the next
widest integral mode and currently we take advantage of this fact.)
</p>
<p>Similarly to <code class="code">LOAD_EXTEND_OP</code> you may return a non-<code class="code">UNKNOWN</code>
value even if the extension is not performed on certain hard registers
as long as for the <code class="code">REGNO_REG_CLASS</code> of these hard registers
<code class="code">TARGET_CAN_CHANGE_MODE_CLASS</code> returns false.
</p>
<p>Note that <code class="code">TARGET_MODE_REP_EXTENDED</code> and <code class="code">LOAD_EXTEND_OP</code>
describe two related properties.  If you define
<code class="code">TARGET_MODE_REP_EXTENDED (mode, word_mode)</code> you probably also want
to define <code class="code">LOAD_EXTEND_OP (mode)</code> to return the same type of
extension.
</p>
<p>In order to enforce the representation of <code class="code">mode</code>,
<code class="code">TARGET_TRULY_NOOP_TRUNCATION</code> should return false when truncating to
<code class="code">mode</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSETJMP_005fPRESERVES_005fNONVOLATILE_005fREGS_005fP"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_SETJMP_PRESERVES_NONVOLATILE_REGS_P</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fSETJMP_005fPRESERVES_005fNONVOLATILE_005fREGS_005fP"> &para;</a></span></dt>
<dd><p>On some targets, it is assumed that the compiler will spill all pseudos
  that are live across a call to <code class="code">setjmp</code>, while other targets treat
  <code class="code">setjmp</code> calls as normal function calls.
</p>  
<p>This hook returns false if <code class="code">setjmp</code> calls do not preserve all
  non-volatile registers so that gcc that must spill all pseudos that are
  live across <code class="code">setjmp</code> calls.  Define this to return true if the
  target does not need to spill all pseudos live across <code class="code">setjmp</code> calls.
  The default implementation conservatively assumes all pseudos must be
  spilled across <code class="code">setjmp</code> calls.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-STORE_005fFLAG_005fVALUE"><span class="category-def">Macro: </span><span><strong class="def-name">STORE_FLAG_VALUE</strong><a class="copiable-link" href="#index-STORE_005fFLAG_005fVALUE"> &para;</a></span></dt>
<dd><p>A C expression describing the value returned by a comparison operator
with an integral mode and stored by a store-flag instruction
(&lsquo;<samp class="samp">cstore<var class="var">mode</var>4</samp>&rsquo;) when the condition is true.  This description must
apply to <em class="emph">all</em> the &lsquo;<samp class="samp">cstore<var class="var">mode</var>4</samp>&rsquo; patterns and all the
comparison operators whose results have a <code class="code">MODE_INT</code> mode.
</p>
<p>A value of 1 or &minus;1 means that the instruction implementing the
comparison operator returns exactly 1 or &minus;1 when the comparison is true
and 0 when the comparison is false.  Otherwise, the value indicates
which bits of the result are guaranteed to be 1 when the comparison is
true.  This value is interpreted in the mode of the comparison
operation, which is given by the mode of the first operand in the
&lsquo;<samp class="samp">cstore<var class="var">mode</var>4</samp>&rsquo; pattern.  Either the low bit or the sign bit of
<code class="code">STORE_FLAG_VALUE</code> be on.  Presently, only those bits are used by
the compiler.
</p>
<p>If <code class="code">STORE_FLAG_VALUE</code> is neither 1 or &minus;1, the compiler will
generate code that depends only on the specified bits.  It can also
replace comparison operators with equivalent operations if they cause
the required bits to be set, even if the remaining bits are undefined.
For example, on a machine whose comparison operators return an
<code class="code">SImode</code> value and where <code class="code">STORE_FLAG_VALUE</code> is defined as
&lsquo;<samp class="samp">0x80000000</samp>&rsquo;, saying that just the sign bit is relevant, the
expression
</p>
<div class="example smallexample">
<pre class="example-preformatted">(ne:SI (and:SI <var class="var">x</var> (const_int <var class="var">power-of-2</var>)) (const_int 0))
</pre></div>

<p>can be converted to
</p>
<div class="example smallexample">
<pre class="example-preformatted">(ashift:SI <var class="var">x</var> (const_int <var class="var">n</var>))
</pre></div>

<p>where <var class="var">n</var> is the appropriate shift count to move the bit being
tested into the sign bit.
</p>
<p>There is no way to describe a machine that always sets the low-order bit
for a true value, but does not guarantee the value of any other bits,
but we do not know of any machine that has such an instruction.  If you
are trying to port GCC to such a machine, include an instruction to
perform a logical-and of the result with 1 in the pattern for the
comparison operators and let us know at <a class="email" href="mailto:gcc@gcc.gnu.org">gcc@gcc.gnu.org</a>.
</p>
<p>Often, a machine will have multiple instructions that obtain a value
from a comparison (or the condition codes).  Here are rules to guide the
choice of value for <code class="code">STORE_FLAG_VALUE</code>, and hence the instructions
to be used:
</p>
<ul class="itemize mark-bullet">
<li>Use the shortest sequence that yields a valid definition for
<code class="code">STORE_FLAG_VALUE</code>.  It is more efficient for the compiler to
&ldquo;normalize&rdquo; the value (convert it to, e.g., 1 or 0) than for the
comparison operators to do so because there may be opportunities to
combine the normalization with other operations.

</li><li>For equal-length sequences, use a value of 1 or &minus;1, with &minus;1 being
slightly preferred on machines with expensive jumps and 1 preferred on
other machines.

</li><li>As a second choice, choose a value of &lsquo;<samp class="samp">0x80000001</samp>&rsquo; if instructions
exist that set both the sign and low-order bits but do not define the
others.

</li><li>Otherwise, use a value of &lsquo;<samp class="samp">0x80000000</samp>&rsquo;.
</li></ul>

<p>Many machines can produce both the value chosen for
<code class="code">STORE_FLAG_VALUE</code> and its negation in the same number of
instructions.  On those machines, you should also define a pattern for
those cases, e.g., one matching
</p>
<div class="example smallexample">
<pre class="example-preformatted">(set <var class="var">A</var> (neg:<var class="var">m</var> (ne:<var class="var">m</var> <var class="var">B</var> <var class="var">C</var>)))
</pre></div>

<p>Some machines can also perform <code class="code">and</code> or <code class="code">plus</code> operations on
condition code values with less instructions than the corresponding
&lsquo;<samp class="samp">cstore<var class="var">mode</var>4</samp>&rsquo; insn followed by <code class="code">and</code> or <code class="code">plus</code>.  On those
machines, define the appropriate patterns.  Use the names <code class="code">incscc</code>
and <code class="code">decscc</code>, respectively, for the patterns which perform
<code class="code">plus</code> or <code class="code">minus</code> operations on condition code values.  See
<samp class="file">rs6000.md</samp> for some examples.  The GNU Superoptimizer can be used to
find such instruction sequences on other machines.
</p>
<p>If this macro is not defined, the default value, 1, is used.  You need
not define <code class="code">STORE_FLAG_VALUE</code> if the machine has no store-flag
instructions, or if the value generated by these instructions is 1.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-FLOAT_005fSTORE_005fFLAG_005fVALUE"><span class="category-def">Macro: </span><span><strong class="def-name">FLOAT_STORE_FLAG_VALUE</strong> <var class="def-var-arguments">(<var class="var">mode</var>)</var><a class="copiable-link" href="#index-FLOAT_005fSTORE_005fFLAG_005fVALUE"> &para;</a></span></dt>
<dd><p>A C expression that gives a nonzero <code class="code">REAL_VALUE_TYPE</code> value that is
returned when comparison operators with floating-point results are true.
Define this macro on machines that have comparison operations that return
floating-point values.  If there are no such operations, do not define
this macro.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-VECTOR_005fSTORE_005fFLAG_005fVALUE"><span class="category-def">Macro: </span><span><strong class="def-name">VECTOR_STORE_FLAG_VALUE</strong> <var class="def-var-arguments">(<var class="var">mode</var>)</var><a class="copiable-link" href="#index-VECTOR_005fSTORE_005fFLAG_005fVALUE"> &para;</a></span></dt>
<dd><p>A C expression that gives an rtx representing the nonzero true element
for vector comparisons.  The returned rtx should be valid for the inner
mode of <var class="var">mode</var> which is guaranteed to be a vector mode.  Define
this macro on machines that have vector comparison operations that
return a vector result.  If there are no such operations, do not define
this macro.  Typically, this macro is defined as <code class="code">const1_rtx</code> or
<code class="code">constm1_rtx</code>.  This macro may return <code class="code">NULL_RTX</code> to prevent
the compiler optimizing such vector comparison operations for the
given mode.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-CLZ_005fDEFINED_005fVALUE_005fAT_005fZERO"><span class="category-def">Macro: </span><span><strong class="def-name">CLZ_DEFINED_VALUE_AT_ZERO</strong> <var class="def-var-arguments">(<var class="var">mode</var>, <var class="var">value</var>)</var><a class="copiable-link" href="#index-CLZ_005fDEFINED_005fVALUE_005fAT_005fZERO"> &para;</a></span></dt>
<dt class="deffnx defmacx-alias-deffnx def-cmd-deffn" id="index-CTZ_005fDEFINED_005fVALUE_005fAT_005fZERO"><span class="category-def">Macro: </span><span><strong class="def-name">CTZ_DEFINED_VALUE_AT_ZERO</strong> <var class="def-var-arguments">(<var class="var">mode</var>, <var class="var">value</var>)</var><a class="copiable-link" href="#index-CTZ_005fDEFINED_005fVALUE_005fAT_005fZERO"> &para;</a></span></dt>
<dd><p>A C expression that indicates whether the architecture defines a value
for <code class="code">clz</code> or <code class="code">ctz</code> with a zero operand.
A result of <code class="code">0</code> indicates the value is undefined.
If the value is defined for only the RTL expression, the macro should
evaluate to <code class="code">1</code>; if the value applies also to the corresponding optab
entry (which is normally the case if it expands directly into
the corresponding RTL), then the macro should evaluate to <code class="code">2</code>.
In the cases where the value is defined, <var class="var">value</var> should be set to
this value.
</p>
<p>If this macro is not defined, the value of <code class="code">clz</code> or
<code class="code">ctz</code> at zero is assumed to be undefined.
</p>
<p>This macro must be defined if the target&rsquo;s expansion for <code class="code">ffs</code>
relies on a particular value to get correct results.  Otherwise it
is not necessary, though it may be used to optimize some corner cases, and
to provide a default expansion for the <code class="code">ffs</code> optab.
</p>
<p>Note that regardless of this macro the &ldquo;definedness&rdquo; of <code class="code">clz</code>
and <code class="code">ctz</code> at zero do <em class="emph">not</em> extend to the builtin functions
visible to the user.  Thus one may be free to adjust the value at will
to match the target expansion of these operations without fear of
breaking the API.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-Pmode"><span class="category-def">Macro: </span><span><strong class="def-name">Pmode</strong><a class="copiable-link" href="#index-Pmode"> &para;</a></span></dt>
<dd><p>An alias for the machine mode for pointers.  On most machines, define
this to be the integer mode corresponding to the width of a hardware
pointer; <code class="code">SImode</code> on 32-bit machine or <code class="code">DImode</code> on 64-bit machines.
On some machines you must define this to be one of the partial integer
modes, such as <code class="code">PSImode</code>.
</p>
<p>The width of <code class="code">Pmode</code> must be at least as large as the value of
<code class="code">POINTER_SIZE</code>.  If it is not equal, you must define the macro
<code class="code">POINTERS_EXTEND_UNSIGNED</code> to specify how pointers are extended
to <code class="code">Pmode</code>.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-FUNCTION_005fMODE"><span class="category-def">Macro: </span><span><strong class="def-name">FUNCTION_MODE</strong><a class="copiable-link" href="#index-FUNCTION_005fMODE"> &para;</a></span></dt>
<dd><p>An alias for the machine mode used for memory references to functions
being called, in <code class="code">call</code> RTL expressions.  On most CISC machines,
where an instruction can begin at any byte address, this should be
<code class="code">QImode</code>.  On most RISC machines, where all instructions have fixed
size and alignment, this should be a mode with the same size and alignment
as the machine instruction words - typically <code class="code">SImode</code> or <code class="code">HImode</code>.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-STDC_005f0_005fIN_005fSYSTEM_005fHEADERS"><span class="category-def">Macro: </span><span><strong class="def-name">STDC_0_IN_SYSTEM_HEADERS</strong><a class="copiable-link" href="#index-STDC_005f0_005fIN_005fSYSTEM_005fHEADERS"> &para;</a></span></dt>
<dd><p>In normal operation, the preprocessor expands <code class="code">__STDC__</code> to the
constant 1, to signify that GCC conforms to ISO Standard C.  On some
hosts, like Solaris, the system compiler uses a different convention,
where <code class="code">__STDC__</code> is normally 0, but is 1 if the user specifies
strict conformance to the C Standard.
</p>
<p>Defining <code class="code">STDC_0_IN_SYSTEM_HEADERS</code> makes GNU CPP follows the host
convention when processing system header files, but when processing user
files <code class="code">__STDC__</code> will always expand to 1.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fC_005fPREINCLUDE"><span class="category-def">C Target Hook: </span><span><code class="def-type">const char *</code> <strong class="def-name">TARGET_C_PREINCLUDE</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fC_005fPREINCLUDE"> &para;</a></span></dt>
<dd><p>Define this hook to return the name of a header file to be included at
the start of all compilations, as if it had been included with
<code class="code">#include &lt;<var class="var">file</var>&gt;</code>.  If this hook returns <code class="code">NULL</code>, or is
not defined, or the header is not found, or if the user specifies
<samp class="option">-ffreestanding</samp> or <samp class="option">-nostdinc</samp>, no header is included.
</p>
<p>This hook can be used together with a header provided by the system C
library to implement ISO C requirements for certain macros to be
predefined that describe properties of the whole implementation rather
than just the compiler.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fCXX_005fIMPLICIT_005fEXTERN_005fC"><span class="category-def">C Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_CXX_IMPLICIT_EXTERN_C</strong> <code class="def-code-arguments">(const char*<var class="var"></var>)</code><a class="copiable-link" href="#index-TARGET_005fCXX_005fIMPLICIT_005fEXTERN_005fC"> &para;</a></span></dt>
<dd><p>Define this hook to add target-specific C++ implicit extern C functions.
If this function returns true for the name of a file-scope function, that
function implicitly gets extern &quot;C&quot; linkage rather than whatever language
linkage the declaration would normally have.  An example of such function
is WinMain on Win32 targets.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-SYSTEM_005fIMPLICIT_005fEXTERN_005fC"><span class="category-def">Macro: </span><span><strong class="def-name">SYSTEM_IMPLICIT_EXTERN_C</strong><a class="copiable-link" href="#index-SYSTEM_005fIMPLICIT_005fEXTERN_005fC"> &para;</a></span></dt>
<dd><p>Define this macro if the system header files do not support C++.
This macro handles system header files by pretending that system
header files are enclosed in &lsquo;<samp class="samp">extern &quot;C&quot; {&hellip;}</samp>&rsquo;.
</p></dd></dl>

<a class="index-entry-id" id="index-_0023pragma"></a>
<a class="index-entry-id" id="index-pragma"></a>
<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-REGISTER_005fTARGET_005fPRAGMAS"><span class="category-def">Macro: </span><span><strong class="def-name">REGISTER_TARGET_PRAGMAS</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="#index-REGISTER_005fTARGET_005fPRAGMAS"> &para;</a></span></dt>
<dd><p>Define this macro if you want to implement any target-specific pragmas.
If defined, it is a C expression which makes a series of calls to
<code class="code">c_register_pragma</code> or <code class="code">c_register_pragma_with_expansion</code>
for each pragma.  The macro may also do any
setup required for the pragmas.
</p>
<p>The primary reason to define this macro is to provide compatibility with
other compilers for the same target.  In general, we discourage
definition of target-specific pragmas for GCC.
</p>
<p>If the pragma can be implemented by attributes then you should consider
defining the target hook &lsquo;<samp class="samp">TARGET_INSERT_ATTRIBUTES</samp>&rsquo; as well.
</p>
<p>Preprocessor macros that appear on pragma lines are not expanded.  All
&lsquo;<samp class="samp">#pragma</samp>&rsquo; directives that do not match any registered pragma are
silently ignored, unless the user specifies <samp class="option">-Wunknown-pragmas</samp>.
</p></dd></dl>

<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-c_005fregister_005fpragma"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">c_register_pragma</strong> <code class="def-code-arguments">(const char *<var class="var">space</var>, const char *<var class="var">name</var>, void (*<var class="var">callback</var>) (struct cpp_reader *))</code><a class="copiable-link" href="#index-c_005fregister_005fpragma"> &para;</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-c_005fregister_005fpragma_005fwith_005fexpansion"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">c_register_pragma_with_expansion</strong> <code class="def-code-arguments">(const char *<var class="var">space</var>, const char *<var class="var">name</var>, void (*<var class="var">callback</var>) (struct cpp_reader *))</code><a class="copiable-link" href="#index-c_005fregister_005fpragma_005fwith_005fexpansion"> &para;</a></span></dt>
<dd>
<p>Each call to <code class="code">c_register_pragma</code> or
<code class="code">c_register_pragma_with_expansion</code> establishes one pragma.  The
<var class="var">callback</var> routine will be called when the preprocessor encounters a
pragma of the form
</p>
<div class="example smallexample">
<pre class="example-preformatted">#pragma [<var class="var">space</var>] <var class="var">name</var> ...
</pre></div>

<p><var class="var">space</var> is the case-sensitive namespace of the pragma, or
<code class="code">NULL</code> to put the pragma in the global namespace.  The callback
routine receives <var class="var">pfile</var> as its first argument, which can be passed
on to cpplib&rsquo;s functions if necessary.  You can lex tokens after the
<var class="var">name</var> by calling <code class="code">pragma_lex</code>.  Tokens that are not read by the
callback will be silently ignored.  The end of the line is indicated by
a token of type <code class="code">CPP_EOF</code>.  Macro expansion occurs on the
arguments of pragmas registered with
<code class="code">c_register_pragma_with_expansion</code> but not on the arguments of
pragmas registered with <code class="code">c_register_pragma</code>.
</p>
<p>Note that the use of <code class="code">pragma_lex</code> is specific to the C and C++
compilers.  It will not work in the Java or Fortran compilers, or any
other language compilers for that matter.  Thus if <code class="code">pragma_lex</code> is going
to be called from target-specific code, it must only be done so when
building the C and C++ compilers.  This can be done by defining the
variables <code class="code">c_target_objs</code> and <code class="code">cxx_target_objs</code> in the
target entry in the <samp class="file">config.gcc</samp> file.  These variables should name
the target-specific, language-specific object file which contains the
code that uses <code class="code">pragma_lex</code>.  Note it will also be necessary to add a
rule to the makefile fragment pointed to by <code class="code">tmake_file</code> that shows
how to build this object file.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-HANDLE_005fPRAGMA_005fPACK_005fWITH_005fEXPANSION"><span class="category-def">Macro: </span><span><strong class="def-name">HANDLE_PRAGMA_PACK_WITH_EXPANSION</strong><a class="copiable-link" href="#index-HANDLE_005fPRAGMA_005fPACK_005fWITH_005fEXPANSION"> &para;</a></span></dt>
<dd><p>Define this macro if macros should be expanded in the
arguments of &lsquo;<samp class="samp">#pragma pack</samp>&rsquo;.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-TARGET_005fDEFAULT_005fPACK_005fSTRUCT"><span class="category-def">Macro: </span><span><strong class="def-name">TARGET_DEFAULT_PACK_STRUCT</strong><a class="copiable-link" href="#index-TARGET_005fDEFAULT_005fPACK_005fSTRUCT"> &para;</a></span></dt>
<dd><p>If your target requires a structure packing default other than 0 (meaning
the machine default), define this macro to the necessary value (in bytes).
This must be a value that would also be valid to use with
&lsquo;<samp class="samp">#pragma pack()</samp>&rsquo; (that is, a small power of two).
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-DOLLARS_005fIN_005fIDENTIFIERS"><span class="category-def">Macro: </span><span><strong class="def-name">DOLLARS_IN_IDENTIFIERS</strong><a class="copiable-link" href="#index-DOLLARS_005fIN_005fIDENTIFIERS"> &para;</a></span></dt>
<dd><p>Define this macro to control use of the character &lsquo;<samp class="samp">$</samp>&rsquo; in
identifier names for the C family of languages.  0 means &lsquo;<samp class="samp">$</samp>&rsquo; is
not allowed by default; 1 means it is allowed.  1 is the default;
there is no need to define this macro in that case.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-INSN_005fSETS_005fARE_005fDELAYED"><span class="category-def">Macro: </span><span><strong class="def-name">INSN_SETS_ARE_DELAYED</strong> <var class="def-var-arguments">(<var class="var">insn</var>)</var><a class="copiable-link" href="#index-INSN_005fSETS_005fARE_005fDELAYED"> &para;</a></span></dt>
<dd><p>Define this macro as a C expression that is nonzero if it is safe for the
delay slot scheduler to place instructions in the delay slot of <var class="var">insn</var>,
even if they appear to use a resource set or clobbered in <var class="var">insn</var>.
<var class="var">insn</var> is always a <code class="code">jump_insn</code> or an <code class="code">insn</code>; GCC knows that
every <code class="code">call_insn</code> has this behavior.  On machines where some <code class="code">insn</code>
or <code class="code">jump_insn</code> is really a function call and hence has this behavior,
you should define this macro.
</p>
<p>You need not define this macro if it would always return zero.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-INSN_005fREFERENCES_005fARE_005fDELAYED"><span class="category-def">Macro: </span><span><strong class="def-name">INSN_REFERENCES_ARE_DELAYED</strong> <var class="def-var-arguments">(<var class="var">insn</var>)</var><a class="copiable-link" href="#index-INSN_005fREFERENCES_005fARE_005fDELAYED"> &para;</a></span></dt>
<dd><p>Define this macro as a C expression that is nonzero if it is safe for the
delay slot scheduler to place instructions in the delay slot of <var class="var">insn</var>,
even if they appear to set or clobber a resource referenced in <var class="var">insn</var>.
<var class="var">insn</var> is always a <code class="code">jump_insn</code> or an <code class="code">insn</code>.  On machines where
some <code class="code">insn</code> or <code class="code">jump_insn</code> is really a function call and its operands
are registers whose use is actually in the subroutine it calls, you should
define this macro.  Doing so allows the delay slot scheduler to move
instructions which copy arguments into the argument registers into the delay
slot of <var class="var">insn</var>.
</p>
<p>You need not define this macro if it would always return zero.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-MULTIPLE_005fSYMBOL_005fSPACES"><span class="category-def">Macro: </span><span><strong class="def-name">MULTIPLE_SYMBOL_SPACES</strong><a class="copiable-link" href="#index-MULTIPLE_005fSYMBOL_005fSPACES"> &para;</a></span></dt>
<dd><p>Define this macro as a C expression that is nonzero if, in some cases,
global symbols from one translation unit may not be bound to undefined
symbols in another translation unit without user intervention.  For
instance, under Microsoft Windows symbols must be explicitly imported
from shared libraries (DLLs).
</p>
<p>You need not define this macro if it would always evaluate to zero.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fMD_005fASM_005fADJUST"><span class="category-def">Target Hook: </span><span><code class="def-type">rtx_insn *</code> <strong class="def-name">TARGET_MD_ASM_ADJUST</strong> <code class="def-code-arguments">(vec&lt;rtx&gt;&amp; <var class="var">outputs</var>, vec&lt;rtx&gt;&amp; <var class="var">inputs</var>, vec&lt;machine_mode&gt;&amp; <var class="var">input_modes</var>, vec&lt;const char *&gt;&amp; <var class="var">constraints</var>, vec&lt;rtx&gt;&amp; <var class="var">usess</var>, vec&lt;rtx&gt;&amp; <var class="var">clobbers</var>, HARD_REG_SET&amp; <var class="var">clobbered_regs</var>, location_t <var class="var">loc</var>)</code><a class="copiable-link" href="#index-TARGET_005fMD_005fASM_005fADJUST"> &para;</a></span></dt>
<dd><p>This target hook may add <em class="dfn">clobbers</em> to <var class="var">clobbers</var> and
<var class="var">clobbered_regs</var> for any hard regs the port wishes to automatically
clobber for an asm.  It can also add hard registers that are used by the
asm to <var class="var">uses</var>.  The <var class="var">outputs</var> and <var class="var">inputs</var> may be inspected
to avoid clobbering a register that is already used by the asm.  <var class="var">loc</var>
is the source location of the asm.
</p>
<p>It may modify the <var class="var">outputs</var>, <var class="var">inputs</var>, <var class="var">input_modes</var>, and
<var class="var">constraints</var> as necessary for other pre-processing.  In this case the
return value is a sequence of insns to emit after the asm.  Note that
changes to <var class="var">inputs</var> must be accompanied by the corresponding changes
to <var class="var">input_modes</var>.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-MATH_005fLIBRARY"><span class="category-def">Macro: </span><span><strong class="def-name">MATH_LIBRARY</strong><a class="copiable-link" href="#index-MATH_005fLIBRARY"> &para;</a></span></dt>
<dd><p>Define this macro as a C string constant for the linker argument to link
in the system math library, minus the initial &lsquo;<samp class="samp">&quot;-l&quot;</samp>&rsquo;, or
&lsquo;<samp class="samp">&quot;&quot;</samp>&rsquo; if the target does not have a
separate math library.
</p>
<p>You need only define this macro if the default of &lsquo;<samp class="samp">&quot;m&quot;</samp>&rsquo; is wrong.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-LIBRARY_005fPATH_005fENV"><span class="category-def">Macro: </span><span><strong class="def-name">LIBRARY_PATH_ENV</strong><a class="copiable-link" href="#index-LIBRARY_005fPATH_005fENV"> &para;</a></span></dt>
<dd><p>Define this macro as a C string constant for the environment variable that
specifies where the linker should look for libraries.
</p>
<p>You need only define this macro if the default of &lsquo;<samp class="samp">&quot;LIBRARY_PATH&quot;</samp>&rsquo;
is wrong.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-TARGET_005fPOSIX_005fIO"><span class="category-def">Macro: </span><span><strong class="def-name">TARGET_POSIX_IO</strong><a class="copiable-link" href="#index-TARGET_005fPOSIX_005fIO"> &para;</a></span></dt>
<dd><p>Define this macro if the target supports the following POSIX&nbsp;file
functions, access, mkdir and  file locking with fcntl / F_SETLKW.
Defining <code class="code">TARGET_POSIX_IO</code> will enable the test coverage code
to use file locking when exiting a program, which avoids race conditions
if the program has forked. It will also create directories at run-time
for cross-profiling.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-MAX_005fCONDITIONAL_005fEXECUTE"><span class="category-def">Macro: </span><span><strong class="def-name">MAX_CONDITIONAL_EXECUTE</strong><a class="copiable-link" href="#index-MAX_005fCONDITIONAL_005fEXECUTE"> &para;</a></span></dt>
<dd>
<p>A C expression for the maximum number of instructions to execute via
conditional execution instructions instead of a branch.  A value of
<code class="code">BRANCH_COST</code>+1 is the default.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-IFCVT_005fMODIFY_005fTESTS"><span class="category-def">Macro: </span><span><strong class="def-name">IFCVT_MODIFY_TESTS</strong> <var class="def-var-arguments">(<var class="var">ce_info</var>, <var class="var">true_expr</var>, <var class="var">false_expr</var>)</var><a class="copiable-link" href="#index-IFCVT_005fMODIFY_005fTESTS"> &para;</a></span></dt>
<dd><p>Used if the target needs to perform machine-dependent modifications on the
conditionals used for turning basic blocks into conditionally executed code.
<var class="var">ce_info</var> points to a data structure, <code class="code">struct ce_if_block</code>, which
contains information about the currently processed blocks.  <var class="var">true_expr</var>
and <var class="var">false_expr</var> are the tests that are used for converting the
then-block and the else-block, respectively.  Set either <var class="var">true_expr</var> or
<var class="var">false_expr</var> to a null pointer if the tests cannot be converted.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-IFCVT_005fMODIFY_005fMULTIPLE_005fTESTS"><span class="category-def">Macro: </span><span><strong class="def-name">IFCVT_MODIFY_MULTIPLE_TESTS</strong> <var class="def-var-arguments">(<var class="var">ce_info</var>, <var class="var">bb</var>, <var class="var">true_expr</var>, <var class="var">false_expr</var>)</var><a class="copiable-link" href="#index-IFCVT_005fMODIFY_005fMULTIPLE_005fTESTS"> &para;</a></span></dt>
<dd><p>Like <code class="code">IFCVT_MODIFY_TESTS</code>, but used when converting more complicated
if-statements into conditions combined by <code class="code">and</code> and <code class="code">or</code> operations.
<var class="var">bb</var> contains the basic block that contains the test that is currently
being processed and about to be turned into a condition.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-IFCVT_005fMODIFY_005fINSN"><span class="category-def">Macro: </span><span><strong class="def-name">IFCVT_MODIFY_INSN</strong> <var class="def-var-arguments">(<var class="var">ce_info</var>, <var class="var">pattern</var>, <var class="var">insn</var>)</var><a class="copiable-link" href="#index-IFCVT_005fMODIFY_005fINSN"> &para;</a></span></dt>
<dd><p>A C expression to modify the <var class="var">PATTERN</var> of an <var class="var">INSN</var> that is to
be converted to conditional execution format.  <var class="var">ce_info</var> points to
a data structure, <code class="code">struct ce_if_block</code>, which contains information
about the currently processed blocks.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-IFCVT_005fMODIFY_005fFINAL"><span class="category-def">Macro: </span><span><strong class="def-name">IFCVT_MODIFY_FINAL</strong> <var class="def-var-arguments">(<var class="var">ce_info</var>)</var><a class="copiable-link" href="#index-IFCVT_005fMODIFY_005fFINAL"> &para;</a></span></dt>
<dd><p>A C expression to perform any final machine dependent modifications in
converting code to conditional execution.  The involved basic blocks
can be found in the <code class="code">struct ce_if_block</code> structure that is pointed
to by <var class="var">ce_info</var>.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-IFCVT_005fMODIFY_005fCANCEL"><span class="category-def">Macro: </span><span><strong class="def-name">IFCVT_MODIFY_CANCEL</strong> <var class="def-var-arguments">(<var class="var">ce_info</var>)</var><a class="copiable-link" href="#index-IFCVT_005fMODIFY_005fCANCEL"> &para;</a></span></dt>
<dd><p>A C expression to cancel any machine dependent modifications in
converting code to conditional execution.  The involved basic blocks
can be found in the <code class="code">struct ce_if_block</code> structure that is pointed
to by <var class="var">ce_info</var>.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-IFCVT_005fMACHDEP_005fINIT"><span class="category-def">Macro: </span><span><strong class="def-name">IFCVT_MACHDEP_INIT</strong> <var class="def-var-arguments">(<var class="var">ce_info</var>)</var><a class="copiable-link" href="#index-IFCVT_005fMACHDEP_005fINIT"> &para;</a></span></dt>
<dd><p>A C expression to initialize any machine specific data for if-conversion
of the if-block in the <code class="code">struct ce_if_block</code> structure that is pointed
to by <var class="var">ce_info</var>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fUSE_005fLATE_005fPROLOGUE_005fEPILOGUE"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_USE_LATE_PROLOGUE_EPILOGUE</strong> <code class="def-code-arguments">()</code><a class="copiable-link" href="#index-TARGET_005fUSE_005fLATE_005fPROLOGUE_005fEPILOGUE"> &para;</a></span></dt>
<dd><p>Return true if the current function&rsquo;s prologue and epilogue should
be emitted late in the pass pipeline, instead of at the usual point.
</p>
<p>Normally, the prologue and epilogue sequences are introduced soon after
register allocation is complete.  The advantage of this approach is that
it allows the prologue and epilogue instructions to be optimized and
scheduled with other code in the function.  However, some targets
require the prologue and epilogue to be the first and last sequences
executed by the function, with no variation allowed.  This hook should
return true on such targets.
</p>
<p>The default implementation returns false, which is correct for most
targets.  The hook should only return true if there is a specific
target limitation that cannot be described in RTL.  For example,
the hook might return true if the prologue and epilogue need to switch
between instruction sets.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fEMIT_005fEPILOGUE_005fFOR_005fSIBCALL"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_EMIT_EPILOGUE_FOR_SIBCALL</strong> <code class="def-code-arguments">(rtx_call_insn *<var class="var">call</var>)</code><a class="copiable-link" href="#index-TARGET_005fEMIT_005fEPILOGUE_005fFOR_005fSIBCALL"> &para;</a></span></dt>
<dd><p>If defined, this hook emits an epilogue sequence for sibling (tail)
call instruction <var class="var">call</var>.  Another way of providing epilogues
for sibling calls is to define the <code class="code">sibcall_epilogue</code> instruction
pattern; the main advantage of this hook over the pattern is that it
has access to the call instruction.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fMACHINE_005fDEPENDENT_005fREORG"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_MACHINE_DEPENDENT_REORG</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fMACHINE_005fDEPENDENT_005fREORG"> &para;</a></span></dt>
<dd><p>If non-null, this hook performs a target-specific pass over the
instruction stream.  The compiler will run it at all optimization levels,
just before the point at which it normally does delayed-branch scheduling.
</p>
<p>The exact purpose of the hook varies from target to target.  Some use
it to do transformations that are necessary for correctness, such as
laying out in-function constant pools or avoiding hardware hazards.
Others use it as an opportunity to do some machine-dependent optimizations.
</p>
<p>You need not implement the hook if it has nothing to do.  The default
definition is null.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fINIT_005fBUILTINS"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_INIT_BUILTINS</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fINIT_005fBUILTINS"> &para;</a></span></dt>
<dd><p>Define this hook if you have any machine-specific built-in functions
that need to be defined.  It should be a function that performs the
necessary setup.
</p>
<p>Machine specific built-in functions can be useful to expand special machine
instructions that would otherwise not normally be generated because
they have no equivalent in the source language (for example, SIMD vector
instructions or prefetch instructions).
</p>
<p>To create a built-in function, call the function
<code class="code">lang_hooks.builtin_function</code>
which is defined by the language front end.  You can use any type nodes set
up by <code class="code">build_common_tree_nodes</code>;
only language front ends that use those two functions will call
&lsquo;<samp class="samp">TARGET_INIT_BUILTINS</samp>&rsquo;.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fBUILTIN_005fDECL"><span class="category-def">Target Hook: </span><span><code class="def-type">tree</code> <strong class="def-name">TARGET_BUILTIN_DECL</strong> <code class="def-code-arguments">(unsigned <var class="var">code</var>, bool <var class="var">initialize_p</var>)</code><a class="copiable-link" href="#index-TARGET_005fBUILTIN_005fDECL"> &para;</a></span></dt>
<dd><p>Define this hook if you have any machine-specific built-in functions
that need to be defined.  It should be a function that returns the
builtin function declaration for the builtin function code <var class="var">code</var>.
If there is no such builtin and it cannot be initialized at this time
if <var class="var">initialize_p</var> is true the function should return <code class="code">NULL_TREE</code>.
If <var class="var">code</var> is out of range the function should return
<code class="code">error_mark_node</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fEXPAND_005fBUILTIN"><span class="category-def">Target Hook: </span><span><code class="def-type">rtx</code> <strong class="def-name">TARGET_EXPAND_BUILTIN</strong> <code class="def-code-arguments">(tree <var class="var">exp</var>, rtx <var class="var">target</var>, rtx <var class="var">subtarget</var>, machine_mode <var class="var">mode</var>, int <var class="var">ignore</var>)</code><a class="copiable-link" href="#index-TARGET_005fEXPAND_005fBUILTIN"> &para;</a></span></dt>
<dd>
<p>Expand a call to a machine specific built-in function that was set up by
&lsquo;<samp class="samp">TARGET_INIT_BUILTINS</samp>&rsquo;.  <var class="var">exp</var> is the expression for the
function call; the result should go to <var class="var">target</var> if that is
convenient, and have mode <var class="var">mode</var> if that is convenient.
<var class="var">subtarget</var> may be used as the target for computing one of
<var class="var">exp</var>&rsquo;s operands.  <var class="var">ignore</var> is nonzero if the value is to be
ignored.  This function should return the result of the call to the
built-in function.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fRESOLVE_005fOVERLOADED_005fBUILTIN"><span class="category-def">Target Hook: </span><span><code class="def-type">tree</code> <strong class="def-name">TARGET_RESOLVE_OVERLOADED_BUILTIN</strong> <code class="def-code-arguments">(location_t <var class="var">loc</var>, tree <var class="var">fndecl</var>, void *<var class="var">arglist</var>, bool <var class="var">complain</var>)</code><a class="copiable-link" href="#index-TARGET_005fRESOLVE_005fOVERLOADED_005fBUILTIN"> &para;</a></span></dt>
<dd><p>Select a replacement for a machine specific built-in function that
was set up by &lsquo;<samp class="samp">TARGET_INIT_BUILTINS</samp>&rsquo;.  This is done
<em class="emph">before</em> regular type checking, and so allows the target to
implement a crude form of function overloading.  <var class="var">fndecl</var> is the
declaration of the built-in function.  <var class="var">arglist</var> is the list of
arguments passed to the built-in function.  The result is a
complete expression that implements the operation, usually
another <code class="code">CALL_EXPR</code>.
<var class="var">arglist</var> really has type &lsquo;<samp class="samp">VEC(tree,gc)*</samp>&rsquo;
<var class="var">complain</var> is a boolean indicating whether invalid operations
should emit errors.  This is set to <code class="code">false</code> when the C++ templating
context expects that errors should not be emitted (i.e. SFINAE).
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fCHECK_005fBUILTIN_005fCALL"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_CHECK_BUILTIN_CALL</strong> <code class="def-code-arguments">(location_t <var class="var">loc</var>, vec&lt;location_t&gt; <var class="var">arg_loc</var>, tree <var class="var">fndecl</var>, tree <var class="var">orig_fndecl</var>, unsigned int <var class="var">nargs</var>, tree *<var class="var">args</var>, bool <var class="var">complain</var>)</code><a class="copiable-link" href="#index-TARGET_005fCHECK_005fBUILTIN_005fCALL"> &para;</a></span></dt>
<dd><p>Perform semantic checking on a call to a machine-specific built-in
function after its arguments have been constrained to the function
signature.  Return true if the call is valid, otherwise report an error
and return false.
</p>
<p>This hook is called after <code class="code">TARGET_RESOLVE_OVERLOADED_BUILTIN</code>.
The call was originally to built-in function <var class="var">orig_fndecl</var>,
but after the optional <code class="code">TARGET_RESOLVE_OVERLOADED_BUILTIN</code>
step is now to built-in function <var class="var">fndecl</var>.  <var class="var">loc</var> is the
location of the call and <var class="var">args</var> is an array of function arguments,
of which there are <var class="var">nargs</var>.  <var class="var">arg_loc</var> specifies the location
of each argument.  <var class="var">complain</var> is a boolean indicating whether invalid
arguments should emitm errors.  This is set to <code class="code">false</code> when the C++
templating context expects that errors should not be emitted (i.e. SFINAE).
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fFOLD_005fBUILTIN"><span class="category-def">Target Hook: </span><span><code class="def-type">tree</code> <strong class="def-name">TARGET_FOLD_BUILTIN</strong> <code class="def-code-arguments">(tree <var class="var">fndecl</var>, int <var class="var">n_args</var>, tree *<var class="var">argp</var>, bool <var class="var">ignore</var>)</code><a class="copiable-link" href="#index-TARGET_005fFOLD_005fBUILTIN"> &para;</a></span></dt>
<dd><p>Fold a call to a machine specific built-in function that was set up by
&lsquo;<samp class="samp">TARGET_INIT_BUILTINS</samp>&rsquo;.  <var class="var">fndecl</var> is the declaration of the
built-in function.  <var class="var">n_args</var> is the number of arguments passed to
the function; the arguments themselves are pointed to by <var class="var">argp</var>.
The result is another tree, valid for both GIMPLE and GENERIC,
containing a simplified expression for the call&rsquo;s result.  If
<var class="var">ignore</var> is true the value will be ignored.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fGIMPLE_005fFOLD_005fBUILTIN"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_GIMPLE_FOLD_BUILTIN</strong> <code class="def-code-arguments">(gimple_stmt_iterator *<var class="var">gsi</var>)</code><a class="copiable-link" href="#index-TARGET_005fGIMPLE_005fFOLD_005fBUILTIN"> &para;</a></span></dt>
<dd><p>Fold a call to a machine specific built-in function that was set up
by &lsquo;<samp class="samp">TARGET_INIT_BUILTINS</samp>&rsquo;.  <var class="var">gsi</var> points to the gimple
statement holding the function call.  Returns true if any change
was made to the GIMPLE stream.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fCOMPARE_005fVERSION_005fPRIORITY"><span class="category-def">Target Hook: </span><span><code class="def-type">int</code> <strong class="def-name">TARGET_COMPARE_VERSION_PRIORITY</strong> <code class="def-code-arguments">(tree <var class="var">decl1</var>, tree <var class="var">decl2</var>)</code><a class="copiable-link" href="#index-TARGET_005fCOMPARE_005fVERSION_005fPRIORITY"> &para;</a></span></dt>
<dd><p>This hook is used to compare the target attributes in two functions to
determine which function&rsquo;s features get higher priority.  This is used
during function multi-versioning to figure out the order in which two
versions must be dispatched.  A function version with a higher priority
is checked for dispatching earlier.  <var class="var">decl1</var> and <var class="var">decl2</var> are
 the two function decls that will be compared.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fGET_005fFUNCTION_005fVERSIONS_005fDISPATCHER"><span class="category-def">Target Hook: </span><span><code class="def-type">tree</code> <strong class="def-name">TARGET_GET_FUNCTION_VERSIONS_DISPATCHER</strong> <code class="def-code-arguments">(void *<var class="var">decl</var>)</code><a class="copiable-link" href="#index-TARGET_005fGET_005fFUNCTION_005fVERSIONS_005fDISPATCHER"> &para;</a></span></dt>
<dd><p>This hook is used to get the dispatcher function for a set of function
versions.  The dispatcher function is called to invoke the right function
version at run-time. <var class="var">decl</var> is one version from a set of semantically
identical versions.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fGENERATE_005fVERSION_005fDISPATCHER_005fBODY"><span class="category-def">Target Hook: </span><span><code class="def-type">tree</code> <strong class="def-name">TARGET_GENERATE_VERSION_DISPATCHER_BODY</strong> <code class="def-code-arguments">(void *<var class="var">arg</var>)</code><a class="copiable-link" href="#index-TARGET_005fGENERATE_005fVERSION_005fDISPATCHER_005fBODY"> &para;</a></span></dt>
<dd><p>This hook is used to generate the dispatcher logic to invoke the right
function version at run-time for a given set of function versions.
<var class="var">arg</var> points to the callgraph node of the dispatcher function whose
body must be generated.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fPREDICT_005fDOLOOP_005fP"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_PREDICT_DOLOOP_P</strong> <code class="def-code-arguments">(class loop *<var class="var">loop</var>)</code><a class="copiable-link" href="#index-TARGET_005fPREDICT_005fDOLOOP_005fP"> &para;</a></span></dt>
<dd><p>Return true if we can predict it is possible to use a low-overhead loop
for a particular loop.  The parameter <var class="var">loop</var> is a pointer to the loop.
This target hook is required only when the target supports low-overhead
loops, and will help ivopts to make some decisions.
The default version of this hook returns false.
</p></dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-TARGET_005fHAVE_005fCOUNT_005fREG_005fDECR_005fP"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_HAVE_COUNT_REG_DECR_P</strong><a class="copiable-link" href="#index-TARGET_005fHAVE_005fCOUNT_005fREG_005fDECR_005fP"> &para;</a></span></dt>
<dd><p>Return true if the target supports hardware count register for decrement
and branch.
The default value is false.
</p></dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-TARGET_005fDOLOOP_005fCOST_005fFOR_005fGENERIC"><span class="category-def">Target Hook: </span><span><code class="def-type">int64_t</code> <strong class="def-name">TARGET_DOLOOP_COST_FOR_GENERIC</strong><a class="copiable-link" href="#index-TARGET_005fDOLOOP_005fCOST_005fFOR_005fGENERIC"> &para;</a></span></dt>
<dd><p>One IV candidate dedicated for doloop is introduced in IVOPTs, we can
calculate the computation cost of adopting it to any generic IV use by
function get_computation_cost as before.  But for targets which have
hardware count register support for decrement and branch, it may have to
move IV value from hardware count register to general purpose register
while doloop IV candidate is used for generic IV uses.  It probably takes
expensive penalty.  This hook allows target owners to define the cost for
this especially for generic IV uses.
The default value is zero.
</p></dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-TARGET_005fDOLOOP_005fCOST_005fFOR_005fADDRESS"><span class="category-def">Target Hook: </span><span><code class="def-type">int64_t</code> <strong class="def-name">TARGET_DOLOOP_COST_FOR_ADDRESS</strong><a class="copiable-link" href="#index-TARGET_005fDOLOOP_005fCOST_005fFOR_005fADDRESS"> &para;</a></span></dt>
<dd><p>One IV candidate dedicated for doloop is introduced in IVOPTs, we can
calculate the computation cost of adopting it to any address IV use by
function get_computation_cost as before.  But for targets which have
hardware count register support for decrement and branch, it may have to
move IV value from hardware count register to general purpose register
while doloop IV candidate is used for address IV uses.  It probably takes
expensive penalty.  This hook allows target owners to define the cost for
this escpecially for address IV uses.
The default value is zero.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fCAN_005fUSE_005fDOLOOP_005fP"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_CAN_USE_DOLOOP_P</strong> <code class="def-code-arguments">(const widest_int <var class="var">&amp;iterations</var>, const widest_int <var class="var">&amp;iterations_max</var>, unsigned int <var class="var">loop_depth</var>, bool <var class="var">entered_at_top</var>)</code><a class="copiable-link" href="#index-TARGET_005fCAN_005fUSE_005fDOLOOP_005fP"> &para;</a></span></dt>
<dd><p>Return true if it is possible to use low-overhead loops (<code class="code">doloop_end</code>
and <code class="code">doloop_begin</code>) for a particular loop.  <var class="var">iterations</var> gives the
exact number of iterations, or 0 if not known.  <var class="var">iterations_max</var> gives
the maximum number of iterations, or 0 if not known.  <var class="var">loop_depth</var> is
the nesting depth of the loop, with 1 for innermost loops, 2 for loops that
contain innermost loops, and so on.  <var class="var">entered_at_top</var> is true if the
loop is only entered from the top.
</p>
<p>This hook is only used if <code class="code">doloop_end</code> is available.  The default
implementation returns true.  You can use <code class="code">can_use_doloop_if_innermost</code>
if the loop must be the innermost, and if there are no other restrictions.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fINVALID_005fWITHIN_005fDOLOOP"><span class="category-def">Target Hook: </span><span><code class="def-type">const char *</code> <strong class="def-name">TARGET_INVALID_WITHIN_DOLOOP</strong> <code class="def-code-arguments">(const rtx_insn *<var class="var">insn</var>)</code><a class="copiable-link" href="#index-TARGET_005fINVALID_005fWITHIN_005fDOLOOP"> &para;</a></span></dt>
<dd>
<p>Take an instruction in <var class="var">insn</var> and return NULL if it is valid within a
low-overhead loop, otherwise return a string explaining why doloop
could not be applied.
</p>
<p>Many targets use special registers for low-overhead looping. For any
instruction that clobbers these this function should return a string indicating
the reason why the doloop could not be applied.
By default, the RTL loop optimizer does not use a present doloop pattern for
loops containing function calls or branch on table instructions.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fPREFERRED_005fDOLOOP_005fMODE"><span class="category-def">Target Hook: </span><span><code class="def-type">machine_mode</code> <strong class="def-name">TARGET_PREFERRED_DOLOOP_MODE</strong> <code class="def-code-arguments">(machine_mode <var class="var">mode</var>)</code><a class="copiable-link" href="#index-TARGET_005fPREFERRED_005fDOLOOP_005fMODE"> &para;</a></span></dt>
<dd><p>This hook takes a <var class="var">mode</var> for a doloop IV, where <code class="code">mode</code> is the
original mode for the operation.  If the target prefers an alternate
<code class="code">mode</code> for the operation, then this hook should return that mode;
otherwise the original <code class="code">mode</code> should be returned.  For example, on a
64-bit target, <code class="code">DImode</code> might be preferred over <code class="code">SImode</code>.  Both the
original and the returned modes should be <code class="code">MODE_INT</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fLEGITIMATE_005fCOMBINED_005fINSN"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_LEGITIMATE_COMBINED_INSN</strong> <code class="def-code-arguments">(rtx_insn *<var class="var">insn</var>)</code><a class="copiable-link" href="#index-TARGET_005fLEGITIMATE_005fCOMBINED_005fINSN"> &para;</a></span></dt>
<dd><p>Take an instruction in <var class="var">insn</var> and return <code class="code">false</code> if the instruction
is not appropriate as a combination of two or more instructions.  The
default is to accept all instructions.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fCAN_005fFOLLOW_005fJUMP"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_CAN_FOLLOW_JUMP</strong> <code class="def-code-arguments">(const rtx_insn *<var class="var">follower</var>, const rtx_insn *<var class="var">followee</var>)</code><a class="copiable-link" href="#index-TARGET_005fCAN_005fFOLLOW_005fJUMP"> &para;</a></span></dt>
<dd><p>FOLLOWER and FOLLOWEE are JUMP_INSN instructions;
return true if FOLLOWER may be modified to follow FOLLOWEE;
false, if it can&rsquo;t.
For example, on some targets, certain kinds of branches can&rsquo;t be made to
follow through a hot/cold partitioning.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fCOMMUTATIVE_005fP"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_COMMUTATIVE_P</strong> <code class="def-code-arguments">(const_rtx <var class="var">x</var>, int <var class="var">outer_code</var>)</code><a class="copiable-link" href="#index-TARGET_005fCOMMUTATIVE_005fP"> &para;</a></span></dt>
<dd><p>This target hook returns <code class="code">true</code> if <var class="var">x</var> is considered to be commutative.
Usually, this is just COMMUTATIVE_P (<var class="var">x</var>), but the HP PA doesn&rsquo;t consider
PLUS to be commutative inside a MEM.  <var class="var">outer_code</var> is the rtx code
of the enclosing rtl, if known, otherwise it is UNKNOWN.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fALLOCATE_005fINITIAL_005fVALUE"><span class="category-def">Target Hook: </span><span><code class="def-type">rtx</code> <strong class="def-name">TARGET_ALLOCATE_INITIAL_VALUE</strong> <code class="def-code-arguments">(rtx <var class="var">hard_reg</var>)</code><a class="copiable-link" href="#index-TARGET_005fALLOCATE_005fINITIAL_005fVALUE"> &para;</a></span></dt>
<dd>
<p>When the initial value of a hard register has been copied in a pseudo
register, it is often not necessary to actually allocate another register
to this pseudo register, because the original hard register or a stack slot
it has been saved into can be used.  <code class="code">TARGET_ALLOCATE_INITIAL_VALUE</code>
is called at the start of register allocation once for each hard register
that had its initial value copied by using
<code class="code">get_func_hard_reg_initial_val</code> or <code class="code">get_hard_reg_initial_val</code>.
Possible values are <code class="code">NULL_RTX</code>, if you don&rsquo;t want
to do any special allocation, a <code class="code">REG</code> rtx&mdash;that would typically be
the hard register itself, if it is known not to be clobbered&mdash;or a
<code class="code">MEM</code>.
If you are returning a <code class="code">MEM</code>, this is only a hint for the allocator;
it might decide to use another register anyways.
You may use <code class="code">current_function_is_leaf</code> or 
<code class="code">REG_N_SETS</code> in the hook to determine if the hard
register in question will not be clobbered.
The default value of this hook is <code class="code">NULL</code>, which disables any special
allocation.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fUNSPEC_005fMAY_005fTRAP_005fP"><span class="category-def">Target Hook: </span><span><code class="def-type">int</code> <strong class="def-name">TARGET_UNSPEC_MAY_TRAP_P</strong> <code class="def-code-arguments">(const_rtx <var class="var">x</var>, unsigned <var class="var">flags</var>)</code><a class="copiable-link" href="#index-TARGET_005fUNSPEC_005fMAY_005fTRAP_005fP"> &para;</a></span></dt>
<dd><p>This target hook returns nonzero if <var class="var">x</var>, an <code class="code">unspec</code> might cause
a trap.  Targets can use this hook to enhance precision of analysis for
<code class="code">unspec</code> operations.  You may call <code class="code">may_trap_p_1</code> to analyze inner
elements of <var class="var">x</var> in which case <var class="var">flags</var> should be passed along.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSET_005fCURRENT_005fFUNCTION"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_SET_CURRENT_FUNCTION</strong> <code class="def-code-arguments">(tree <var class="var">decl</var>)</code><a class="copiable-link" href="#index-TARGET_005fSET_005fCURRENT_005fFUNCTION"> &para;</a></span></dt>
<dd><p>The compiler invokes this hook whenever it changes its current function
context (<code class="code">cfun</code>).  You can define this function if
the back end needs to perform any initialization or reset actions on a
per-function basis.  For example, it may be used to implement function
attributes that affect register usage or code generation patterns.
The argument <var class="var">decl</var> is the declaration for the new function context,
and may be null to indicate that the compiler has left a function context
and is returning to processing at the top level.
The default hook function does nothing.
</p>
<p>GCC sets <code class="code">cfun</code> to a dummy function context during initialization of
some parts of the back end.  The hook function is not invoked in this
situation; you need not worry about the hook being invoked recursively,
or when the back end is in a partially-initialized state.
<code class="code">cfun</code> might be <code class="code">NULL</code> to indicate processing at top level,
outside of any function scope.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-TARGET_005fOBJECT_005fSUFFIX"><span class="category-def">Macro: </span><span><strong class="def-name">TARGET_OBJECT_SUFFIX</strong><a class="copiable-link" href="#index-TARGET_005fOBJECT_005fSUFFIX"> &para;</a></span></dt>
<dd><p>Define this macro to be a C string representing the suffix for object
files on your target machine.  If you do not define this macro, GCC will
use &lsquo;<samp class="samp">.o</samp>&rsquo; as the suffix for object files.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-TARGET_005fEXECUTABLE_005fSUFFIX"><span class="category-def">Macro: </span><span><strong class="def-name">TARGET_EXECUTABLE_SUFFIX</strong><a class="copiable-link" href="#index-TARGET_005fEXECUTABLE_005fSUFFIX"> &para;</a></span></dt>
<dd><p>Define this macro to be a C string representing the suffix to be
automatically added to executable files on your target machine.  If you
do not define this macro, GCC will use the null string as the suffix for
executable files.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-COLLECT_005fEXPORT_005fLIST"><span class="category-def">Macro: </span><span><strong class="def-name">COLLECT_EXPORT_LIST</strong><a class="copiable-link" href="#index-COLLECT_005fEXPORT_005fLIST"> &para;</a></span></dt>
<dd><p>If defined, <code class="code">collect2</code> will scan the individual object files
specified on its command line and create an export list for the linker.
Define this macro for systems like AIX, where the linker discards
object files that are not referenced from <code class="code">main</code> and uses export
lists.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fCANNOT_005fMODIFY_005fJUMPS_005fP"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_CANNOT_MODIFY_JUMPS_P</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fCANNOT_005fMODIFY_005fJUMPS_005fP"> &para;</a></span></dt>
<dd><p>This target hook returns <code class="code">true</code> past the point in which new jump
instructions could be created.  On machines that require a register for
every jump such as the SHmedia ISA of SH5, this point would typically be
reload, so this target hook should be defined to a function such as:
</p>
<div class="example smallexample">
<pre class="example-preformatted">static bool
cannot_modify_jumps_past_reload_p ()
{
  return (reload_completed || reload_in_progress);
}
</pre></div>
</dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fHAVE_005fCONDITIONAL_005fEXECUTION"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_HAVE_CONDITIONAL_EXECUTION</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fHAVE_005fCONDITIONAL_005fEXECUTION"> &para;</a></span></dt>
<dd><p>This target hook returns true if the target supports conditional execution.
This target hook is required only when the target has several different
modes and they have different conditional execution capability, such as ARM.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fGEN_005fCCMP_005fFIRST"><span class="category-def">Target Hook: </span><span><code class="def-type">rtx</code> <strong class="def-name">TARGET_GEN_CCMP_FIRST</strong> <code class="def-code-arguments">(rtx_insn **<var class="var">prep_seq</var>, rtx_insn **<var class="var">gen_seq</var>, rtx_code <var class="var">code</var>, tree <var class="var">op0</var>, tree <var class="var">op1</var>)</code><a class="copiable-link" href="#index-TARGET_005fGEN_005fCCMP_005fFIRST"> &para;</a></span></dt>
<dd><p>This function prepares to emit a comparison insn for the first compare in a
 sequence of conditional comparisions.  It returns an appropriate comparison
 with <code class="code">CC</code> for passing to <code class="code">gen_ccmp_next</code> or <code class="code">cbranch_optab</code>.
 The insns to prepare the compare are saved in <var class="var">prep_seq</var> and the compare
 insns are saved in <var class="var">gen_seq</var>.  They will be emitted when all the
 compares in the conditional comparision are generated without error.
 <var class="var">code</var> is the <code class="code">rtx_code</code> of the compare for <var class="var">op0</var> and <var class="var">op1</var>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fGEN_005fCCMP_005fNEXT"><span class="category-def">Target Hook: </span><span><code class="def-type">rtx</code> <strong class="def-name">TARGET_GEN_CCMP_NEXT</strong> <code class="def-code-arguments">(rtx_insn **<var class="var">prep_seq</var>, rtx_insn **<var class="var">gen_seq</var>, rtx <var class="var">prev</var>, rtx_code <var class="var">cmp_code</var>, tree <var class="var">op0</var>, tree <var class="var">op1</var>, rtx_code <var class="var">bit_code</var>)</code><a class="copiable-link" href="#index-TARGET_005fGEN_005fCCMP_005fNEXT"> &para;</a></span></dt>
<dd><p>This function prepares to emit a conditional comparison within a sequence
 of conditional comparisons.  It returns an appropriate comparison with
 <code class="code">CC</code> for passing to <code class="code">gen_ccmp_next</code> or <code class="code">cbranch_optab</code>.
 The insns to prepare the compare are saved in <var class="var">prep_seq</var> and the compare
 insns are saved in <var class="var">gen_seq</var>.  They will be emitted when all the
 compares in the conditional comparision are generated without error.  The
 <var class="var">prev</var> expression is the result of a prior call to <code class="code">gen_ccmp_first</code>
 or <code class="code">gen_ccmp_next</code>.  It may return <code class="code">NULL</code> if the combination of
 <var class="var">prev</var> and this comparison is not supported, otherwise the result must
 be appropriate for passing to <code class="code">gen_ccmp_next</code> or <code class="code">cbranch_optab</code>.
 <var class="var">code</var> is the <code class="code">rtx_code</code> of the compare for <var class="var">op0</var> and <var class="var">op1</var>.
 <var class="var">bit_code</var> is <code class="code">AND</code> or <code class="code">IOR</code>, which is the op on the compares.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fHAVE_005fCCMP"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_HAVE_CCMP</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fHAVE_005fCCMP"> &para;</a></span></dt>
<dd><p>This target hook returns true if the target supports conditional compare.
This target hook is required only when the ccmp support is conditionally
enabled, such as in response to command-line flags. The default implementation
returns true iff <code class="code">TARGET_GEN_CCMP_FIRST</code> is defined.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fLOOP_005fUNROLL_005fADJUST"><span class="category-def">Target Hook: </span><span><code class="def-type">unsigned</code> <strong class="def-name">TARGET_LOOP_UNROLL_ADJUST</strong> <code class="def-code-arguments">(unsigned <var class="var">nunroll</var>, class loop *<var class="var">loop</var>)</code><a class="copiable-link" href="#index-TARGET_005fLOOP_005fUNROLL_005fADJUST"> &para;</a></span></dt>
<dd><p>This target hook returns a new value for the number of times <var class="var">loop</var>
should be unrolled. The parameter <var class="var">nunroll</var> is the number of times
the loop is to be unrolled. The parameter <var class="var">loop</var> is a pointer to
the loop, which is going to be checked for unrolling. This target hook
is required only when the target has special constraints like maximum
number of memory accesses.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-POWI_005fMAX_005fMULTS"><span class="category-def">Macro: </span><span><strong class="def-name">POWI_MAX_MULTS</strong><a class="copiable-link" href="#index-POWI_005fMAX_005fMULTS"> &para;</a></span></dt>
<dd><p>If defined, this macro is interpreted as a signed integer C expression
that specifies the maximum number of floating point multiplications
that should be emitted when expanding exponentiation by an integer
constant inline.  When this value is defined, exponentiation requiring
more than this number of multiplications is implemented by calling the
system library&rsquo;s <code class="code">pow</code>, <code class="code">powf</code> or <code class="code">powl</code> routines.
The default value places no upper bound on the multiplication count.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fEXTRA_005fINCLUDES"><span class="category-def">Macro: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_EXTRA_INCLUDES</strong> <code class="def-code-arguments">(const char *<var class="var">sysroot</var>, const char *<var class="var">iprefix</var>, int <var class="var">stdinc</var>)</code><a class="copiable-link" href="#index-TARGET_005fEXTRA_005fINCLUDES"> &para;</a></span></dt>
<dd><p>This target hook should register any extra include files for the
target.  The parameter <var class="var">stdinc</var> indicates if normal include files
are present.  The parameter <var class="var">sysroot</var> is the system root directory.
The parameter <var class="var">iprefix</var> is the prefix for the gcc directory.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fEXTRA_005fPRE_005fINCLUDES"><span class="category-def">Macro: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_EXTRA_PRE_INCLUDES</strong> <code class="def-code-arguments">(const char *<var class="var">sysroot</var>, const char *<var class="var">iprefix</var>, int <var class="var">stdinc</var>)</code><a class="copiable-link" href="#index-TARGET_005fEXTRA_005fPRE_005fINCLUDES"> &para;</a></span></dt>
<dd><p>This target hook should register any extra include files for the
target before any standard headers.  The parameter <var class="var">stdinc</var>
indicates if normal include files are present.  The parameter
<var class="var">sysroot</var> is the system root directory.  The parameter
<var class="var">iprefix</var> is the prefix for the gcc directory.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fOPTF"><span class="category-def">Macro: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_OPTF</strong> <code class="def-code-arguments">(char *<var class="var">path</var>)</code><a class="copiable-link" href="#index-TARGET_005fOPTF"> &para;</a></span></dt>
<dd><p>This target hook should register special include paths for the target.
The parameter <var class="var">path</var> is the include to register.  On Darwin
systems, this is used for Framework includes, which have semantics
that are different from <samp class="option">-I</samp>.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-bool"><span class="category-def">Macro: </span><span><strong class="def-name">bool</strong> <var class="def-var-arguments">TARGET_USE_LOCAL_THUNK_ALIAS_P (tree <var class="var">fndecl</var>)</var><a class="copiable-link" href="#index-bool"> &para;</a></span></dt>
<dd><p>This target macro returns <code class="code">true</code> if it is safe to use a local alias
for a virtual function <var class="var">fndecl</var> when constructing thunks,
<code class="code">false</code> otherwise.  By default, the macro returns <code class="code">true</code> for all
functions, if a target supports aliases (i.e. defines
<code class="code">ASM_OUTPUT_DEF</code>), <code class="code">false</code> otherwise,
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-TARGET_005fFORMAT_005fTYPES"><span class="category-def">Macro: </span><span><strong class="def-name">TARGET_FORMAT_TYPES</strong><a class="copiable-link" href="#index-TARGET_005fFORMAT_005fTYPES"> &para;</a></span></dt>
<dd><p>If defined, this macro is the name of a global variable containing
target-specific format checking information for the <samp class="option">-Wformat</samp>
option.  The default is to have no target-specific format checks.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-TARGET_005fN_005fFORMAT_005fTYPES"><span class="category-def">Macro: </span><span><strong class="def-name">TARGET_N_FORMAT_TYPES</strong><a class="copiable-link" href="#index-TARGET_005fN_005fFORMAT_005fTYPES"> &para;</a></span></dt>
<dd><p>If defined, this macro is the number of entries in
<code class="code">TARGET_FORMAT_TYPES</code>.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-TARGET_005fOVERRIDES_005fFORMAT_005fATTRIBUTES"><span class="category-def">Macro: </span><span><strong class="def-name">TARGET_OVERRIDES_FORMAT_ATTRIBUTES</strong><a class="copiable-link" href="#index-TARGET_005fOVERRIDES_005fFORMAT_005fATTRIBUTES"> &para;</a></span></dt>
<dd><p>If defined, this macro is the name of a global variable containing
target-specific format overrides for the <samp class="option">-Wformat</samp> option. The
default is to have no target-specific format overrides. If defined,
<code class="code">TARGET_FORMAT_TYPES</code> and <code class="code">TARGET_OVERRIDES_FORMAT_ATTRIBUTES_COUNT</code>
must be defined, too.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-TARGET_005fOVERRIDES_005fFORMAT_005fATTRIBUTES_005fCOUNT"><span class="category-def">Macro: </span><span><strong class="def-name">TARGET_OVERRIDES_FORMAT_ATTRIBUTES_COUNT</strong><a class="copiable-link" href="#index-TARGET_005fOVERRIDES_005fFORMAT_005fATTRIBUTES_005fCOUNT"> &para;</a></span></dt>
<dd><p>If defined, this macro specifies the number of entries in
<code class="code">TARGET_OVERRIDES_FORMAT_ATTRIBUTES</code>.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-TARGET_005fOVERRIDES_005fFORMAT_005fINIT"><span class="category-def">Macro: </span><span><strong class="def-name">TARGET_OVERRIDES_FORMAT_INIT</strong><a class="copiable-link" href="#index-TARGET_005fOVERRIDES_005fFORMAT_005fINIT"> &para;</a></span></dt>
<dd><p>If defined, this macro specifies the optional initialization
routine for target specific customizations of the system printf
and scanf formatter settings.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fINVALID_005fARG_005fFOR_005fUNPROTOTYPED_005fFN"><span class="category-def">Target Hook: </span><span><code class="def-type">const char *</code> <strong class="def-name">TARGET_INVALID_ARG_FOR_UNPROTOTYPED_FN</strong> <code class="def-code-arguments">(const_tree <var class="var">typelist</var>, const_tree <var class="var">funcdecl</var>, const_tree <var class="var">val</var>)</code><a class="copiable-link" href="#index-TARGET_005fINVALID_005fARG_005fFOR_005fUNPROTOTYPED_005fFN"> &para;</a></span></dt>
<dd><p>If defined, this macro returns the diagnostic message when it is
illegal to pass argument <var class="var">val</var> to function <var class="var">funcdecl</var>
with prototype <var class="var">typelist</var>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fINVALID_005fCONVERSION"><span class="category-def">Target Hook: </span><span><code class="def-type">const char *</code> <strong class="def-name">TARGET_INVALID_CONVERSION</strong> <code class="def-code-arguments">(const_tree <var class="var">fromtype</var>, const_tree <var class="var">totype</var>)</code><a class="copiable-link" href="#index-TARGET_005fINVALID_005fCONVERSION"> &para;</a></span></dt>
<dd><p>If defined, this macro returns the diagnostic message when it is
invalid to convert from <var class="var">fromtype</var> to <var class="var">totype</var>, or <code class="code">NULL</code>
if validity should be determined by the front end.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fINVALID_005fUNARY_005fOP"><span class="category-def">Target Hook: </span><span><code class="def-type">const char *</code> <strong class="def-name">TARGET_INVALID_UNARY_OP</strong> <code class="def-code-arguments">(int <var class="var">op</var>, const_tree <var class="var">type</var>)</code><a class="copiable-link" href="#index-TARGET_005fINVALID_005fUNARY_005fOP"> &para;</a></span></dt>
<dd><p>If defined, this macro returns the diagnostic message when it is
invalid to apply operation <var class="var">op</var> (where unary plus is denoted by
<code class="code">CONVERT_EXPR</code>) to an operand of type <var class="var">type</var>, or <code class="code">NULL</code>
if validity should be determined by the front end.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fINVALID_005fBINARY_005fOP"><span class="category-def">Target Hook: </span><span><code class="def-type">const char *</code> <strong class="def-name">TARGET_INVALID_BINARY_OP</strong> <code class="def-code-arguments">(int <var class="var">op</var>, const_tree <var class="var">type1</var>, const_tree <var class="var">type2</var>)</code><a class="copiable-link" href="#index-TARGET_005fINVALID_005fBINARY_005fOP"> &para;</a></span></dt>
<dd><p>If defined, this macro returns the diagnostic message when it is
invalid to apply operation <var class="var">op</var> to operands of types <var class="var">type1</var>
and <var class="var">type2</var>, or <code class="code">NULL</code> if validity should be determined by
the front end.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fPROMOTED_005fTYPE"><span class="category-def">Target Hook: </span><span><code class="def-type">tree</code> <strong class="def-name">TARGET_PROMOTED_TYPE</strong> <code class="def-code-arguments">(const_tree <var class="var">type</var>)</code><a class="copiable-link" href="#index-TARGET_005fPROMOTED_005fTYPE"> &para;</a></span></dt>
<dd><p>If defined, this target hook returns the type to which values of
<var class="var">type</var> should be promoted when they appear in expressions,
analogous to the integer promotions, or <code class="code">NULL_TREE</code> to use the
front end&rsquo;s normal promotion rules.  This hook is useful when there are
target-specific types with special promotion rules.
This is currently used only by the C and C++ front ends.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fCONVERT_005fTO_005fTYPE"><span class="category-def">Target Hook: </span><span><code class="def-type">tree</code> <strong class="def-name">TARGET_CONVERT_TO_TYPE</strong> <code class="def-code-arguments">(tree <var class="var">type</var>, tree <var class="var">expr</var>)</code><a class="copiable-link" href="#index-TARGET_005fCONVERT_005fTO_005fTYPE"> &para;</a></span></dt>
<dd><p>If defined, this hook returns the result of converting <var class="var">expr</var> to
<var class="var">type</var>.  It should return the converted expression,
or <code class="code">NULL_TREE</code> to apply the front end&rsquo;s normal conversion rules.
This hook is useful when there are target-specific types with special
conversion rules.
This is currently used only by the C and C++ front ends.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fVERIFY_005fTYPE_005fCONTEXT"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_VERIFY_TYPE_CONTEXT</strong> <code class="def-code-arguments">(location_t <var class="var">loc</var>, type_context_kind <var class="var">context</var>, const_tree <var class="var">type</var>, bool <var class="var">silent_p</var>)</code><a class="copiable-link" href="#index-TARGET_005fVERIFY_005fTYPE_005fCONTEXT"> &para;</a></span></dt>
<dd><p>If defined, this hook returns false if there is a target-specific reason
why type <var class="var">type</var> cannot be used in the source language context described
by <var class="var">context</var>.  When <var class="var">silent_p</var> is false, the hook also reports an
error against <var class="var">loc</var> for invalid uses of <var class="var">type</var>.
</p>
<p>Calls to this hook should be made through the global function
<code class="code">verify_type_context</code>, which makes the <var class="var">silent_p</var> parameter
default to false and also handles <code class="code">error_mark_node</code>.
</p>
<p>The default implementation always returns true.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-OBJC_005fJBLEN"><span class="category-def">Macro: </span><span><strong class="def-name">OBJC_JBLEN</strong><a class="copiable-link" href="#index-OBJC_005fJBLEN"> &para;</a></span></dt>
<dd><p>This macro determines the size of the objective C jump buffer for the
NeXT runtime. By default, OBJC_JBLEN is defined to an innocuous value.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-LIBGCC2_005fUNWIND_005fATTRIBUTE"><span class="category-def">Macro: </span><span><strong class="def-name">LIBGCC2_UNWIND_ATTRIBUTE</strong><a class="copiable-link" href="#index-LIBGCC2_005fUNWIND_005fATTRIBUTE"> &para;</a></span></dt>
<dd><p>Define this macro if any target-specific attributes need to be attached
to the functions in <samp class="file">libgcc</samp> that provide low-level support for
call stack unwinding.  It is used in declarations in <samp class="file">unwind-generic.h</samp>
and the associated definitions of those functions.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fUPDATE_005fSTACK_005fBOUNDARY"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_UPDATE_STACK_BOUNDARY</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fUPDATE_005fSTACK_005fBOUNDARY"> &para;</a></span></dt>
<dd><p>Define this macro to update the current function stack boundary if
necessary.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fGET_005fDRAP_005fRTX"><span class="category-def">Target Hook: </span><span><code class="def-type">rtx</code> <strong class="def-name">TARGET_GET_DRAP_RTX</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fGET_005fDRAP_005fRTX"> &para;</a></span></dt>
<dd><p>This hook should return an rtx for Dynamic Realign Argument Pointer (DRAP) if a
different argument pointer register is needed to access the function&rsquo;s
argument list due to stack realignment.  Return <code class="code">NULL</code> if no DRAP
is needed.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fZERO_005fCALL_005fUSED_005fREGS"><span class="category-def">Target Hook: </span><span><code class="def-type">HARD_REG_SET</code> <strong class="def-name">TARGET_ZERO_CALL_USED_REGS</strong> <code class="def-code-arguments">(HARD_REG_SET <var class="var">selected_regs</var>)</code><a class="copiable-link" href="#index-TARGET_005fZERO_005fCALL_005fUSED_005fREGS"> &para;</a></span></dt>
<dd><p>This target hook emits instructions to zero the subset of <var class="var">selected_regs</var>
that could conceivably contain values that are useful to an attacker.
Return the set of registers that were actually cleared.
</p>
<p>For most targets, the returned set of registers is a subset of
<var class="var">selected_regs</var>, however, for some of the targets (for example MIPS),
clearing some registers that are in the <var class="var">selected_regs</var> requires
clearing other call used registers that are not in the <var class="var">selected_regs</var>,
under such situation, the returned set of registers must be a subset of all
call used registers.
</p>
<p>The default implementation uses normal move instructions to zero
all the registers in <var class="var">selected_regs</var>.  Define this hook if the
target has more efficient ways of zeroing certain registers,
or if you believe that certain registers would never contain
values that are useful to an attacker.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fALLOCATE_005fSTACK_005fSLOTS_005fFOR_005fARGS"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_ALLOCATE_STACK_SLOTS_FOR_ARGS</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fALLOCATE_005fSTACK_005fSLOTS_005fFOR_005fARGS"> &para;</a></span></dt>
<dd><p>When optimization is disabled, this hook indicates whether or not
arguments should be allocated to stack slots.  Normally, GCC allocates
stacks slots for arguments when not optimizing in order to make
debugging easier.  However, when a function is declared with
<code class="code">__attribute__((naked))</code>, there is no stack frame, and the compiler
cannot safely move arguments from the registers in which they are passed
to the stack.  Therefore, this hook should return true in general, but
false for naked functions.  The default implementation always returns true.
</p></dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-TARGET_005fCONST_005fANCHOR"><span class="category-def">Target Hook: </span><span><code class="def-type">unsigned HOST_WIDE_INT</code> <strong class="def-name">TARGET_CONST_ANCHOR</strong><a class="copiable-link" href="#index-TARGET_005fCONST_005fANCHOR"> &para;</a></span></dt>
<dd><p>On some architectures it can take multiple instructions to synthesize
a constant.  If there is another constant already in a register that
is close enough in value then it is preferable that the new constant
is computed from this register using immediate addition or
subtraction.  We accomplish this through CSE.  Besides the value of
the constant we also add a lower and an upper constant anchor to the
available expressions.  These are then queried when encountering new
constants.  The anchors are computed by rounding the constant up and
down to a multiple of the value of <code class="code">TARGET_CONST_ANCHOR</code>.
<code class="code">TARGET_CONST_ANCHOR</code> should be the maximum positive value
accepted by immediate-add plus one.  We currently assume that the
value of <code class="code">TARGET_CONST_ANCHOR</code> is a power of 2.  For example, on
MIPS, where add-immediate takes a 16-bit signed value,
<code class="code">TARGET_CONST_ANCHOR</code> is set to &lsquo;<samp class="samp">0x8000</samp>&rsquo;.  The default value
is zero, which disables this optimization.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fASAN_005fSHADOW_005fOFFSET"><span class="category-def">Target Hook: </span><span><code class="def-type">unsigned HOST_WIDE_INT</code> <strong class="def-name">TARGET_ASAN_SHADOW_OFFSET</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fASAN_005fSHADOW_005fOFFSET"> &para;</a></span></dt>
<dd><p>Return the offset bitwise ored into shifted address to get corresponding
Address Sanitizer shadow memory address.  NULL if Address Sanitizer is not
supported by the target.  May return 0 if Address Sanitizer is not supported
or using dynamic shadow offset by a subtarget.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fASAN_005fDYNAMIC_005fSHADOW_005fOFFSET_005fP"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_ASAN_DYNAMIC_SHADOW_OFFSET_P</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fASAN_005fDYNAMIC_005fSHADOW_005fOFFSET_005fP"> &para;</a></span></dt>
<dd><p>Return true if asan should use dynamic shadow offset.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fMEMMODEL_005fCHECK"><span class="category-def">Target Hook: </span><span><code class="def-type">unsigned HOST_WIDE_INT</code> <strong class="def-name">TARGET_MEMMODEL_CHECK</strong> <code class="def-code-arguments">(unsigned HOST_WIDE_INT <var class="var">val</var>)</code><a class="copiable-link" href="#index-TARGET_005fMEMMODEL_005fCHECK"> &para;</a></span></dt>
<dd><p>Validate target specific memory model mask bits. When NULL no target specific
memory model bits are allowed.
</p></dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-TARGET_005fATOMIC_005fTEST_005fAND_005fSET_005fTRUEVAL"><span class="category-def">Target Hook: </span><span><code class="def-type">unsigned char</code> <strong class="def-name">TARGET_ATOMIC_TEST_AND_SET_TRUEVAL</strong><a class="copiable-link" href="#index-TARGET_005fATOMIC_005fTEST_005fAND_005fSET_005fTRUEVAL"> &para;</a></span></dt>
<dd><p>This value should be set if the result written by
<code class="code">atomic_test_and_set</code> is not exactly 1, i.e. the
<code class="code">bool</code> <code class="code">true</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fHAS_005fIFUNC_005fP"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_HAS_IFUNC_P</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fHAS_005fIFUNC_005fP"> &para;</a></span></dt>
<dd><p>It returns true if the target supports GNU indirect functions.
The support includes the assembler, linker and dynamic linker.
The default value of this hook is based on target&rsquo;s libc.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fIFUNC_005fREF_005fLOCAL_005fOK"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_IFUNC_REF_LOCAL_OK</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fIFUNC_005fREF_005fLOCAL_005fOK"> &para;</a></span></dt>
<dd><p>Return true if it is OK to reference indirect function resolvers
locally.  The default is to return false.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fATOMIC_005fALIGN_005fFOR_005fMODE"><span class="category-def">Target Hook: </span><span><code class="def-type">unsigned int</code> <strong class="def-name">TARGET_ATOMIC_ALIGN_FOR_MODE</strong> <code class="def-code-arguments">(machine_mode <var class="var">mode</var>)</code><a class="copiable-link" href="#index-TARGET_005fATOMIC_005fALIGN_005fFOR_005fMODE"> &para;</a></span></dt>
<dd><p>If defined, this function returns an appropriate alignment in bits for an
atomic object of machine_mode <var class="var">mode</var>.  If 0 is returned then the
default alignment for the specified mode is used.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fATOMIC_005fASSIGN_005fEXPAND_005fFENV"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_ATOMIC_ASSIGN_EXPAND_FENV</strong> <code class="def-code-arguments">(tree *<var class="var">hold</var>, tree *<var class="var">clear</var>, tree *<var class="var">update</var>)</code><a class="copiable-link" href="#index-TARGET_005fATOMIC_005fASSIGN_005fEXPAND_005fFENV"> &para;</a></span></dt>
<dd><p>ISO C11 requires atomic compound assignments that may raise floating-point
exceptions to raise exceptions corresponding to the arithmetic operation
whose result was successfully stored in a compare-and-exchange sequence.
This requires code equivalent to calls to <code class="code">feholdexcept</code>,
<code class="code">feclearexcept</code> and <code class="code">feupdateenv</code> to be generated at
appropriate points in the compare-and-exchange sequence.  This hook should
set <code class="code">*<var class="var">hold</var></code> to an expression equivalent to the call to
<code class="code">feholdexcept</code>, <code class="code">*<var class="var">clear</var></code> to an expression equivalent to
the call to <code class="code">feclearexcept</code> and <code class="code">*<var class="var">update</var></code> to an expression
equivalent to the call to <code class="code">feupdateenv</code>.  The three expressions are
<code class="code">NULL_TREE</code> on entry to the hook and may be left as <code class="code">NULL_TREE</code>
if no code is required in a particular place.  The default implementation
leaves all three expressions as <code class="code">NULL_TREE</code>.  The
<code class="code">__atomic_feraiseexcept</code> function from <code class="code">libatomic</code> may be of use
as part of the code generated in <code class="code">*<var class="var">update</var></code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fRECORD_005fOFFLOAD_005fSYMBOL"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_RECORD_OFFLOAD_SYMBOL</strong> <code class="def-code-arguments">(tree)</code><a class="copiable-link" href="#index-TARGET_005fRECORD_005fOFFLOAD_005fSYMBOL"> &para;</a></span></dt>
<dd><p>Used when offloaded functions are seen in the compilation unit and no named
sections are available.  It is called once for each symbol that must be
recorded in the offload function and variable table.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fOFFLOAD_005fOPTIONS"><span class="category-def">Target Hook: </span><span><code class="def-type">char *</code> <strong class="def-name">TARGET_OFFLOAD_OPTIONS</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fOFFLOAD_005fOPTIONS"> &para;</a></span></dt>
<dd><p>Used when writing out the list of options into an LTO file.  It should
translate any relevant target-specific options (such as the ABI in use)
into one of the <samp class="option">-foffload</samp> options that exist as a common interface
to express such options.  It should return a string containing these options,
separated by spaces, which the caller will free.
</p>
</dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-TARGET_005fSUPPORTS_005fWIDE_005fINT"><span class="category-def">Macro: </span><span><strong class="def-name">TARGET_SUPPORTS_WIDE_INT</strong><a class="copiable-link" href="#index-TARGET_005fSUPPORTS_005fWIDE_005fINT"> &para;</a></span></dt>
<dd>
<p>On older ports, large integers are stored in <code class="code">CONST_DOUBLE</code> rtl
objects.  Newer ports define <code class="code">TARGET_SUPPORTS_WIDE_INT</code> to be nonzero
to indicate that large integers are stored in
<code class="code">CONST_WIDE_INT</code> rtl objects.  The <code class="code">CONST_WIDE_INT</code> allows
very large integer constants to be represented.  <code class="code">CONST_DOUBLE</code>
is limited to twice the size of the host&rsquo;s <code class="code">HOST_WIDE_INT</code>
representation.
</p>
<p>Converting a port mostly requires looking for the places where
<code class="code">CONST_DOUBLE</code>s are used with <code class="code">VOIDmode</code> and replacing that
code with code that accesses <code class="code">CONST_WIDE_INT</code>s.  &lsquo;<samp class="samp">&quot;grep -i
const_double&quot;</samp>&rsquo; at the port level gets you to 95% of the changes that
need to be made.  There are a few places that require a deeper look.
</p>
<ul class="itemize mark-bullet">
<li>There is no equivalent to <code class="code">hval</code> and <code class="code">lval</code> for
<code class="code">CONST_WIDE_INT</code>s.  This would be difficult to express in the md
language since there are a variable number of elements.

<p>Most ports only check that <code class="code">hval</code> is either 0 or -1 to see if the
value is small.  As mentioned above, this will no longer be necessary
since small constants are always <code class="code">CONST_INT</code>.  Of course there
are still a few exceptions, the alpha&rsquo;s constraint used by the zap
instruction certainly requires careful examination by C code.
However, all the current code does is pass the hval and lval to C
code, so evolving the c code to look at the <code class="code">CONST_WIDE_INT</code> is
not really a large change.
</p>
</li><li>Because there is no standard template that ports use to materialize
constants, there is likely to be some futzing that is unique to each
port in this code.

</li><li>The rtx costs may have to be adjusted to properly account for larger
constants that are represented as <code class="code">CONST_WIDE_INT</code>.
</li></ul>

<p>All and all it does not take long to convert ports that the
maintainer is familiar with.
</p>
</dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fHAVE_005fSPECULATION_005fSAFE_005fVALUE"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_HAVE_SPECULATION_SAFE_VALUE</strong> <code class="def-code-arguments">(bool <var class="var">active</var>)</code><a class="copiable-link" href="#index-TARGET_005fHAVE_005fSPECULATION_005fSAFE_005fVALUE"> &para;</a></span></dt>
<dd><p>This hook is used to determine the level of target support for
 <code class="code">__builtin_speculation_safe_value</code>.  If called with an argument
 of false, it returns true if the target has been modified to support
 this builtin.  If called with an argument of true, it returns true
 if the target requires active mitigation execution might be speculative.
</p> 
<p>The default implementation returns false if the target does not define
 a pattern named <code class="code">speculation_barrier</code>.  Else it returns true
 for the first case and whether the pattern is enabled for the current
 compilation for the second case.
</p> 
<p>For targets that have no processors that can execute instructions
 speculatively an alternative implemenation of this hook is available:
 simply redefine this hook to <code class="code">speculation_safe_value_not_needed</code>
 along with your other target hooks.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSPECULATION_005fSAFE_005fVALUE"><span class="category-def">Target Hook: </span><span><code class="def-type">rtx</code> <strong class="def-name">TARGET_SPECULATION_SAFE_VALUE</strong> <code class="def-code-arguments">(machine_mode <var class="var">mode</var>, rtx <var class="var">result</var>, rtx <var class="var">val</var>, rtx <var class="var">failval</var>)</code><a class="copiable-link" href="#index-TARGET_005fSPECULATION_005fSAFE_005fVALUE"> &para;</a></span></dt>
<dd><p>This target hook can be used to generate a target-specific code
 sequence that implements the <code class="code">__builtin_speculation_safe_value</code>
 built-in function.  The function must always return <var class="var">val</var> in
 <var class="var">result</var> in mode <var class="var">mode</var> when the cpu is not executing
 speculatively, but must never return that when speculating until it
 is known that the speculation will not be unwound.  The hook supports
 two primary mechanisms for implementing the requirements.  The first
 is to emit a speculation barrier which forces the processor to wait
 until all prior speculative operations have been resolved; the second
 is to use a target-specific mechanism that can track the speculation
 state and to return <var class="var">failval</var> if it can determine that
 speculation must be unwound at a later time.
</p> 
<p>The default implementation simply copies <var class="var">val</var> to <var class="var">result</var> and
 emits a <code class="code">speculation_barrier</code> instruction if that is defined.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fRUN_005fTARGET_005fSELFTESTS"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_RUN_TARGET_SELFTESTS</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fRUN_005fTARGET_005fSELFTESTS"> &para;</a></span></dt>
<dd><p>If selftests are enabled, run any selftests for this target.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fMEMTAG_005fCAN_005fTAG_005fADDRESSES"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_MEMTAG_CAN_TAG_ADDRESSES</strong> <code class="def-code-arguments">()</code><a class="copiable-link" href="#index-TARGET_005fMEMTAG_005fCAN_005fTAG_005fADDRESSES"> &para;</a></span></dt>
<dd><p>True if the backend architecture naturally supports ignoring some region
of pointers.  This feature means that <samp class="option">-fsanitize=hwaddress</samp> can
work.
</p>
<p>At preset, this feature does not support address spaces.  It also requires
<code class="code">Pmode</code> to be the same as <code class="code">ptr_mode</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fMEMTAG_005fTAG_005fSIZE"><span class="category-def">Target Hook: </span><span><code class="def-type">uint8_t</code> <strong class="def-name">TARGET_MEMTAG_TAG_SIZE</strong> <code class="def-code-arguments">()</code><a class="copiable-link" href="#index-TARGET_005fMEMTAG_005fTAG_005fSIZE"> &para;</a></span></dt>
<dd><p>Return the size of a tag (in bits) for this platform.
</p>
<p>The default returns 8.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fMEMTAG_005fGRANULE_005fSIZE"><span class="category-def">Target Hook: </span><span><code class="def-type">uint8_t</code> <strong class="def-name">TARGET_MEMTAG_GRANULE_SIZE</strong> <code class="def-code-arguments">()</code><a class="copiable-link" href="#index-TARGET_005fMEMTAG_005fGRANULE_005fSIZE"> &para;</a></span></dt>
<dd><p>Return the size in real memory that each byte in shadow memory refers to.
I.e. if a variable is <var class="var">X</var> bytes long in memory, then this hook should
return the value <var class="var">Y</var> such that the tag in shadow memory spans
<var class="var">X</var>/<var class="var">Y</var> bytes.
</p>
<p>Most variables will need to be aligned to this amount since two variables
that are neighbors in memory and share a tag granule would need to share
the same tag.
</p>
<p>The default returns 16.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fMEMTAG_005fINSERT_005fRANDOM_005fTAG"><span class="category-def">Target Hook: </span><span><code class="def-type">rtx</code> <strong class="def-name">TARGET_MEMTAG_INSERT_RANDOM_TAG</strong> <code class="def-code-arguments">(rtx <var class="var">untagged</var>, rtx <var class="var">target</var>)</code><a class="copiable-link" href="#index-TARGET_005fMEMTAG_005fINSERT_005fRANDOM_005fTAG"> &para;</a></span></dt>
<dd><p>Return an RTX representing the value of <var class="var">untagged</var> but with a
(possibly) random tag in it.
Put that value into <var class="var">target</var> if it is convenient to do so.
This function is used to generate a tagged base for the current stack frame.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fMEMTAG_005fADD_005fTAG"><span class="category-def">Target Hook: </span><span><code class="def-type">rtx</code> <strong class="def-name">TARGET_MEMTAG_ADD_TAG</strong> <code class="def-code-arguments">(rtx <var class="var">base</var>, poly_int64 <var class="var">addr_offset</var>, uint8_t <var class="var">tag_offset</var>)</code><a class="copiable-link" href="#index-TARGET_005fMEMTAG_005fADD_005fTAG"> &para;</a></span></dt>
<dd><p>Return an RTX that represents the result of adding <var class="var">addr_offset</var> to
the address in pointer <var class="var">base</var> and <var class="var">tag_offset</var> to the tag in pointer
<var class="var">base</var>.
The resulting RTX must either be a valid memory address or be able to get
put into an operand with <code class="code">force_operand</code>.
</p>
<p>Unlike other memtag hooks, this must return an expression and not emit any
RTL.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fMEMTAG_005fSET_005fTAG"><span class="category-def">Target Hook: </span><span><code class="def-type">rtx</code> <strong class="def-name">TARGET_MEMTAG_SET_TAG</strong> <code class="def-code-arguments">(rtx <var class="var">untagged_base</var>, rtx <var class="var">tag</var>, rtx <var class="var">target</var>)</code><a class="copiable-link" href="#index-TARGET_005fMEMTAG_005fSET_005fTAG"> &para;</a></span></dt>
<dd><p>Return an RTX representing <var class="var">untagged_base</var> but with the tag <var class="var">tag</var>.
Try and store this in <var class="var">target</var> if convenient.
<var class="var">untagged_base</var> is required to have a zero tag when this hook is called.
The default of this hook is to set the top byte of <var class="var">untagged_base</var> to
<var class="var">tag</var>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fMEMTAG_005fEXTRACT_005fTAG"><span class="category-def">Target Hook: </span><span><code class="def-type">rtx</code> <strong class="def-name">TARGET_MEMTAG_EXTRACT_TAG</strong> <code class="def-code-arguments">(rtx <var class="var">tagged_pointer</var>, rtx <var class="var">target</var>)</code><a class="copiable-link" href="#index-TARGET_005fMEMTAG_005fEXTRACT_005fTAG"> &para;</a></span></dt>
<dd><p>Return an RTX representing the tag stored in <var class="var">tagged_pointer</var>.
Store the result in <var class="var">target</var> if it is convenient.
The default represents the top byte of the original pointer.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fMEMTAG_005fUNTAGGED_005fPOINTER"><span class="category-def">Target Hook: </span><span><code class="def-type">rtx</code> <strong class="def-name">TARGET_MEMTAG_UNTAGGED_POINTER</strong> <code class="def-code-arguments">(rtx <var class="var">tagged_pointer</var>, rtx <var class="var">target</var>)</code><a class="copiable-link" href="#index-TARGET_005fMEMTAG_005fUNTAGGED_005fPOINTER"> &para;</a></span></dt>
<dd><p>Return an RTX representing <var class="var">tagged_pointer</var> with its tag set to zero.
Store the result in <var class="var">target</var> if convenient.
The default clears the top byte of the original pointer.
</p></dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-TARGET_005fHAVE_005fSHADOW_005fCALL_005fSTACK"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_HAVE_SHADOW_CALL_STACK</strong><a class="copiable-link" href="#index-TARGET_005fHAVE_005fSHADOW_005fCALL_005fSTACK"> &para;</a></span></dt>
<dd><p>This value is true if the target platform supports
<samp class="option">-fsanitize=shadow-call-stack</samp>.  The default value is false.
</p></dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-TARGET_005fHAVE_005fLIBATOMIC"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_HAVE_LIBATOMIC</strong><a class="copiable-link" href="#index-TARGET_005fHAVE_005fLIBATOMIC"> &para;</a></span></dt>
<dd><p>This value is true if the target platform supports
libatomic.  The default value is false.
</p></dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-TARGET_005fDOCUMENTATION_005fNAME"><span class="category-def">Target Hook: </span><span><code class="def-type">const char *</code> <strong class="def-name">TARGET_DOCUMENTATION_NAME</strong><a class="copiable-link" href="#index-TARGET_005fDOCUMENTATION_005fNAME"> &para;</a></span></dt>
<dd><p>If non-NULL, this value is a string used for locating target-specific documentation for this target.
The default value is NULL.
</p></dd></dl>

</div>
<hr>
<div class="nav-panel">
<p>
Previous: <a href="Named-Address-Spaces.html">Adding support for named address spaces</a>, Up: <a href="Target-Macros.html">Target Description Macros and Functions</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Option-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>

<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- Copyright Â© 1988-2025 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Funding Free Software", the Front-Cover
Texts being (a) (see below), and with the Back-Cover Texts being (b)
(see below).  A copy of the license is included in the section entitled
"GNU Free Documentation License".

(a) The FSF's Front-Cover Text is:

A GNU Manual

(b) The FSF's Back-Cover Text is:

You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development. -->
<title>Standard Names (GNU Compiler Collection (GCC) Internals)</title>

<meta name="description" content="Standard Names (GNU Compiler Collection (GCC) Internals)">
<meta name="keywords" content="Standard Names (GNU Compiler Collection (GCC) Internals)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Option-Index.html" rel="index" title="Option Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Machine-Desc.html" rel="up" title="Machine Desc">
<link href="Pattern-Ordering.html" rel="next" title="Pattern Ordering">
<link href="Constraints.html" rel="prev" title="Constraints">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
ul.mark-bullet {list-style-type: disc}
-->
</style>


</head>

<body lang="en">
<div class="section-level-extent" id="Standard-Names">
<div class="nav-panel">
<p>
Next: <a href="Pattern-Ordering.html" accesskey="n" rel="next">When the Order of Patterns Matters</a>, Previous: <a href="Constraints.html" accesskey="p" rel="prev">Operand Constraints</a>, Up: <a href="Machine-Desc.html" accesskey="u" rel="up">Machine Descriptions</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Option-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="Standard-Pattern-Names-For-Generation"><span>16.10 Standard Pattern Names For Generation<a class="copiable-link" href="#Standard-Pattern-Names-For-Generation"> &para;</a></span></h3>
<a class="index-entry-id" id="index-standard-pattern-names"></a>
<a class="index-entry-id" id="index-pattern-names"></a>
<a class="index-entry-id" id="index-names_002c-pattern"></a>

<p>Here is a table of the instruction names that are meaningful in the RTL
generation pass of the compiler.  Giving one of these names to an
instruction pattern tells the RTL generation pass that it can use the
pattern to accomplish a certain task.
</p>
<dl class="table">
<dt><a id="index-movm-instruction-pattern"></a><span>&lsquo;<samp class="samp">mov<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-movm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Here <var class="var">m</var> stands for a two-letter machine mode name, in lowercase.
This instruction pattern moves data with that machine mode from operand
1 to operand 0.  For example, &lsquo;<samp class="samp">movsi</samp>&rsquo; moves full-word data.
</p>
<p>If operand 0 is a <code class="code">subreg</code> with mode <var class="var">m</var> of a register whose
own mode is wider than <var class="var">m</var>, the effect of this instruction is
to store the specified value in the part of the register that corresponds
to mode <var class="var">m</var>.  Bits outside of <var class="var">m</var>, but which are within the
same target word as the <code class="code">subreg</code> are undefined.  Bits which are
outside the target word are left unchanged.
</p>
<p>This class of patterns is special in several ways.  First of all, each
of these names up to and including full word size <em class="emph">must</em> be defined,
because there is no other way to copy a datum from one place to another.
If there are patterns accepting operands in larger modes,
&lsquo;<samp class="samp">mov<var class="var">m</var></samp>&rsquo; must be defined for integer modes of those sizes.
</p>
<p>Second, these patterns are not used solely in the RTL generation pass.
Even the reload pass can generate move insns to copy values from stack
slots into temporary registers.  When it does so, one of the operands is
a hard register and the other is an operand that can need to be reloaded
into a register.
</p>
<a class="index-entry-id" id="index-force_005freg"></a>
<p>Therefore, when given such a pair of operands, the pattern must generate
RTL which needs no reloading and needs no temporary registers&mdash;no
registers other than the operands.  For example, if you support the
pattern with a <code class="code">define_expand</code>, then in such a case the
<code class="code">define_expand</code> mustn&rsquo;t call <code class="code">force_reg</code> or any other such
function which might generate new pseudo registers.
</p>
<p>This requirement exists even for subword modes on a RISC machine where
fetching those modes from memory normally requires several insns and
some temporary registers.
</p>
<a class="index-entry-id" id="index-change_005faddress"></a>
<p>During reload a memory reference with an invalid address may be passed
as an operand.  Such an address will be replaced with a valid address
later in the reload pass.  In this case, nothing may be done with the
address except to use it as it stands.  If it is copied, it will not be
replaced with a valid address.  No attempt should be made to make such
an address into a valid address and no routine (such as
<code class="code">change_address</code>) that will do so may be called.  Note that
<code class="code">general_operand</code> will fail when applied to such an address.
</p>
<a class="index-entry-id" id="index-reload_005fin_005fprogress"></a>
<p>The global variable <code class="code">reload_in_progress</code> (which must be explicitly
declared if required) can be used to determine whether such special
handling is required.
</p>
<p>The variety of operands that have reloads depends on the rest of the
machine description, but typically on a RISC machine these can only be
pseudo registers that did not get hard registers, while on other
machines explicit memory references will get optional reloads.
</p>
<p>If a scratch register is required to move an object to or from memory,
it can be allocated using <code class="code">gen_reg_rtx</code> prior to life analysis.
</p>
<p>If there are cases which need scratch registers during or after reload,
you must provide an appropriate secondary_reload target hook.
</p>
<a class="index-entry-id" id="index-can_005fcreate_005fpseudo_005fp"></a>
<p>The macro <code class="code">can_create_pseudo_p</code> can be used to determine if it
is unsafe to create new pseudo registers.  If this variable is nonzero, then
it is unsafe to call <code class="code">gen_reg_rtx</code> to allocate a new pseudo.
</p>
<p>The constraints on a &lsquo;<samp class="samp">mov<var class="var">m</var></samp>&rsquo; must permit moving any hard
register to any other hard register provided that
<code class="code">TARGET_HARD_REGNO_MODE_OK</code> permits mode <var class="var">m</var> in both registers and
<code class="code">TARGET_REGISTER_MOVE_COST</code> applied to their classes returns a value
of 2.
</p>
<p>It is obligatory to support floating point &lsquo;<samp class="samp">mov<var class="var">m</var></samp>&rsquo;
instructions into and out of any registers that can hold fixed point
values, because unions and structures (which have modes <code class="code">SImode</code> or
<code class="code">DImode</code>) can be in those registers and they may have floating
point members.
</p>
<p>There may also be a need to support fixed point &lsquo;<samp class="samp">mov<var class="var">m</var></samp>&rsquo;
instructions in and out of floating point registers.  Unfortunately, I
have forgotten why this was so, and I don&rsquo;t know whether it is still
true.  If <code class="code">TARGET_HARD_REGNO_MODE_OK</code> rejects fixed point values in
floating point registers, then the constraints of the fixed point
&lsquo;<samp class="samp">mov<var class="var">m</var></samp>&rsquo; instructions must be designed to avoid ever trying to
reload into a floating point register.
</p>
</dd>
<dt><a class="index-entry-id" id="index-reload_005fout-instruction-pattern"></a>
<a id="index-reload_005fin-instruction-pattern"></a><span>&lsquo;<samp class="samp">reload_in<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-reload_005fin-instruction-pattern"> &para;</a></span></dt>
<dt>&lsquo;<samp class="samp">reload_out<var class="var">m</var></samp>&rsquo;</dt>
<dd><p>These named patterns have been obsoleted by the target hook
<code class="code">secondary_reload</code>.
</p>
<p>Like &lsquo;<samp class="samp">mov<var class="var">m</var></samp>&rsquo;, but used when a scratch register is required to
move between operand 0 and operand 1.  Operand 2 describes the scratch
register.  See the discussion of the <code class="code">SECONDARY_RELOAD_CLASS</code>
macro in see <a class="pxref" href="Register-Classes.html">Register Classes</a>.
</p>
<p>There are special restrictions on the form of the <code class="code">match_operand</code>s
used in these patterns.  First, only the predicate for the reload
operand is examined, i.e., <code class="code">reload_in</code> examines operand 1, but not
the predicates for operand 0 or 2.  Second, there may be only one
alternative in the constraints.  Third, only a single register class
letter may be used for the constraint; subsequent constraint letters
are ignored.  As a special exception, an empty constraint string
matches the <code class="code">ALL_REGS</code> register class.  This may relieve ports
of the burden of defining an <code class="code">ALL_REGS</code> constraint letter just
for these patterns.
</p>
</dd>
<dt><a id="index-movstrictm-instruction-pattern"></a><span>&lsquo;<samp class="samp">movstrict<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-movstrictm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Like &lsquo;<samp class="samp">mov<var class="var">m</var></samp>&rsquo; except that if operand 0 is a <code class="code">subreg</code>
with mode <var class="var">m</var> of a register whose natural mode is wider,
the &lsquo;<samp class="samp">movstrict<var class="var">m</var></samp>&rsquo; instruction is guaranteed not to alter
any of the register except the part which belongs to mode <var class="var">m</var>.
</p>
</dd>
<dt><a id="index-movmisalignm-instruction-pattern"></a><span>&lsquo;<samp class="samp">movmisalign<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-movmisalignm-instruction-pattern"> &para;</a></span></dt>
<dd><p>This variant of a move pattern is designed to load or store a value
from a memory address that is not naturally aligned for its mode.
For a store, the memory will be in operand 0; for a load, the memory
will be in operand 1.  The other operand is guaranteed not to be a
memory, so that it&rsquo;s easy to tell whether this is a load or store.
</p>
<p>This pattern is used by the autovectorizer, and when expanding a
<code class="code">MISALIGNED_INDIRECT_REF</code> expression.
</p>
</dd>
<dt><a id="index-load_005fmultiple-instruction-pattern"></a><span>&lsquo;<samp class="samp">load_multiple</samp>&rsquo;<a class="copiable-link" href="#index-load_005fmultiple-instruction-pattern"> &para;</a></span></dt>
<dd><p>Load several consecutive memory locations into consecutive registers.
Operand 0 is the first of the consecutive registers, operand 1
is the first memory location, and operand 2 is a constant: the
number of consecutive registers.
</p>
<p>Define this only if the target machine really has such an instruction;
do not define this if the most efficient way of loading consecutive
registers from memory is to do them one at a time.
</p>
<p>On some machines, there are restrictions as to which consecutive
registers can be stored into memory, such as particular starting or
ending register numbers or only a range of valid counts.  For those
machines, use a <code class="code">define_expand</code> (see <a class="pxref" href="Expander-Definitions.html">Defining RTL Sequences for Code Generation</a>)
and make the pattern fail if the restrictions are not met.
</p>
<p>Write the generated insn as a <code class="code">parallel</code> with elements being a
<code class="code">set</code> of one register from the appropriate memory location (you may
also need <code class="code">use</code> or <code class="code">clobber</code> elements).  Use a
<code class="code">match_parallel</code> (see <a class="pxref" href="RTL-Template.html">RTL Template</a>) to recognize the insn.  See
<samp class="file">rs6000.md</samp> for examples of the use of this insn pattern.
</p>
</dd>
<dt><a id="index-store_005fmultiple-instruction-pattern"></a><span>&lsquo;<samp class="samp">store_multiple</samp>&rsquo;<a class="copiable-link" href="#index-store_005fmultiple-instruction-pattern"> &para;</a></span></dt>
<dd><p>Similar to &lsquo;<samp class="samp">load_multiple</samp>&rsquo;, but store several consecutive registers
into consecutive memory locations.  Operand 0 is the first of the
consecutive memory locations, operand 1 is the first register, and
operand 2 is a constant: the number of consecutive registers.
</p>
</dd>
<dt><a id="index-vec_005fload_005flanesmn-instruction-pattern"></a><span>&lsquo;<samp class="samp">vec_load_lanes<var class="var">m</var><var class="var">n</var></samp>&rsquo;<a class="copiable-link" href="#index-vec_005fload_005flanesmn-instruction-pattern"> &para;</a></span></dt>
<dd><p>Perform an interleaved load of several vectors from memory operand 1
into register operand 0.  Both operands have mode <var class="var">m</var>.  The register
operand is viewed as holding consecutive vectors of mode <var class="var">n</var>,
while the memory operand is a flat array that contains the same number
of elements.  The operation is equivalent to:
</p>
<div class="example smallexample">
<pre class="example-preformatted">int c = GET_MODE_SIZE (<var class="var">m</var>) / GET_MODE_SIZE (<var class="var">n</var>);
for (j = 0; j &lt; GET_MODE_NUNITS (<var class="var">n</var>); j++)
  for (i = 0; i &lt; c; i++)
    operand0[i][j] = operand1[j * c + i];
</pre></div>

<p>For example, &lsquo;<samp class="samp">vec_load_lanestiv4hi</samp>&rsquo; loads 8 16-bit values
from memory into a register of mode &lsquo;<samp class="samp">TI</samp>&rsquo;.  The register
contains two consecutive vectors of mode &lsquo;<samp class="samp">V4HI</samp>&rsquo;.
</p>
<p>This pattern can only be used if:
</p><div class="example smallexample">
<pre class="example-preformatted">TARGET_ARRAY_MODE_SUPPORTED_P (<var class="var">n</var>, <var class="var">c</var>)
</pre></div>
<p>is true.  GCC assumes that, if a target supports this kind of
instruction for some mode <var class="var">n</var>, it also supports unaligned
loads for vectors of mode <var class="var">n</var>.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-vec_005fmask_005fload_005flanesmn-instruction-pattern"></a><span>&lsquo;<samp class="samp">vec_mask_load_lanes<var class="var">m</var><var class="var">n</var></samp>&rsquo;<a class="copiable-link" href="#index-vec_005fmask_005fload_005flanesmn-instruction-pattern"> &para;</a></span></dt>
<dd><p>Like &lsquo;<samp class="samp">vec_load_lanes<var class="var">m</var><var class="var">n</var></samp>&rsquo;, but takes an additional
mask operand (operand 2) that specifies which elements of the destination
vectors should be loaded.  Other elements of the destination vectors are
taken from operand 3, which is an else operand similar to the one in
<code class="code">maskload</code>.
The operation is equivalent to:
</p>
<div class="example smallexample">
<pre class="example-preformatted">int c = GET_MODE_SIZE (<var class="var">m</var>) / GET_MODE_SIZE (<var class="var">n</var>);
for (j = 0; j &lt; GET_MODE_NUNITS (<var class="var">n</var>); j++)
  if (operand2[j])
    for (i = 0; i &lt; c; i++)
      operand0[i][j] = operand1[j * c + i];
  else
    for (i = 0; i &lt; c; i++)
      operand0[i][j] = operand3[j];
</pre></div>

<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-vec_005fmask_005flen_005fload_005flanesmn-instruction-pattern"></a><span>&lsquo;<samp class="samp">vec_mask_len_load_lanes<var class="var">m</var><var class="var">n</var></samp>&rsquo;<a class="copiable-link" href="#index-vec_005fmask_005flen_005fload_005flanesmn-instruction-pattern"> &para;</a></span></dt>
<dd><p>Like &lsquo;<samp class="samp">vec_load_lanes<var class="var">m</var><var class="var">n</var></samp>&rsquo;, but takes an additional
mask operand (operand 2), length operand (operand 4) as well as bias operand
(operand 5) that specifies which elements of the destination vectors should be
loaded.  Other elements of the destination vectors are taken from operand 3,
which is an else operand similar to the one in <code class="code">maskload</code>.
The operation is equivalent to:
</p>
<div class="example smallexample">
<pre class="example-preformatted">int c = GET_MODE_SIZE (<var class="var">m</var>) / GET_MODE_SIZE (<var class="var">n</var>);
for (j = 0; j &lt; operand4 + operand5; j++)
  for (i = 0; i &lt; c; i++)
    if (operand2[j])
      operand0[i][j] = operand1[j * c + i];
    else
      operand0[i][j] = operand3[j];
</pre></div>

<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-vec_005fstore_005flanesmn-instruction-pattern"></a><span>&lsquo;<samp class="samp">vec_store_lanes<var class="var">m</var><var class="var">n</var></samp>&rsquo;<a class="copiable-link" href="#index-vec_005fstore_005flanesmn-instruction-pattern"> &para;</a></span></dt>
<dd><p>Equivalent to &lsquo;<samp class="samp">vec_load_lanes<var class="var">m</var><var class="var">n</var></samp>&rsquo;, with the memory
and register operands reversed.  That is, the instruction is
equivalent to:
</p>
<div class="example smallexample">
<pre class="example-preformatted">int c = GET_MODE_SIZE (<var class="var">m</var>) / GET_MODE_SIZE (<var class="var">n</var>);
for (j = 0; j &lt; GET_MODE_NUNITS (<var class="var">n</var>); j++)
  for (i = 0; i &lt; c; i++)
    operand0[j * c + i] = operand1[i][j];
</pre></div>

<p>for a memory operand 0 and register operand 1.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-vec_005fmask_005fstore_005flanesmn-instruction-pattern"></a><span>&lsquo;<samp class="samp">vec_mask_store_lanes<var class="var">m</var><var class="var">n</var></samp>&rsquo;<a class="copiable-link" href="#index-vec_005fmask_005fstore_005flanesmn-instruction-pattern"> &para;</a></span></dt>
<dd><p>Like &lsquo;<samp class="samp">vec_store_lanes<var class="var">m</var><var class="var">n</var></samp>&rsquo;, but takes an additional
mask operand (operand 2) that specifies which elements of the source
vectors should be stored.  The operation is equivalent to:
</p>
<div class="example smallexample">
<pre class="example-preformatted">int c = GET_MODE_SIZE (<var class="var">m</var>) / GET_MODE_SIZE (<var class="var">n</var>);
for (j = 0; j &lt; GET_MODE_NUNITS (<var class="var">n</var>); j++)
  if (operand2[j])
    for (i = 0; i &lt; c; i++)
      operand0[j * c + i] = operand1[i][j];
</pre></div>

<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-vec_005fmask_005flen_005fstore_005flanesmn-instruction-pattern"></a><span>&lsquo;<samp class="samp">vec_mask_len_store_lanes<var class="var">m</var><var class="var">n</var></samp>&rsquo;<a class="copiable-link" href="#index-vec_005fmask_005flen_005fstore_005flanesmn-instruction-pattern"> &para;</a></span></dt>
<dd><p>Like &lsquo;<samp class="samp">vec_store_lanes<var class="var">m</var><var class="var">n</var></samp>&rsquo;, but takes an additional
mask operand (operand 2), length operand (operand 3) as well as bias operand (operand 4)
that specifies which elements of the source vectors should be stored.
The operation is equivalent to:
</p>
<div class="example smallexample">
<pre class="example-preformatted">int c = GET_MODE_SIZE (<var class="var">m</var>) / GET_MODE_SIZE (<var class="var">n</var>);
for (j = 0; j &lt; operand3 + operand4; j++)
  if (operand2[j])
    for (i = 0; i &lt; c; i++)
      operand0[j * c + i] = operand1[i][j];
</pre></div>

<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-gather_005floadmn-instruction-pattern"></a><span>&lsquo;<samp class="samp">gather_load<var class="var">m</var><var class="var">n</var></samp>&rsquo;<a class="copiable-link" href="#index-gather_005floadmn-instruction-pattern"> &para;</a></span></dt>
<dd><p>Load several separate memory locations into a vector of mode <var class="var">m</var>.
Operand 1 is a scalar base address and operand 2 is a vector of mode <var class="var">n</var>
containing offsets from that base.  Operand 0 is a destination vector with
the same number of elements as <var class="var">n</var>.  For each element index <var class="var">i</var>:
</p>
<ul class="itemize mark-bullet">
<li>extend the offset element <var class="var">i</var> to address width, using zero
extension if operand 3 is 1 and sign extension if operand 3 is zero;
</li><li>multiply the extended offset by operand 4;
</li><li>add the result to the base; and
</li><li>load the value at that address into element <var class="var">i</var> of operand 0.
</li></ul>

<p>The value of operand 3 does not matter if the offsets are already
address width.
</p>
</dd>
<dt><a id="index-mask_005fgather_005floadmn-instruction-pattern"></a><span>&lsquo;<samp class="samp">mask_gather_load<var class="var">m</var><var class="var">n</var></samp>&rsquo;<a class="copiable-link" href="#index-mask_005fgather_005floadmn-instruction-pattern"> &para;</a></span></dt>
<dd><p>Like &lsquo;<samp class="samp">gather_load<var class="var">m</var><var class="var">n</var></samp>&rsquo;, but takes an extra mask operand as
operand 5.
Other elements of the destination vectors are taken from operand 6,
which is an else operand similar to the one in <code class="code">maskload</code>.
Bit <var class="var">i</var> of the mask is set if element <var class="var">i</var>
of the result should be loaded from memory and clear if element <var class="var">i</var>
of the result should be set to operand 6.
</p>
</dd>
<dt><a id="index-mask_005flen_005fgather_005floadmn-instruction-pattern"></a><span>&lsquo;<samp class="samp">mask_len_gather_load<var class="var">m</var><var class="var">n</var></samp>&rsquo;<a class="copiable-link" href="#index-mask_005flen_005fgather_005floadmn-instruction-pattern"> &para;</a></span></dt>
<dd><p>Like &lsquo;<samp class="samp">gather_load<var class="var">m</var><var class="var">n</var></samp>&rsquo;, but takes an extra mask operand
(operand 5) and an else operand (operand 6) as well as a len operand
(operand 7) and a bias operand (operand 8).
</p>
<p>Similar to mask_len_load the instruction loads at
most (operand 7 + operand 8) elements from memory.
Bit <var class="var">i</var> of the mask is set if element <var class="var">i</var> of the result should
be loaded from memory and clear if element <var class="var">i</var> of the result should
be set to element <var class="var">i</var> of operand 6.
Mask elements <var class="var">i</var> with <var class="var">i</var> &gt; (operand 7 + operand 8) are ignored.
</p>
</dd>
<dt><a id="index-mask_005flen_005fstrided_005floadm-instruction-pattern"></a><span>&lsquo;<samp class="samp">mask_len_strided_load<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-mask_005flen_005fstrided_005floadm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Load several separate memory locations into a destination vector of mode <var class="var">m</var>.
Operand 0 is a destination vector of mode <var class="var">m</var>.
Operand 1 is a scalar base address and operand 2 is a scalar stride of Pmode.
operand 3 is mask operand, operand 4 is length operand and operand 5 is bias operand.
The instruction can be seen as a special case of <code class="code">mask_len_gather_load<var class="var">m</var><var class="var">n</var></code>
with an offset vector that is a <code class="code">vec_series</code> with zero as base and operand 2 as step.
For each element the load address is operand 1 + <var class="var">i</var> * operand 2.
Similar to mask_len_load, the instruction loads at most (operand 4 + operand 5) elements from memory.
Element <var class="var">i</var> of the mask (operand 3) is set if element <var class="var">i</var> of the result should
be loaded from memory and clear if element <var class="var">i</var> of the result should be zero.
Mask elements <var class="var">i</var> with <var class="var">i</var> &gt; (operand 4 + operand 5) are ignored.
</p>
</dd>
<dt><a id="index-scatter_005fstoremn-instruction-pattern"></a><span>&lsquo;<samp class="samp">scatter_store<var class="var">m</var><var class="var">n</var></samp>&rsquo;<a class="copiable-link" href="#index-scatter_005fstoremn-instruction-pattern"> &para;</a></span></dt>
<dd><p>Store a vector of mode <var class="var">m</var> into several distinct memory locations.
Operand 0 is a scalar base address and operand 1 is a vector of mode
<var class="var">n</var> containing offsets from that base.  Operand 4 is the vector of
values that should be stored, which has the same number of elements as
<var class="var">n</var>.  For each element index <var class="var">i</var>:
</p>
<ul class="itemize mark-bullet">
<li>extend the offset element <var class="var">i</var> to address width, using zero
extension if operand 2 is 1 and sign extension if operand 2 is zero;
</li><li>multiply the extended offset by operand 3;
</li><li>add the result to the base; and
</li><li>store element <var class="var">i</var> of operand 4 to that address.
</li></ul>

<p>The value of operand 2 does not matter if the offsets are already
address width.
</p>
</dd>
<dt><a id="index-mask_005fscatter_005fstoremn-instruction-pattern"></a><span>&lsquo;<samp class="samp">mask_scatter_store<var class="var">m</var><var class="var">n</var></samp>&rsquo;<a class="copiable-link" href="#index-mask_005fscatter_005fstoremn-instruction-pattern"> &para;</a></span></dt>
<dd><p>Like &lsquo;<samp class="samp">scatter_store<var class="var">m</var><var class="var">n</var></samp>&rsquo;, but takes an extra mask operand as
operand 5.  Bit <var class="var">i</var> of the mask is set if element <var class="var">i</var>
of the result should be stored to memory.
</p>
</dd>
<dt><a id="index-mask_005flen_005fscatter_005fstoremn-instruction-pattern"></a><span>&lsquo;<samp class="samp">mask_len_scatter_store<var class="var">m</var><var class="var">n</var></samp>&rsquo;<a class="copiable-link" href="#index-mask_005flen_005fscatter_005fstoremn-instruction-pattern"> &para;</a></span></dt>
<dd><p>Like &lsquo;<samp class="samp">scatter_store<var class="var">m</var><var class="var">n</var></samp>&rsquo;, but takes an extra mask operand (operand 5),
a len operand (operand 6) as well as a bias operand (operand 7).  The instruction stores
at most (operand 6 + operand 7) elements of (operand 4) to memory.
Bit <var class="var">i</var> of the mask is set if element <var class="var">i</var> of (operand 4) should be stored.
Mask elements <var class="var">i</var> with <var class="var">i</var> &gt; (operand 6 + operand 7) are ignored.
</p>
</dd>
<dt><a id="index-mask_005flen_005fstrided_005fstorem-instruction-pattern"></a><span>&lsquo;<samp class="samp">mask_len_strided_store<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-mask_005flen_005fstrided_005fstorem-instruction-pattern"> &para;</a></span></dt>
<dd><p>Store a vector of mode m into several distinct memory locations.
Operand 0 is a scalar base address and operand 1 is scalar stride of Pmode.
Operand 2 is the vector of values that should be stored, which is of mode <var class="var">m</var>.
operand 3 is mask operand, operand 4 is length operand and operand 5 is bias operand.
The instruction can be seen as a special case of <code class="code">mask_len_scatter_store<var class="var">m</var><var class="var">n</var></code>
with an offset vector that is a <code class="code">vec_series</code> with zero as base and operand 1 as step.
For each element the store address is operand 0 + <var class="var">i</var> * operand 1.
Similar to mask_len_store, the instruction stores at most (operand 4 + operand 5) elements of
mask (operand 3) to memory.  Element <var class="var">i</var> of the mask is set if element <var class="var">i</var> of (operand 3)
should be stored.  Mask elements <var class="var">i</var> with <var class="var">i</var> &gt; (operand 4 + operand 5) are ignored.
</p>
</dd>
<dt><a id="index-vec_005fsetm-instruction-pattern"></a><span>&lsquo;<samp class="samp">vec_set<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-vec_005fsetm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Set given field in the vector value.  Operand 0 is the vector to modify,
operand 1 is new value of field and operand 2 specify the field index.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-vec_005fextractmn-instruction-pattern"></a><span>&lsquo;<samp class="samp">vec_extract<var class="var">m</var><var class="var">n</var></samp>&rsquo;<a class="copiable-link" href="#index-vec_005fextractmn-instruction-pattern"> &para;</a></span></dt>
<dd><p>Extract given field from the vector value.  Operand 1 is the vector, operand 2
specify field index and operand 0 place to store value into.  The
<var class="var">n</var> mode is the mode of the field or vector of fields that should be
extracted, should be either element mode of the vector mode <var class="var">m</var>, or
a vector mode with the same element mode and smaller number of elements.
If <var class="var">n</var> is a vector mode the index is counted in multiples of
mode <var class="var">n</var>.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-vec_005finitmn-instruction-pattern"></a><span>&lsquo;<samp class="samp">vec_init<var class="var">m</var><var class="var">n</var></samp>&rsquo;<a class="copiable-link" href="#index-vec_005finitmn-instruction-pattern"> &para;</a></span></dt>
<dd><p>Initialize the vector to given values.  Operand 0 is the vector to initialize
and operand 1 is parallel containing values for individual fields.  The
<var class="var">n</var> mode is the mode of the elements, should be either element mode of
the vector mode <var class="var">m</var>, or a vector mode with the same element mode and
smaller number of elements.
</p>
</dd>
<dt><a id="index-vec_005fduplicatem-instruction-pattern"></a><span>&lsquo;<samp class="samp">vec_duplicate<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-vec_005fduplicatem-instruction-pattern"> &para;</a></span></dt>
<dd><p>Initialize vector output operand 0 so that each element has the value given
by scalar input operand 1.  The vector has mode <var class="var">m</var> and the scalar has
the mode appropriate for one element of <var class="var">m</var>.
</p>
<p>This pattern only handles duplicates of non-constant inputs.  Constant
vectors go through the <code class="code">mov<var class="var">m</var></code> pattern instead.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-vec_005fseriesm-instruction-pattern"></a><span>&lsquo;<samp class="samp">vec_series<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-vec_005fseriesm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Initialize vector output operand 0 so that element <var class="var">i</var> is equal to
operand 1 plus <var class="var">i</var> times operand 2.  In other words, create a linear
series whose base value is operand 1 and whose step is operand 2.
</p>
<p>The vector output has mode <var class="var">m</var> and the scalar inputs have the mode
appropriate for one element of <var class="var">m</var>.  This pattern is not used for
floating-point vectors, in order to avoid having to specify the
rounding behavior for <var class="var">i</var> &gt; 1.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-while_005fultmn-instruction-pattern"></a><span><code class="code">while_ult<var class="var">m</var><var class="var">n</var></code><a class="copiable-link" href="#index-while_005fultmn-instruction-pattern"> &para;</a></span></dt>
<dd><p>Set operand 0 to a mask that is true while incrementing operand 1
gives a value that is less than operand 2, for a vector length up to operand 3.
Operand 0 has mode <var class="var">n</var> and operands 1 and 2 are scalar integers of mode
<var class="var">m</var>.  Operand 3 should be omitted when <var class="var">n</var> is a vector mode, and
a <code class="code">CONST_INT</code> otherwise.  The operation for vector modes is equivalent to:
</p>
<div class="example smallexample">
<pre class="example-preformatted">operand0[0] = operand1 &lt; operand2;
for (i = 1; i &lt; GET_MODE_NUNITS (<var class="var">n</var>); i++)
  operand0[i] = operand0[i - 1] &amp;&amp; (operand1 + i &lt; operand2);
</pre></div>

<p>And for non-vector modes the operation is equivalent to:
</p>
<div class="example smallexample">
<pre class="example-preformatted">operand0[0] = operand1 &lt; operand2;
for (i = 1; i &lt; operand3; i++)
  operand0[i] = operand0[i - 1] &amp;&amp; (operand1 + i &lt; operand2);
</pre></div>

</dd>
<dt><a id="index-select_005fvlm-instruction-pattern"></a><span><code class="code">select_vl<var class="var">m</var></code><a class="copiable-link" href="#index-select_005fvlm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Set operand 0 to the number of scalar iterations that should be handled
by one iteration of a vector loop.  Operand 1 is the total number of
scalar iterations that the loop needs to process and operand 2 is a
maximum bound on the result (also known as the maximum &ldquo;vectorization
factor&rdquo;).
</p>
<p>The maximum value of operand 0 is given by:
</p><div class="example smallexample">
<pre class="example-preformatted">operand0 = MIN (operand1, operand2)
</pre></div>
<p>However, targets might choose a lower value than this, based on
target-specific criteria.  Each iteration of the vector loop might
therefore process a different number of scalar iterations, which in turn
means that induction variables will have a variable step.  Because of
this, it is generally not useful to define this instruction if it will
always calculate the maximum value.
</p>
<p>This optab is only useful on targets that implement &lsquo;<samp class="samp">len_load_<var class="var">m</var></samp>&rsquo;
and/or &lsquo;<samp class="samp">len_store_<var class="var">m</var></samp>&rsquo;.
</p>
</dd>
<dt><a id="index-check_005fraw_005fptrsm-instruction-pattern"></a><span>&lsquo;<samp class="samp">check_raw_ptrs<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-check_005fraw_005fptrsm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Check whether, given two pointers <var class="var">a</var> and <var class="var">b</var> and a length <var class="var">len</var>,
a write of <var class="var">len</var> bytes at <var class="var">a</var> followed by a read of <var class="var">len</var> bytes
at <var class="var">b</var> can be split into interleaved byte accesses
&lsquo;<samp class="samp"><var class="var">a</var>[0], <var class="var">b</var>[0], <var class="var">a</var>[1], <var class="var">b</var>[1], &hellip;</samp>&rsquo;
without affecting the dependencies between the bytes.  Set operand 0
to true if the split is possible and false otherwise.
</p>
<p>Operands 1, 2 and 3 provide the values of <var class="var">a</var>, <var class="var">b</var> and <var class="var">len</var>
respectively.  Operand 4 is a constant integer that provides the known
common alignment of <var class="var">a</var> and <var class="var">b</var>.  All inputs have mode <var class="var">m</var>.
</p>
<p>This split is possible if:
</p>
<div class="example smallexample">
<pre class="example-preformatted"><var class="var">a</var> == <var class="var">b</var> || <var class="var">a</var> + <var class="var">len</var> &lt;= <var class="var">b</var> || <var class="var">b</var> + <var class="var">len</var> &lt;= <var class="var">a</var>
</pre></div>

<p>You should only define this pattern if the target has a way of accelerating
the test without having to do the individual comparisons.
</p>
</dd>
<dt><a id="index-check_005fwar_005fptrsm-instruction-pattern"></a><span>&lsquo;<samp class="samp">check_war_ptrs<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-check_005fwar_005fptrsm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Like &lsquo;<samp class="samp">check_raw_ptrs<var class="var">m</var></samp>&rsquo;, but with the read and write swapped round.
The split is possible in this case if:
</p>
<div class="example smallexample">
<pre class="example-preformatted"><var class="var">b</var> &lt;= <var class="var">a</var> || <var class="var">a</var> + <var class="var">len</var> &lt;= <var class="var">b</var>
</pre></div>

</dd>
<dt><a id="index-vec_005fcmpmn-instruction-pattern"></a><span>&lsquo;<samp class="samp">vec_cmp<var class="var">m</var><var class="var">n</var></samp>&rsquo;<a class="copiable-link" href="#index-vec_005fcmpmn-instruction-pattern"> &para;</a></span></dt>
<dd><p>Output a vector comparison.  Operand 0 of mode <var class="var">n</var> is the destination for
predicate in operand 1 which is a signed vector comparison with operands of
mode <var class="var">m</var> in operands 2 and 3.  Predicate is computed by element-wise
evaluation of the vector comparison with a truth value of all-ones and a false
value of all-zeros.
</p>
</dd>
<dt><a id="index-vec_005fcmpumn-instruction-pattern"></a><span>&lsquo;<samp class="samp">vec_cmpu<var class="var">m</var><var class="var">n</var></samp>&rsquo;<a class="copiable-link" href="#index-vec_005fcmpumn-instruction-pattern"> &para;</a></span></dt>
<dd><p>Similar to <code class="code">vec_cmp<var class="var">m</var><var class="var">n</var></code> but perform unsigned vector comparison.
</p>
</dd>
<dt><a id="index-vec_005fcmpeqmn-instruction-pattern"></a><span>&lsquo;<samp class="samp">vec_cmpeq<var class="var">m</var><var class="var">n</var></samp>&rsquo;<a class="copiable-link" href="#index-vec_005fcmpeqmn-instruction-pattern"> &para;</a></span></dt>
<dd><p>Similar to <code class="code">vec_cmp<var class="var">m</var><var class="var">n</var></code> but perform equality or non-equality
vector comparison only.  If <code class="code">vec_cmp<var class="var">m</var><var class="var">n</var></code>
or <code class="code">vec_cmpu<var class="var">m</var><var class="var">n</var></code> instruction pattern is supported,
it will be preferred over <code class="code">vec_cmpeq<var class="var">m</var><var class="var">n</var></code>, so there is
no need to define this instruction pattern if the others are supported.
</p>
</dd>
<dt><a id="index-vcond_005fmask_005fmn-instruction-pattern"></a><span>&lsquo;<samp class="samp">vcond_mask_<var class="var">m</var><var class="var">n</var></samp>&rsquo;<a class="copiable-link" href="#index-vcond_005fmask_005fmn-instruction-pattern"> &para;</a></span></dt>
<dd><p>Output a conditional vector move.  Operand 0 is the destination to
receive a combination of operand 1 and operand 2, depending on the
mask in operand 3.  Operands 0, 1, and 2 have mode <var class="var">m</var> while
operand 3 has mode <var class="var">n</var>.
</p>
<p>Suppose that <var class="var">m</var> has <var class="var">e</var> elements.  There are then two
supported forms of <var class="var">n</var>.  The first form is an integer or
boolean vector that also has <var class="var">e</var> elements.  In this case, each
element is -1 or 0, with -1 selecting elements from operand 1 and
0 selecting elements from operand 2.  The second supported form
of <var class="var">n</var> is a scalar integer that has at least <var class="var">e</var> bits.
A set bit then selects from operand 1 and a clear bit selects
from operand 2.  Bits <var class="var">e</var> and above have no effect.
</p>
<p>Subject to those restrictions, the behavior is equivalent to:
</p>
<div class="example smallexample">
<pre class="example-preformatted">for (i = 0; i &lt; <var class="var">e</var>; i++)
  op0[i] = op3[i] ? op1[i] : op2[i];
</pre></div>

</dd>
<dt><a id="index-vcond_005fmask_005flen_005fmn-instruction-pattern"></a><span>&lsquo;<samp class="samp">vcond_mask_len_<var class="var">m</var><var class="var">n</var></samp>&rsquo;<a class="copiable-link" href="#index-vcond_005fmask_005flen_005fmn-instruction-pattern"> &para;</a></span></dt>
<dd><p>Set each element of operand 0 to the corresponding element of operand 2
or operand 3.  Choose operand 2 if both the element index is less than
operand 4 plus operand 5 and the corresponding element of operand 1
is nonzero:
</p>
<div class="example smallexample">
<pre class="example-preformatted">for (i = 0; i &lt; GET_MODE_NUNITS (<var class="var">m</var>); i++)
  op0[i] = i &lt; op4 + op5 &amp;&amp; op1[i] ? op2[i] : op3[i];
</pre></div>

<p>Operands 0, 2 and 3 have mode <var class="var">m</var>.  Operand 1 has mode <var class="var">n</var>.
Operands 4 and 5 have a target-dependent scalar integer mode.
</p>
</dd>
<dt><a id="index-maskloadmn-instruction-pattern"></a><span>&lsquo;<samp class="samp">maskload<var class="var">m</var><var class="var">n</var></samp>&rsquo;<a class="copiable-link" href="#index-maskloadmn-instruction-pattern"> &para;</a></span></dt>
<dd><p>Perform a masked load of vector from memory operand 1 of mode <var class="var">m</var>
into register operand 0.  The mask is provided in register operand 2 of
mode <var class="var">n</var>.  Operand 3 (the &ldquo;else value&rdquo;) is of mode <var class="var">m</var> and
specifies which value is loaded when the mask is unset.
The predicate of operand 3 must only accept the else values that the target
actually supports.  Currently three values are attempted, zero, -1, and
undefined.  GCC handles an else value of zero more efficiently than -1 or
undefined.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-maskstoremn-instruction-pattern"></a><span>&lsquo;<samp class="samp">maskstore<var class="var">m</var><var class="var">n</var></samp>&rsquo;<a class="copiable-link" href="#index-maskstoremn-instruction-pattern"> &para;</a></span></dt>
<dd><p>Perform a masked store of vector from register operand 1 of mode <var class="var">m</var>
into memory operand 0.  Mask is provided in register operand 2 of
mode <var class="var">n</var>.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-len_005fload_005fm-instruction-pattern"></a><span>&lsquo;<samp class="samp">len_load_<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-len_005fload_005fm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Load (operand 2 + operand 3) elements from memory operand 1
into vector register operand 0, setting the other elements of
operand 0 to undefined values.  Operands 0 and 1 have mode <var class="var">m</var>,
which must be a vector mode.  Operand 2 has whichever integer mode the
target prefers.  Operand 3 conceptually has mode <code class="code">QI</code>.
</p>
<p>Operand 2 can be a variable or a constant amount.  Operand 3 specifies a
constant bias: it is either a constant 0 or a constant -1.  The predicate on
operand 3 must only accept the bias values that the target actually supports.
GCC handles a bias of 0 more efficiently than a bias of -1.
</p>
<p>If (operand 2 + operand 3) exceeds the number of elements in mode
<var class="var">m</var>, the behavior is undefined.
</p>
<p>If the target prefers the length to be measured in bytes rather than
elements, it should only implement this pattern for vectors of <code class="code">QI</code>
elements.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-len_005fstore_005fm-instruction-pattern"></a><span>&lsquo;<samp class="samp">len_store_<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-len_005fstore_005fm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Store (operand 2 + operand 3) vector elements from vector register operand 1
into memory operand 0, leaving the other elements of
operand 0 unchanged.  Operands 0 and 1 have mode <var class="var">m</var>, which must be
a vector mode.  Operand 2 has whichever integer mode the target prefers.
Operand 3 conceptually has mode <code class="code">QI</code>.
</p>
<p>Operand 2 can be a variable or a constant amount.  Operand 3 specifies a
constant bias: it is either a constant 0 or a constant -1.  The predicate on
operand 3 must only accept the bias values that the target actually supports.
GCC handles a bias of 0 more efficiently than a bias of -1.
</p>
<p>If (operand 2 + operand 3) exceeds the number of elements in mode
<var class="var">m</var>, the behavior is undefined.
</p>
<p>If the target prefers the length to be measured in bytes
rather than elements, it should only implement this pattern for vectors
of <code class="code">QI</code> elements.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-mask_005flen_005floadmn-instruction-pattern"></a><span>&lsquo;<samp class="samp">mask_len_load<var class="var">m</var><var class="var">n</var></samp>&rsquo;<a class="copiable-link" href="#index-mask_005flen_005floadmn-instruction-pattern"> &para;</a></span></dt>
<dd><p>Perform a masked load from the memory location pointed to by operand 1
into register operand 0.  (operand 3 + operand 4) elements are loaded from
memory and other elements in operand 0 are set to undefined values.
This is a combination of len_load and maskload.
Operands 0 and 1 have mode <var class="var">m</var>, which must be a vector mode.  Operand 3
has whichever integer mode the target prefers.  A mask is specified in
operand 2 which must be of type <var class="var">n</var>.  The mask has lower precedence than
the length and is itself subject to length masking,
i.e. only mask indices &lt; (operand 4 + operand 5) are used.
Operand 3 is an else operand similar to the one in <code class="code">maskload</code>.
Operand 4 conceptually has mode <code class="code">QI</code>.
</p>
<p>Operand 4 can be a variable or a constant amount.  Operand 5 specifies a
constant bias: it is either a constant 0 or a constant -1.  The predicate on
operand 5 must only accept the bias values that the target actually supports.
GCC handles a bias of 0 more efficiently than a bias of -1.
</p>
<p>If (operand 4 + operand 5) exceeds the number of elements in mode
<var class="var">m</var>, the behavior is undefined.
</p>
<p>If the target prefers the length to be measured in bytes
rather than elements, it should only implement this pattern for vectors
of <code class="code">QI</code> elements.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-mask_005flen_005fstoremn-instruction-pattern"></a><span>&lsquo;<samp class="samp">mask_len_store<var class="var">m</var><var class="var">n</var></samp>&rsquo;<a class="copiable-link" href="#index-mask_005flen_005fstoremn-instruction-pattern"> &para;</a></span></dt>
<dd><p>Perform a masked store from vector register operand 1 into memory operand 0.
(operand 3 + operand 4) elements are stored to memory
and leave the other elements of operand 0 unchanged.
This is a combination of len_store and maskstore.
Operands 0 and 1 have mode <var class="var">m</var>, which must be a vector mode.  Operand 3 has whichever
integer mode the target prefers.  A mask is specified in operand 2 which must be
of type <var class="var">n</var>.  The mask has lower precedence than the length and is itself subject to
length masking, i.e. only mask indices &lt; (operand 3 + operand 4) are used.
Operand 4 conceptually has mode <code class="code">QI</code>.
</p>
<p>Operand 2 can be a variable or a constant amount.  Operand 3 specifies a
constant bias: it is either a constant 0 or a constant -1.  The predicate on
operand 4 must only accept the bias values that the target actually supports.
GCC handles a bias of 0 more efficiently than a bias of -1.
</p>
<p>If (operand 2 + operand 4) exceeds the number of elements in mode
<var class="var">m</var>, the behavior is undefined.
</p>
<p>If the target prefers the length to be measured in bytes
rather than elements, it should only implement this pattern for vectors
of <code class="code">QI</code> elements.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-vec_005fpermm-instruction-pattern"></a><span>&lsquo;<samp class="samp">vec_perm<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-vec_005fpermm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Output a (variable) vector permutation.  Operand 0 is the destination
to receive elements from operand 1 and operand 2, which are of mode
<var class="var">m</var>.  Operand 3 is the <em class="dfn">selector</em>.  It is an integral mode
vector of the same width and number of elements as mode <var class="var">m</var>.
</p>
<p>The input elements are numbered from 0 in operand 1 through
<em class="math">2*<var class="var">N</var>-1</em> in operand 2.  The elements of the selector must
be computed modulo <em class="math">2*<var class="var">N</var></em>.  Note that if
<code class="code">rtx_equal_p(operand1, operand2)</code>, this can be implemented
with just operand 1 and selector elements modulo <var class="var">N</var>.
</p>
<p>In order to make things easy for a number of targets, if there is no
&lsquo;<samp class="samp">vec_perm</samp>&rsquo; pattern for mode <var class="var">m</var>, but there is for mode <var class="var">q</var>
where <var class="var">q</var> is a vector of <code class="code">QImode</code> of the same width as <var class="var">m</var>,
the middle-end will lower the mode <var class="var">m</var> <code class="code">VEC_PERM_EXPR</code> to
mode <var class="var">q</var>.
</p>
<p>See also <code class="code">TARGET_VECTORIZER_VEC_PERM_CONST</code>, which performs
the analogous operation for constant selectors.
</p>
</dd>
<dt><a id="index-pushm1-instruction-pattern"></a><span>&lsquo;<samp class="samp">push<var class="var">m</var>1</samp>&rsquo;<a class="copiable-link" href="#index-pushm1-instruction-pattern"> &para;</a></span></dt>
<dd><p>Output a push instruction.  Operand 0 is value to push.  Used only when
<code class="code">PUSH_ROUNDING</code> is defined.  For historical reason, this pattern may be
missing and in such case an <code class="code">mov</code> expander is used instead, with a
<code class="code">MEM</code> expression forming the push operation.  The <code class="code">mov</code> expander
method is deprecated.
</p>
</dd>
<dt><a id="index-addm3-instruction-pattern"></a><span>&lsquo;<samp class="samp">add<var class="var">m</var>3</samp>&rsquo;<a class="copiable-link" href="#index-addm3-instruction-pattern"> &para;</a></span></dt>
<dd><p>Add operand 2 and operand 1, storing the result in operand 0.  All operands
must have mode <var class="var">m</var>.  This can be used even on two-address machines, by
means of constraints requiring operands 1 and 0 to be the same location.
</p>
</dd>
<dt><a class="index-entry-id" id="index-usaddm3-instruction-pattern"></a>
<a class="index-entry-id" id="index-subm3-instruction-pattern"></a>
<a class="index-entry-id" id="index-sssubm3-instruction-pattern"></a>
<a class="index-entry-id" id="index-ussubm3-instruction-pattern"></a>
<a class="index-entry-id" id="index-mulm3-instruction-pattern"></a>
<a class="index-entry-id" id="index-ssmulm3-instruction-pattern"></a>
<a class="index-entry-id" id="index-usmulm3-instruction-pattern"></a>
<a class="index-entry-id" id="index-divm3-instruction-pattern"></a>
<a class="index-entry-id" id="index-ssdivm3-instruction-pattern"></a>
<a class="index-entry-id" id="index-udivm3-instruction-pattern"></a>
<a class="index-entry-id" id="index-usdivm3-instruction-pattern"></a>
<a class="index-entry-id" id="index-modm3-instruction-pattern"></a>
<a class="index-entry-id" id="index-umodm3-instruction-pattern"></a>
<a class="index-entry-id" id="index-uminm3-instruction-pattern"></a>
<a class="index-entry-id" id="index-umaxm3-instruction-pattern"></a>
<a class="index-entry-id" id="index-andm3-instruction-pattern"></a>
<a class="index-entry-id" id="index-iorm3-instruction-pattern"></a>
<a class="index-entry-id" id="index-xorm3-instruction-pattern"></a>
<a id="index-ssaddm3-instruction-pattern"></a><span>&lsquo;<samp class="samp">ssadd<var class="var">m</var>3</samp>&rsquo;, &lsquo;<samp class="samp">usadd<var class="var">m</var>3</samp>&rsquo;<a class="copiable-link" href="#index-ssaddm3-instruction-pattern"> &para;</a></span></dt>
<dt>&lsquo;<samp class="samp">sub<var class="var">m</var>3</samp>&rsquo;, &lsquo;<samp class="samp">sssub<var class="var">m</var>3</samp>&rsquo;, &lsquo;<samp class="samp">ussub<var class="var">m</var>3</samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">mul<var class="var">m</var>3</samp>&rsquo;, &lsquo;<samp class="samp">ssmul<var class="var">m</var>3</samp>&rsquo;, &lsquo;<samp class="samp">usmul<var class="var">m</var>3</samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">div<var class="var">m</var>3</samp>&rsquo;, &lsquo;<samp class="samp">ssdiv<var class="var">m</var>3</samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">udiv<var class="var">m</var>3</samp>&rsquo;, &lsquo;<samp class="samp">usdiv<var class="var">m</var>3</samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">mod<var class="var">m</var>3</samp>&rsquo;, &lsquo;<samp class="samp">umod<var class="var">m</var>3</samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">umin<var class="var">m</var>3</samp>&rsquo;, &lsquo;<samp class="samp">umax<var class="var">m</var>3</samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">and<var class="var">m</var>3</samp>&rsquo;, &lsquo;<samp class="samp">ior<var class="var">m</var>3</samp>&rsquo;, &lsquo;<samp class="samp">xor<var class="var">m</var>3</samp>&rsquo;</dt>
<dd><p>Similar, for other arithmetic operations.
</p>
</dd>
<dt><a id="index-ustruncmn2-instruction-pattern"></a><span>&lsquo;<samp class="samp">ustrunc<var class="var">m</var><var class="var">n</var>2</samp>&rsquo;<a class="copiable-link" href="#index-ustruncmn2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Truncate the operand 1, and storing the result in operand 0.  There will
be saturation during the trunction.  The result will be saturated to the
maximal value of operand 0 type if there is overflow when truncation.  The
operand 1 must have mode <var class="var">n</var>,  and the operand 0 must have mode <var class="var">m</var>.
Both scalar and vector integer modes are allowed.
</p>
</dd>
<dt><a id="index-sstruncmn2-instruction-pattern"></a><span>&lsquo;<samp class="samp">sstrunc<var class="var">m</var><var class="var">n</var>2</samp>&rsquo;<a class="copiable-link" href="#index-sstruncmn2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Similar but for signed.
</p>
</dd>
<dt><a id="index-andnm3-instruction-pattern"></a><span>&lsquo;<samp class="samp">andn<var class="var">m</var>3</samp>&rsquo;<a class="copiable-link" href="#index-andnm3-instruction-pattern"> &para;</a></span></dt>
<dd><p>Like <code class="code">and<var class="var">m</var>3</code>, but it uses bitwise-complement of operand 2
rather than operand 2 itself.
</p>
</dd>
<dt><a id="index-iornm3-instruction-pattern"></a><span>&lsquo;<samp class="samp">iorn<var class="var">m</var>3</samp>&rsquo;<a class="copiable-link" href="#index-iornm3-instruction-pattern"> &para;</a></span></dt>
<dd><p>Like <code class="code">ior<var class="var">m</var>3</code>, but it uses bitwise-complement of operand 2
rather than operand 2 itself.
</p>
</dd>
<dt><a id="index-addvm4-instruction-pattern"></a><span>&lsquo;<samp class="samp">addv<var class="var">m</var>4</samp>&rsquo;<a class="copiable-link" href="#index-addvm4-instruction-pattern"> &para;</a></span></dt>
<dd><p>Like <code class="code">add<var class="var">m</var>3</code> but takes a <code class="code">code_label</code> as operand 3 and
emits code to jump to it if signed overflow occurs during the addition.
This pattern is used to implement the built-in functions performing
signed integer addition with overflow checking.
</p>
</dd>
<dt><a class="index-entry-id" id="index-mulvm4-instruction-pattern"></a>
<a id="index-subvm4-instruction-pattern"></a><span>&lsquo;<samp class="samp">subv<var class="var">m</var>4</samp>&rsquo;, &lsquo;<samp class="samp">mulv<var class="var">m</var>4</samp>&rsquo;<a class="copiable-link" href="#index-subvm4-instruction-pattern"> &para;</a></span></dt>
<dd><p>Similar, for other signed arithmetic operations.
</p>
</dd>
<dt><a id="index-uaddvm4-instruction-pattern"></a><span>&lsquo;<samp class="samp">uaddv<var class="var">m</var>4</samp>&rsquo;<a class="copiable-link" href="#index-uaddvm4-instruction-pattern"> &para;</a></span></dt>
<dd><p>Like <code class="code">addv<var class="var">m</var>4</code> but for unsigned addition.  That is to
say, the operation is the same as signed addition but the jump
is taken only on unsigned overflow.
</p>
</dd>
<dt><a class="index-entry-id" id="index-umulvm4-instruction-pattern"></a>
<a id="index-usubvm4-instruction-pattern"></a><span>&lsquo;<samp class="samp">usubv<var class="var">m</var>4</samp>&rsquo;, &lsquo;<samp class="samp">umulv<var class="var">m</var>4</samp>&rsquo;<a class="copiable-link" href="#index-usubvm4-instruction-pattern"> &para;</a></span></dt>
<dd><p>Similar, for other unsigned arithmetic operations.
</p>
</dd>
<dt><a id="index-uaddcm5-instruction-pattern"></a><span>&lsquo;<samp class="samp">uaddc<var class="var">m</var>5</samp>&rsquo;<a class="copiable-link" href="#index-uaddcm5-instruction-pattern"> &para;</a></span></dt>
<dd><p>Adds unsigned operands 2, 3 and 4 (where the last operand is guaranteed to
have only values 0 or 1) together, sets operand 0 to the result of the
addition of the 3 operands and sets operand 1 to 1 iff there was
overflow on the unsigned additions, and to 0 otherwise.  So, it is
an addition with carry in (operand 4) and carry out (operand 1).
All operands have the same mode.
</p>
</dd>
<dt><a id="index-usubcm5-instruction-pattern"></a><span>&lsquo;<samp class="samp">usubc<var class="var">m</var>5</samp>&rsquo;<a class="copiable-link" href="#index-usubcm5-instruction-pattern"> &para;</a></span></dt>
<dd><p>Similarly to &lsquo;<samp class="samp">uaddc<var class="var">m</var>5</samp>&rsquo;, except subtracts unsigned operands 3
and 4 from operand 2 instead of adding them.  So, it is
a subtraction with carry/borrow in (operand 4) and carry/borrow out
(operand 1).  All operands have the same mode.
</p>
</dd>
<dt><a id="index-addptrm3-instruction-pattern"></a><span>&lsquo;<samp class="samp">addptr<var class="var">m</var>3</samp>&rsquo;<a class="copiable-link" href="#index-addptrm3-instruction-pattern"> &para;</a></span></dt>
<dd><p>Like <code class="code">add<var class="var">m</var>3</code> but is guaranteed to only be used for address
calculations.  The expanded code is not allowed to clobber the
condition code.  It only needs to be defined if <code class="code">add<var class="var">m</var>3</code>
sets the condition code.  If adds used for address calculations and
normal adds are not compatible it is required to expand a distinct
pattern (e.g. using an unspec).  The pattern is used by LRA to emit
address calculations.  <code class="code">add<var class="var">m</var>3</code> is used if
<code class="code">addptr<var class="var">m</var>3</code> is not defined.
</p>
</dd>
<dt><a id="index-fmam4-instruction-pattern"></a><span>&lsquo;<samp class="samp">fma<var class="var">m</var>4</samp>&rsquo;<a class="copiable-link" href="#index-fmam4-instruction-pattern"> &para;</a></span></dt>
<dd><p>Multiply operand 2 and operand 1, then add operand 3, storing the
result in operand 0 without doing an intermediate rounding step.  All
operands must have mode <var class="var">m</var>.  This pattern is used to implement
the <code class="code">fma</code>, <code class="code">fmaf</code>, and <code class="code">fmal</code> builtin functions from
the ISO C99 standard.
</p>
</dd>
<dt><a id="index-fmsm4-instruction-pattern"></a><span>&lsquo;<samp class="samp">fms<var class="var">m</var>4</samp>&rsquo;<a class="copiable-link" href="#index-fmsm4-instruction-pattern"> &para;</a></span></dt>
<dd><p>Like <code class="code">fma<var class="var">m</var>4</code>, except operand 3 subtracted from the
product instead of added to the product.  This is represented
in the rtl as
</p>
<div class="example smallexample">
<pre class="example-preformatted">(fma:<var class="var">m</var> <var class="var">op1</var> <var class="var">op2</var> (neg:<var class="var">m</var> <var class="var">op3</var>))
</pre></div>

</dd>
<dt><a id="index-fnmam4-instruction-pattern"></a><span>&lsquo;<samp class="samp">fnma<var class="var">m</var>4</samp>&rsquo;<a class="copiable-link" href="#index-fnmam4-instruction-pattern"> &para;</a></span></dt>
<dd><p>Like <code class="code">fma<var class="var">m</var>4</code> except that the intermediate product
is negated before being added to operand 3.  This is represented
in the rtl as
</p>
<div class="example smallexample">
<pre class="example-preformatted">(fma:<var class="var">m</var> (neg:<var class="var">m</var> <var class="var">op1</var>) <var class="var">op2</var> <var class="var">op3</var>)
</pre></div>

</dd>
<dt><a id="index-fnmsm4-instruction-pattern"></a><span>&lsquo;<samp class="samp">fnms<var class="var">m</var>4</samp>&rsquo;<a class="copiable-link" href="#index-fnmsm4-instruction-pattern"> &para;</a></span></dt>
<dd><p>Like <code class="code">fms<var class="var">m</var>4</code> except that the intermediate product
is negated before subtracting operand 3.  This is represented
in the rtl as
</p>
<div class="example smallexample">
<pre class="example-preformatted">(fma:<var class="var">m</var> (neg:<var class="var">m</var> <var class="var">op1</var>) <var class="var">op2</var> (neg:<var class="var">m</var> <var class="var">op3</var>))
</pre></div>

</dd>
<dt><a class="index-entry-id" id="index-maxm3-instruction-pattern"></a>
<a id="index-minm3-instruction-pattern"></a><span>&lsquo;<samp class="samp">smin<var class="var">m</var>3</samp>&rsquo;, &lsquo;<samp class="samp">smax<var class="var">m</var>3</samp>&rsquo;<a class="copiable-link" href="#index-minm3-instruction-pattern"> &para;</a></span></dt>
<dd><p>Signed minimum and maximum operations.  When used with floating point,
if both operands are zeros, or if either operand is <code class="code">NaN</code>, then
it is unspecified which of the two operands is returned as the result.
</p>
</dd>
<dt><a class="index-entry-id" id="index-fmaxm3-instruction-pattern"></a>
<a id="index-fminm3-instruction-pattern"></a><span>&lsquo;<samp class="samp">fmin<var class="var">m</var>3</samp>&rsquo;, &lsquo;<samp class="samp">fmax<var class="var">m</var>3</samp>&rsquo;<a class="copiable-link" href="#index-fminm3-instruction-pattern"> &para;</a></span></dt>
<dd><p>IEEE-conformant minimum and maximum operations.  If one operand is a quiet
<code class="code">NaN</code>, then the other operand is returned.  If both operands are quiet
<code class="code">NaN</code>, then a quiet <code class="code">NaN</code> is returned.  In the case when gcc supports
signaling <code class="code">NaN</code> (-fsignaling-nans) an invalid floating point exception is
raised and a quiet <code class="code">NaN</code> is returned.
</p>
<p>All operands have mode <var class="var">m</var>, which is a scalar or vector
floating-point mode.  These patterns are not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a class="index-entry-id" id="index-reduc_005fsmax_005fscal_005fm-instruction-pattern"></a>
<a id="index-reduc_005fsmin_005fscal_005fm-instruction-pattern"></a><span>&lsquo;<samp class="samp">reduc_smin_scal_<var class="var">m</var></samp>&rsquo;, &lsquo;<samp class="samp">reduc_smax_scal_<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-reduc_005fsmin_005fscal_005fm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Find the signed minimum/maximum of the elements of a vector. The vector is
operand 1, and operand 0 is the scalar result, with mode equal to the mode of
the elements of the input vector.
</p>
</dd>
<dt><a class="index-entry-id" id="index-reduc_005fumax_005fscal_005fm-instruction-pattern"></a>
<a id="index-reduc_005fumin_005fscal_005fm-instruction-pattern"></a><span>&lsquo;<samp class="samp">reduc_umin_scal_<var class="var">m</var></samp>&rsquo;, &lsquo;<samp class="samp">reduc_umax_scal_<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-reduc_005fumin_005fscal_005fm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Find the unsigned minimum/maximum of the elements of a vector. The vector is
operand 1, and operand 0 is the scalar result, with mode equal to the mode of
the elements of the input vector.
</p>
</dd>
<dt><a class="index-entry-id" id="index-reduc_005ffmax_005fscal_005fm-instruction-pattern"></a>
<a id="index-reduc_005ffmin_005fscal_005fm-instruction-pattern"></a><span>&lsquo;<samp class="samp">reduc_fmin_scal_<var class="var">m</var></samp>&rsquo;, &lsquo;<samp class="samp">reduc_fmax_scal_<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-reduc_005ffmin_005fscal_005fm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Find the floating-point minimum/maximum of the elements of a vector,
using the same rules as <code class="code">fmin<var class="var">m</var>3</code> and <code class="code">fmax<var class="var">m</var>3</code>.
Operand 1 is a vector of mode <var class="var">m</var> and operand 0 is the scalar
result, which has mode <code class="code">GET_MODE_INNER (<var class="var">m</var>)</code>.
</p>
</dd>
<dt><a id="index-reduc_005fplus_005fscal_005fm-instruction-pattern"></a><span>&lsquo;<samp class="samp">reduc_plus_scal_<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-reduc_005fplus_005fscal_005fm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Compute the sum of the elements of a vector. The vector is operand 1, and
operand 0 is the scalar result, with mode equal to the mode of the elements of
the input vector.
</p>
</dd>
<dt><a class="index-entry-id" id="index-reduc_005fior_005fscal_005fm-instruction-pattern"></a>
<a class="index-entry-id" id="index-reduc_005fxor_005fscal_005fm-instruction-pattern"></a>
<a id="index-reduc_005fand_005fscal_005fm-instruction-pattern"></a><span>&lsquo;<samp class="samp">reduc_and_scal_<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-reduc_005fand_005fscal_005fm-instruction-pattern"> &para;</a></span></dt>
<dt>&lsquo;<samp class="samp">reduc_ior_scal_<var class="var">m</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">reduc_xor_scal_<var class="var">m</var></samp>&rsquo;</dt>
<dd><p>Compute the bitwise <code class="code">AND</code>/<code class="code">IOR</code>/<code class="code">XOR</code> reduction of the elements
of a vector of mode <var class="var">m</var>.  Operand 1 is the vector input and operand 0
is the scalar result.  The mode of the scalar result is the same as one
element of <var class="var">m</var>.
</p>
</dd>
<dt><a id="index-extract_005flast_005fm-instruction-pattern"></a><span><code class="code">extract_last_<var class="var">m</var></code><a class="copiable-link" href="#index-extract_005flast_005fm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Find the last set bit in mask operand 1 and extract the associated element
of vector operand 2.  Store the result in scalar operand 0.  Operand 2
has vector mode <var class="var">m</var> while operand 0 has the mode appropriate for one
element of <var class="var">m</var>.  Operand 1 has the usual mask mode for vectors of mode
<var class="var">m</var>; see <code class="code">TARGET_VECTORIZE_GET_MASK_MODE</code>.
</p>
</dd>
<dt><a id="index-fold_005fextract_005flast_005fm-instruction-pattern"></a><span><code class="code">fold_extract_last_<var class="var">m</var></code><a class="copiable-link" href="#index-fold_005fextract_005flast_005fm-instruction-pattern"> &para;</a></span></dt>
<dd><p>If any bits of mask operand 2 are set, find the last set bit, extract
the associated element from vector operand 3, and store the result
in operand 0.  Store operand 1 in operand 0 otherwise.  Operand 3
has mode <var class="var">m</var> and operands 0 and 1 have the mode appropriate for
one element of <var class="var">m</var>.  Operand 2 has the usual mask mode for vectors
of mode <var class="var">m</var>; see <code class="code">TARGET_VECTORIZE_GET_MASK_MODE</code>.
</p>
</dd>
<dt><a id="index-len_005ffold_005fextract_005flast_005fm-instruction-pattern"></a><span><code class="code">len_fold_extract_last_<var class="var">m</var></code><a class="copiable-link" href="#index-len_005ffold_005fextract_005flast_005fm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Like &lsquo;<samp class="samp">fold_extract_last_<var class="var">m</var></samp>&rsquo;, but takes an extra length operand as
operand 4 and an extra bias operand as operand 5.  The last associated element
is extracted should have the index i &lt; len (operand 4) + bias (operand 5).
</p>
</dd>
<dt><a id="index-fold_005fleft_005fplus_005fm-instruction-pattern"></a><span><code class="code">fold_left_plus_<var class="var">m</var></code><a class="copiable-link" href="#index-fold_005fleft_005fplus_005fm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Take scalar operand 1 and successively add each element from vector
operand 2.  Store the result in scalar operand 0.  The vector has
mode <var class="var">m</var> and the scalars have the mode appropriate for one
element of <var class="var">m</var>.  The operation is strictly in-order: there is
no reassociation.
</p>
</dd>
<dt><a id="index-mask_005ffold_005fleft_005fplus_005fm-instruction-pattern"></a><span><code class="code">mask_fold_left_plus_<var class="var">m</var></code><a class="copiable-link" href="#index-mask_005ffold_005fleft_005fplus_005fm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Like &lsquo;<samp class="samp">fold_left_plus_<var class="var">m</var></samp>&rsquo;, but takes an additional mask operand
(operand 3) that specifies which elements of the source vector should be added.
</p>
</dd>
<dt><a id="index-mask_005flen_005ffold_005fleft_005fplus_005fm-instruction-pattern"></a><span><code class="code">mask_len_fold_left_plus_<var class="var">m</var></code><a class="copiable-link" href="#index-mask_005flen_005ffold_005fleft_005fplus_005fm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Like &lsquo;<samp class="samp">fold_left_plus_<var class="var">m</var></samp>&rsquo;, but takes an additional mask operand
(operand 3), len operand (operand 4) and bias operand (operand 5) that
performs following operations strictly in-order (no reassociation):
</p>
<div class="example smallexample">
<pre class="example-preformatted">operand0 = operand1;
for (i = 0; i &lt; LEN + BIAS; i++)
  if (operand3[i])
    operand0 += operand2[i];
</pre></div>

</dd>
<dt><a id="index-sdot_005fprodmn-instruction-pattern"></a><span>&lsquo;<samp class="samp">sdot_prod<var class="var">m</var><var class="var">n</var></samp>&rsquo;<a class="copiable-link" href="#index-sdot_005fprodmn-instruction-pattern"> &para;</a></span></dt>
<dd>
<p>Multiply operand 1 by operand 2 without loss of precision, given that
both operands contain signed elements.  Add each product to the overlapping
element of operand 3 and store the result in operand 0.  Operands 0 and 3
have mode <var class="var">m</var> and operands 1 and 2 have mode <var class="var">n</var>, with <var class="var">n</var>
having narrower elements than <var class="var">m</var>.
</p>
<p>Semantically the expressions perform the multiplication in the following signs
</p>
<div class="example smallexample">
<pre class="example-preformatted">sdot&lt;signed op0, signed op1, signed op2, signed op3&gt; ==
   op0 = sign-ext (op1) * sign-ext (op2) + op3
...
</pre></div>

</dd>
<dt><a id="index-udot_005fprodmn-instruction-pattern"></a><span>&lsquo;<samp class="samp">udot_prod<var class="var">m</var><var class="var">n</var></samp>&rsquo;<a class="copiable-link" href="#index-udot_005fprodmn-instruction-pattern"> &para;</a></span></dt>
<dd>
<p>Multiply operand 1 by operand 2 without loss of precision, given that
both operands contain unsigned elements.  Add each product to the overlapping
element of operand 3 and store the result in operand 0.  Operands 0 and 3
have mode <var class="var">m</var> and operands 1 and 2 have mode <var class="var">n</var>, with <var class="var">n</var>
having narrower elements than <var class="var">m</var>.
</p>
<p>Semantically the expressions perform the multiplication in the following signs
</p>
<div class="example smallexample">
<pre class="example-preformatted">udot&lt;unsigned op0, unsigned op1, unsigned op2, unsigned op3&gt; ==
   op0 = zero-ext (op1) * zero-ext (op2) + op3
...
</pre></div>

</dd>
<dt><a id="index-usdot_005fprodmn-instruction-pattern"></a><span>&lsquo;<samp class="samp">usdot_prod<var class="var">m</var><var class="var">n</var></samp>&rsquo;<a class="copiable-link" href="#index-usdot_005fprodmn-instruction-pattern"> &para;</a></span></dt>
<dd><p>Compute the sum of the products of elements of different signs.
Multiply operand 1 by operand 2 without loss of precision, given that operand 1
is unsigned and operand 2 is signed.  Add each product to the overlapping
element of operand 3 and store the result in operand 0.  Operands 0 and 3 have
mode <var class="var">m</var> and operands 1 and 2 have mode <var class="var">n</var>, with <var class="var">n</var> having
narrower elements than <var class="var">m</var>.
</p>
<p>Semantically the expressions perform the multiplication in the following signs
</p>
<div class="example smallexample">
<pre class="example-preformatted">usdot&lt;signed op0, unsigned op1, signed op2, signed op3&gt; ==
   op0 = ((signed-conv) zero-ext (op1)) * sign-ext (op2) + op3
...
</pre></div>

</dd>
<dt><a class="index-entry-id" id="index-usadm-instruction-pattern"></a>
<a id="index-ssadm-instruction-pattern"></a><span>&lsquo;<samp class="samp">ssad<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-ssadm-instruction-pattern"> &para;</a></span></dt>
<dt>&lsquo;<samp class="samp">usad<var class="var">m</var></samp>&rsquo;</dt>
<dd><p>Compute the sum of absolute differences of two signed/unsigned elements.
Operand 1 and operand 2 are of the same mode. Their absolute difference, which
is of a wider mode, is computed and added to operand 3. Operand 3 is of a mode
equal or wider than the mode of the absolute difference. The result is placed
in operand 0, which is of the same mode as operand 3.
<var class="var">m</var> is the mode of operand 1 and operand 2.
</p>
</dd>
<dt><a class="index-entry-id" id="index-widen_005fusumm3-instruction-pattern"></a>
<a id="index-widen_005fssumm3-instruction-pattern"></a><span>&lsquo;<samp class="samp">widen_ssum<var class="var">m</var>3</samp>&rsquo;<a class="copiable-link" href="#index-widen_005fssumm3-instruction-pattern"> &para;</a></span></dt>
<dt>&lsquo;<samp class="samp">widen_usum<var class="var">m</var>3</samp>&rsquo;</dt>
<dd><p>Operands 0 and 2 are of the same mode, which is wider than the mode of
operand 1. Add operand 1 to operand 2 and place the widened result in
operand 0. (This is used express accumulation of elements into an accumulator
of a wider mode.)
<var class="var">m</var> is the mode of operand 1.
</p>
</dd>
<dt><a class="index-entry-id" id="index-umulhsm3-instruction-pattern"></a>
<a id="index-smulhsm3-instruction-pattern"></a><span>&lsquo;<samp class="samp">smulhs<var class="var">m</var>3</samp>&rsquo;<a class="copiable-link" href="#index-smulhsm3-instruction-pattern"> &para;</a></span></dt>
<dt>&lsquo;<samp class="samp">umulhs<var class="var">m</var>3</samp>&rsquo;</dt>
<dd><p>Signed/unsigned multiply high with scale. This is equivalent to the C code:
</p><div class="example smallexample">
<pre class="example-preformatted">narrow op0, op1, op2;
...
op0 = (narrow) (((wide) op1 * (wide) op2) &gt;&gt; (N / 2 - 1));
</pre></div>
<p>where the sign of &lsquo;<samp class="samp">narrow</samp>&rsquo; determines whether this is a signed
or unsigned operation, and <var class="var">N</var> is the size of &lsquo;<samp class="samp">wide</samp>&rsquo; in bits.
<var class="var">m</var> is the mode for all 3 operands (narrow). The wide mode is not specified
and is defined to fit the whole multiply.
</p>
</dd>
<dt><a class="index-entry-id" id="index-umulhrsm3-instruction-pattern"></a>
<a id="index-smulhrsm3-instruction-pattern"></a><span>&lsquo;<samp class="samp">smulhrs<var class="var">m</var>3</samp>&rsquo;<a class="copiable-link" href="#index-smulhrsm3-instruction-pattern"> &para;</a></span></dt>
<dt>&lsquo;<samp class="samp">umulhrs<var class="var">m</var>3</samp>&rsquo;</dt>
<dd><p>Signed/unsigned multiply high with round and scale. This is
equivalent to the C code:
</p><div class="example smallexample">
<pre class="example-preformatted">narrow op0, op1, op2;
...
op0 = (narrow) (((((wide) op1 * (wide) op2) &gt;&gt; (N / 2 - 2)) + 1) &gt;&gt; 1);
</pre></div>
<p>where the sign of &lsquo;<samp class="samp">narrow</samp>&rsquo; determines whether this is a signed
or unsigned operation, and <var class="var">N</var> is the size of &lsquo;<samp class="samp">wide</samp>&rsquo; in bits.
<var class="var">m</var> is the mode for all 3 operands (narrow). The wide mode is not specified
and is defined to fit the whole multiply.
</p>
</dd>
<dt><a class="index-entry-id" id="index-sdiv_005fpow2m3-instruction-pattern-1"></a>
<a id="index-sdiv_005fpow2m3-instruction-pattern"></a><span>&lsquo;<samp class="samp">sdiv_pow2<var class="var">m</var>3</samp>&rsquo;<a class="copiable-link" href="#index-sdiv_005fpow2m3-instruction-pattern"> &para;</a></span></dt>
<dt>&lsquo;<samp class="samp">sdiv_pow2<var class="var">m</var>3</samp>&rsquo;</dt>
<dd><p>Signed division by power-of-2 immediate. Equivalent to:
</p><div class="example smallexample">
<pre class="example-preformatted">signed op0, op1;
...
op0 = op1 / (1 &lt;&lt; imm);
</pre></div>

</dd>
<dt><a id="index-vec_005fshl_005finsert_005fm-instruction-pattern"></a><span>&lsquo;<samp class="samp">vec_shl_insert_<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-vec_005fshl_005finsert_005fm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Shift the elements in vector input operand 1 left one element (i.e.
away from element 0) and fill the vacated element 0 with the scalar
in operand 2.  Store the result in vector output operand 0.  Operands
0 and 1 have mode <var class="var">m</var> and operand 2 has the mode appropriate for
one element of <var class="var">m</var>.
</p>
</dd>
<dt><a id="index-vec_005fshl_005fm-instruction-pattern"></a><span>&lsquo;<samp class="samp">vec_shl_<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-vec_005fshl_005fm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Whole vector left shift in bits, i.e. away from element 0.
Operand 1 is a vector to be shifted.
Operand 2 is an integer shift amount in bits.
Operand 0 is where the resulting shifted vector is stored.
The output and input vectors should have the same modes.
</p>
</dd>
<dt><a id="index-vec_005fshr_005fm-instruction-pattern"></a><span>&lsquo;<samp class="samp">vec_shr_<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-vec_005fshr_005fm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Whole vector right shift in bits, i.e. towards element 0.
Operand 1 is a vector to be shifted.
Operand 2 is an integer shift amount in bits.
Operand 0 is where the resulting shifted vector is stored.
The output and input vectors should have the same modes.
</p>
</dd>
<dt><a id="index-vec_005fpack_005ftrunc_005fm-instruction-pattern"></a><span>&lsquo;<samp class="samp">vec_pack_trunc_<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-vec_005fpack_005ftrunc_005fm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Narrow (demote) and merge the elements of two vectors. Operands 1 and 2
are vectors of the same mode having N integral or floating point elements
of size S.  Operand 0 is the resulting vector in which 2*N elements of
size S/2 are concatenated after narrowing them down using truncation.
</p>
</dd>
<dt><a id="index-vec_005fpack_005fsbool_005ftrunc_005fm-instruction-pattern"></a><span>&lsquo;<samp class="samp">vec_pack_sbool_trunc_<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-vec_005fpack_005fsbool_005ftrunc_005fm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Narrow and merge the elements of two vectors.  Operands 1 and 2 are vectors
of the same type having N boolean elements.  Operand 0 is the resulting
vector in which 2*N elements are concatenated.  The last operand (operand 3)
is the number of elements in the output vector 2*N as a <code class="code">CONST_INT</code>.
This instruction pattern is used when all the vector input and output
operands have the same scalar mode <var class="var">m</var> and thus using
<code class="code">vec_pack_trunc_<var class="var">m</var></code> would be ambiguous.
</p>
</dd>
<dt><a class="index-entry-id" id="index-vec_005fpack_005fusat_005fm-instruction-pattern"></a>
<a id="index-vec_005fpack_005fssat_005fm-instruction-pattern"></a><span>&lsquo;<samp class="samp">vec_pack_ssat_<var class="var">m</var></samp>&rsquo;, &lsquo;<samp class="samp">vec_pack_usat_<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-vec_005fpack_005fssat_005fm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Narrow (demote) and merge the elements of two vectors.  Operands 1 and 2
are vectors of the same mode having N integral elements of size S.
Operand 0 is the resulting vector in which the elements of the two input
vectors are concatenated after narrowing them down using signed/unsigned
saturating arithmetic.
</p>
</dd>
<dt><a class="index-entry-id" id="index-vec_005fpack_005fufix_005ftrunc_005fm-instruction-pattern"></a>
<a id="index-vec_005fpack_005fsfix_005ftrunc_005fm-instruction-pattern"></a><span>&lsquo;<samp class="samp">vec_pack_sfix_trunc_<var class="var">m</var></samp>&rsquo;, &lsquo;<samp class="samp">vec_pack_ufix_trunc_<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-vec_005fpack_005fsfix_005ftrunc_005fm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Narrow, convert to signed/unsigned integral type and merge the elements
of two vectors.  Operands 1 and 2 are vectors of the same mode having N
floating point elements of size S.  Operand 0 is the resulting vector
in which 2*N elements of size S/2 are concatenated.
</p>
</dd>
<dt><a class="index-entry-id" id="index-vec_005fpacku_005ffloat_005fm-instruction-pattern"></a>
<a id="index-vec_005fpacks_005ffloat_005fm-instruction-pattern"></a><span>&lsquo;<samp class="samp">vec_packs_float_<var class="var">m</var></samp>&rsquo;, &lsquo;<samp class="samp">vec_packu_float_<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-vec_005fpacks_005ffloat_005fm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Narrow, convert to floating point type and merge the elements
of two vectors.  Operands 1 and 2 are vectors of the same mode having N
signed/unsigned integral elements of size S.  Operand 0 is the resulting vector
in which 2*N elements of size S/2 are concatenated.
</p>
</dd>
<dt><a class="index-entry-id" id="index-vec_005funpacks_005flo_005fm-instruction-pattern"></a>
<a id="index-vec_005funpacks_005fhi_005fm-instruction-pattern"></a><span>&lsquo;<samp class="samp">vec_unpacks_hi_<var class="var">m</var></samp>&rsquo;, &lsquo;<samp class="samp">vec_unpacks_lo_<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-vec_005funpacks_005fhi_005fm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Extract and widen (promote) the high/low part of a vector of signed
integral or floating point elements.  The input vector (operand 1) has N
elements of size S.  Widen (promote) the high/low elements of the vector
using signed or floating point extension and place the resulting N/2
values of size 2*S in the output vector (operand 0).
</p>
</dd>
<dt><a class="index-entry-id" id="index-vec_005funpacku_005flo_005fm-instruction-pattern"></a>
<a id="index-vec_005funpacku_005fhi_005fm-instruction-pattern"></a><span>&lsquo;<samp class="samp">vec_unpacku_hi_<var class="var">m</var></samp>&rsquo;, &lsquo;<samp class="samp">vec_unpacku_lo_<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-vec_005funpacku_005fhi_005fm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Extract and widen (promote) the high/low part of a vector of unsigned
integral elements.  The input vector (operand 1) has N elements of size S.
Widen (promote) the high/low elements of the vector using zero extension and
place the resulting N/2 values of size 2*S in the output vector (operand 0).
</p>
</dd>
<dt><a class="index-entry-id" id="index-vec_005funpacks_005fsbool_005flo_005fm-instruction-pattern"></a>
<a id="index-vec_005funpacks_005fsbool_005fhi_005fm-instruction-pattern"></a><span>&lsquo;<samp class="samp">vec_unpacks_sbool_hi_<var class="var">m</var></samp>&rsquo;, &lsquo;<samp class="samp">vec_unpacks_sbool_lo_<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-vec_005funpacks_005fsbool_005fhi_005fm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Extract the high/low part of a vector of boolean elements that have scalar
mode <var class="var">m</var>.  The input vector (operand 1) has N elements, the output
vector (operand 0) has N/2 elements.  The last operand (operand 2) is the
number of elements of the input vector N as a <code class="code">CONST_INT</code>.  These
patterns are used if both the input and output vectors have the same scalar
mode <var class="var">m</var> and thus using <code class="code">vec_unpacks_hi_<var class="var">m</var></code> or
<code class="code">vec_unpacks_lo_<var class="var">m</var></code> would be ambiguous.
</p>
</dd>
<dt><a class="index-entry-id" id="index-vec_005funpacks_005ffloat_005flo_005fm-instruction-pattern"></a>
<a class="index-entry-id" id="index-vec_005funpacku_005ffloat_005fhi_005fm-instruction-pattern"></a>
<a class="index-entry-id" id="index-vec_005funpacku_005ffloat_005flo_005fm-instruction-pattern"></a>
<a id="index-vec_005funpacks_005ffloat_005fhi_005fm-instruction-pattern"></a><span>&lsquo;<samp class="samp">vec_unpacks_float_hi_<var class="var">m</var></samp>&rsquo;, &lsquo;<samp class="samp">vec_unpacks_float_lo_<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-vec_005funpacks_005ffloat_005fhi_005fm-instruction-pattern"> &para;</a></span></dt>
<dt>&lsquo;<samp class="samp">vec_unpacku_float_hi_<var class="var">m</var></samp>&rsquo;, &lsquo;<samp class="samp">vec_unpacku_float_lo_<var class="var">m</var></samp>&rsquo;</dt>
<dd><p>Extract, convert to floating point type and widen the high/low part of a
vector of signed/unsigned integral elements.  The input vector (operand 1)
has N elements of size S.  Convert the high/low elements of the vector using
floating point conversion and place the resulting N/2 values of size 2*S in
the output vector (operand 0).
</p>
</dd>
<dt><a class="index-entry-id" id="index-vec_005funpack_005fsfix_005ftrunc_005flo_005fm-instruction-pattern"></a>
<a class="index-entry-id" id="index-vec_005funpack_005fufix_005ftrunc_005fhi_005fm-instruction-pattern"></a>
<a class="index-entry-id" id="index-vec_005funpack_005fufix_005ftrunc_005flo_005fm-instruction-pattern"></a>
<a id="index-vec_005funpack_005fsfix_005ftrunc_005fhi_005fm-instruction-pattern"></a><span>&lsquo;<samp class="samp">vec_unpack_sfix_trunc_hi_<var class="var">m</var></samp>&rsquo;,<a class="copiable-link" href="#index-vec_005funpack_005fsfix_005ftrunc_005fhi_005fm-instruction-pattern"> &para;</a></span></dt>
<dt>&lsquo;<samp class="samp">vec_unpack_sfix_trunc_lo_<var class="var">m</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">vec_unpack_ufix_trunc_hi_<var class="var">m</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">vec_unpack_ufix_trunc_lo_<var class="var">m</var></samp>&rsquo;</dt>
<dd><p>Extract, convert to signed/unsigned integer type and widen the high/low part of a
vector of floating point elements.  The input vector (operand 1)
has N elements of size S.  Convert the high/low elements of the vector
to integers and place the resulting N/2 values of size 2*S in
the output vector (operand 0).
</p>
</dd>
<dt><a class="index-entry-id" id="index-vec_005fwiden_005fumult_005flo_005fm-instruction-pattern"></a>
<a class="index-entry-id" id="index-vec_005fwiden_005fsmult_005fhi_005fm-instruction-pattern"></a>
<a class="index-entry-id" id="index-vec_005fwiden_005fsmult_005flo_005fm-instruction-pattern"></a>
<a class="index-entry-id" id="index-vec_005fwiden_005fumult_005feven_005fm-instruction-pattern"></a>
<a class="index-entry-id" id="index-vec_005fwiden_005fumult_005fodd_005fm-instruction-pattern"></a>
<a class="index-entry-id" id="index-vec_005fwiden_005fsmult_005feven_005fm-instruction-pattern"></a>
<a class="index-entry-id" id="index-vec_005fwiden_005fsmult_005fodd_005fm-instruction-pattern"></a>
<a id="index-vec_005fwiden_005fumult_005fhi_005fm-instruction-pattern"></a><span>&lsquo;<samp class="samp">vec_widen_umult_hi_<var class="var">m</var></samp>&rsquo;, &lsquo;<samp class="samp">vec_widen_umult_lo_<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-vec_005fwiden_005fumult_005fhi_005fm-instruction-pattern"> &para;</a></span></dt>
<dt>&lsquo;<samp class="samp">vec_widen_smult_hi_<var class="var">m</var></samp>&rsquo;, &lsquo;<samp class="samp">vec_widen_smult_lo_<var class="var">m</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">vec_widen_umult_even_<var class="var">m</var></samp>&rsquo;, &lsquo;<samp class="samp">vec_widen_umult_odd_<var class="var">m</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">vec_widen_smult_even_<var class="var">m</var></samp>&rsquo;, &lsquo;<samp class="samp">vec_widen_smult_odd_<var class="var">m</var></samp>&rsquo;</dt>
<dd><p>Signed/Unsigned widening multiplication.  The two inputs (operands 1 and 2)
are vectors with N signed/unsigned elements of size S.  Multiply the high/low
or even/odd elements of the two vectors, and put the N/2 products of size 2*S
in the output vector (operand 0). A target shouldn&rsquo;t implement even/odd pattern
pair if it is less efficient than lo/hi one.
</p>
</dd>
<dt><a class="index-entry-id" id="index-vec_005fwiden_005fushiftl_005flo_005fm-instruction-pattern"></a>
<a class="index-entry-id" id="index-vec_005fwiden_005fsshiftl_005fhi_005fm-instruction-pattern"></a>
<a class="index-entry-id" id="index-vec_005fwiden_005fsshiftl_005flo_005fm-instruction-pattern"></a>
<a id="index-vec_005fwiden_005fushiftl_005fhi_005fm-instruction-pattern"></a><span>&lsquo;<samp class="samp">vec_widen_ushiftl_hi_<var class="var">m</var></samp>&rsquo;, &lsquo;<samp class="samp">vec_widen_ushiftl_lo_<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-vec_005fwiden_005fushiftl_005fhi_005fm-instruction-pattern"> &para;</a></span></dt>
<dt>&lsquo;<samp class="samp">vec_widen_sshiftl_hi_<var class="var">m</var></samp>&rsquo;, &lsquo;<samp class="samp">vec_widen_sshiftl_lo_<var class="var">m</var></samp>&rsquo;</dt>
<dd><p>Signed/Unsigned widening shift left.  The first input (operand 1) is a vector
with N signed/unsigned elements of size S.  Operand 2 is a constant.  Shift
the high/low elements of operand 1, and put the N/2 results of size 2*S in the
output vector (operand 0).
</p>
</dd>
<dt><a class="index-entry-id" id="index-vec_005fwiden_005fsaddl_005flo_005fm-instruction-pattern"></a>
<a class="index-entry-id" id="index-vec_005fwiden_005fuaddl_005fhi_005fm-instruction-pattern"></a>
<a class="index-entry-id" id="index-vec_005fwiden_005fuaddl_005flo_005fm-instruction-pattern"></a>
<a id="index-vec_005fwiden_005fsaddl_005fhi_005fm-instruction-pattern"></a><span>&lsquo;<samp class="samp">vec_widen_uaddl_hi_<var class="var">m</var></samp>&rsquo;, &lsquo;<samp class="samp">vec_widen_uaddl_lo_<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-vec_005fwiden_005fsaddl_005fhi_005fm-instruction-pattern"> &para;</a></span></dt>
<dt>&lsquo;<samp class="samp">vec_widen_saddl_hi_<var class="var">m</var></samp>&rsquo;, &lsquo;<samp class="samp">vec_widen_saddl_lo_<var class="var">m</var></samp>&rsquo;</dt>
<dd><p>Signed/Unsigned widening add long.  Operands 1 and 2 are vectors with N
signed/unsigned elements of size S.  Add the high/low elements of 1 and 2
together, widen the resulting elements and put the N/2 results of size 2*S in
the output vector (operand 0).
</p>
</dd>
<dt><a class="index-entry-id" id="index-vec_005fwiden_005fssubl_005flo_005fm-instruction-pattern"></a>
<a class="index-entry-id" id="index-vec_005fwiden_005fusubl_005fhi_005fm-instruction-pattern"></a>
<a class="index-entry-id" id="index-vec_005fwiden_005fusubl_005flo_005fm-instruction-pattern"></a>
<a id="index-vec_005fwiden_005fssubl_005fhi_005fm-instruction-pattern"></a><span>&lsquo;<samp class="samp">vec_widen_usubl_hi_<var class="var">m</var></samp>&rsquo;, &lsquo;<samp class="samp">vec_widen_usubl_lo_<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-vec_005fwiden_005fssubl_005fhi_005fm-instruction-pattern"> &para;</a></span></dt>
<dt>&lsquo;<samp class="samp">vec_widen_ssubl_hi_<var class="var">m</var></samp>&rsquo;, &lsquo;<samp class="samp">vec_widen_ssubl_lo_<var class="var">m</var></samp>&rsquo;</dt>
<dd><p>Signed/Unsigned widening subtract long.  Operands 1 and 2 are vectors with N
signed/unsigned elements of size S.  Subtract the high/low elements of 2 from
1 and widen the resulting elements. Put the N/2 results of size 2*S in the
output vector (operand 0).
</p>
</dd>
<dt><a class="index-entry-id" id="index-vec_005fwiden_005fsabd_005flo_005fm-instruction-pattern"></a>
<a class="index-entry-id" id="index-vec_005fwiden_005fsabd_005fodd_005fm-instruction-pattern"></a>
<a class="index-entry-id" id="index-vec_005fwiden_005fsabd_005feven_005fm-instruction-pattern"></a>
<a class="index-entry-id" id="index-vec_005fwiden_005fuabd_005fhi_005fm-instruction-pattern"></a>
<a class="index-entry-id" id="index-vec_005fwiden_005fuabd_005flo_005fm-instruction-pattern"></a>
<a class="index-entry-id" id="index-vec_005fwiden_005fuabd_005fodd_005fm-instruction-pattern"></a>
<a class="index-entry-id" id="index-vec_005fwiden_005fuabd_005feven_005fm-instruction-pattern"></a>
<a id="index-vec_005fwiden_005fsabd_005fhi_005fm-instruction-pattern"></a><span>&lsquo;<samp class="samp">vec_widen_uabd_hi_<var class="var">m</var></samp>&rsquo;, &lsquo;<samp class="samp">vec_widen_uabd_lo_<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-vec_005fwiden_005fsabd_005fhi_005fm-instruction-pattern"> &para;</a></span></dt>
<dt>&lsquo;<samp class="samp">vec_widen_uabd_odd_<var class="var">m</var></samp>&rsquo;, &lsquo;<samp class="samp">vec_widen_uabd_even_<var class="var">m</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">vec_widen_sabd_hi_<var class="var">m</var></samp>&rsquo;, &lsquo;<samp class="samp">vec_widen_sabd_lo_<var class="var">m</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">vec_widen_sabd_odd_<var class="var">m</var></samp>&rsquo;, &lsquo;<samp class="samp">vec_widen_sabd_even_<var class="var">m</var></samp>&rsquo;</dt>
<dd><p>Signed/Unsigned widening absolute difference.  Operands 1 and 2 are
vectors with N signed/unsigned elements of size S.  Find the absolute
difference between operands 1 and 2 and widen the resulting elements.
Put the N/2 results of size 2*S in the output vector (operand 0).
</p>
</dd>
<dt><a id="index-vec_005faddsubm3-instruction-pattern"></a><span>&lsquo;<samp class="samp">vec_addsub<var class="var">m</var>3</samp>&rsquo;<a class="copiable-link" href="#index-vec_005faddsubm3-instruction-pattern"> &para;</a></span></dt>
<dd><p>Alternating subtract, add with even lanes doing subtract and odd
lanes doing addition.  Operands 1 and 2 and the outout operand are vectors
with mode <var class="var">m</var>.
</p>
</dd>
<dt><a id="index-vec_005ffmaddsubm4-instruction-pattern"></a><span>&lsquo;<samp class="samp">vec_fmaddsub<var class="var">m</var>4</samp>&rsquo;<a class="copiable-link" href="#index-vec_005ffmaddsubm4-instruction-pattern"> &para;</a></span></dt>
<dd><p>Alternating multiply subtract, add with even lanes doing subtract and odd
lanes doing addition of the third operand to the multiplication result
of the first two operands.  Operands 1, 2 and 3 and the outout operand are vectors
with mode <var class="var">m</var>.
</p>
</dd>
<dt><a id="index-vec_005ffmsubaddm4-instruction-pattern"></a><span>&lsquo;<samp class="samp">vec_fmsubadd<var class="var">m</var>4</samp>&rsquo;<a class="copiable-link" href="#index-vec_005ffmsubaddm4-instruction-pattern"> &para;</a></span></dt>
<dd><p>Alternating multiply add, subtract with even lanes doing addition and odd
lanes doing subtraction of the third operand to the multiplication result
of the first two operands.  Operands 1, 2 and 3 and the outout operand are vectors
with mode <var class="var">m</var>.
</p>
<p>These instructions are not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-mulhisi3-instruction-pattern"></a><span>&lsquo;<samp class="samp">mulhisi3</samp>&rsquo;<a class="copiable-link" href="#index-mulhisi3-instruction-pattern"> &para;</a></span></dt>
<dd><p>Multiply operands 1 and 2, which have mode <code class="code">HImode</code>, and store
a <code class="code">SImode</code> product in operand 0.
</p>
</dd>
<dt><a class="index-entry-id" id="index-mulsidi3-instruction-pattern"></a>
<a id="index-mulqihi3-instruction-pattern"></a><span>&lsquo;<samp class="samp">mulqihi3</samp>&rsquo;, &lsquo;<samp class="samp">mulsidi3</samp>&rsquo;<a class="copiable-link" href="#index-mulqihi3-instruction-pattern"> &para;</a></span></dt>
<dd><p>Similar widening-multiplication instructions of other widths.
</p>
</dd>
<dt><a class="index-entry-id" id="index-umulhisi3-instruction-pattern"></a>
<a class="index-entry-id" id="index-umulsidi3-instruction-pattern"></a>
<a id="index-umulqihi3-instruction-pattern"></a><span>&lsquo;<samp class="samp">umulqihi3</samp>&rsquo;, &lsquo;<samp class="samp">umulhisi3</samp>&rsquo;, &lsquo;<samp class="samp">umulsidi3</samp>&rsquo;<a class="copiable-link" href="#index-umulqihi3-instruction-pattern"> &para;</a></span></dt>
<dd><p>Similar widening-multiplication instructions that do unsigned
multiplication.
</p>
</dd>
<dt><a class="index-entry-id" id="index-usmulhisi3-instruction-pattern"></a>
<a class="index-entry-id" id="index-usmulsidi3-instruction-pattern"></a>
<a id="index-usmulqihi3-instruction-pattern"></a><span>&lsquo;<samp class="samp">usmulqihi3</samp>&rsquo;, &lsquo;<samp class="samp">usmulhisi3</samp>&rsquo;, &lsquo;<samp class="samp">usmulsidi3</samp>&rsquo;<a class="copiable-link" href="#index-usmulqihi3-instruction-pattern"> &para;</a></span></dt>
<dd><p>Similar widening-multiplication instructions that interpret the first
operand as unsigned and the second operand as signed, then do a signed
multiplication.
</p>
</dd>
<dt><a id="index-smulm3_005fhighpart-instruction-pattern"></a><span>&lsquo;<samp class="samp">smul<var class="var">m</var>3_highpart</samp>&rsquo;<a class="copiable-link" href="#index-smulm3_005fhighpart-instruction-pattern"> &para;</a></span></dt>
<dd><p>Perform a signed multiplication of operands 1 and 2, which have mode
<var class="var">m</var>, and store the most significant half of the product in operand 0.
The least significant half of the product is discarded.  This may be
represented in RTL using a <code class="code">smul_highpart</code> RTX expression.
</p>
</dd>
<dt><a id="index-umulm3_005fhighpart-instruction-pattern"></a><span>&lsquo;<samp class="samp">umul<var class="var">m</var>3_highpart</samp>&rsquo;<a class="copiable-link" href="#index-umulm3_005fhighpart-instruction-pattern"> &para;</a></span></dt>
<dd><p>Similar, but the multiplication is unsigned.  This may be represented
in RTL using an <code class="code">umul_highpart</code> RTX expression.
</p>
</dd>
<dt><a id="index-maddmn4-instruction-pattern"></a><span>&lsquo;<samp class="samp">madd<var class="var">m</var><var class="var">n</var>4</samp>&rsquo;<a class="copiable-link" href="#index-maddmn4-instruction-pattern"> &para;</a></span></dt>
<dd><p>Multiply operands 1 and 2, sign-extend them to mode <var class="var">n</var>, add
operand 3, and store the result in operand 0.  Operands 1 and 2
have mode <var class="var">m</var> and operands 0 and 3 have mode <var class="var">n</var>.
Both modes must be integer or fixed-point modes and <var class="var">n</var> must be twice
the size of <var class="var">m</var>.
</p>
<p>In other words, <code class="code">madd<var class="var">m</var><var class="var">n</var>4</code> is like
<code class="code">mul<var class="var">m</var><var class="var">n</var>3</code> except that it also adds operand 3.
</p>
<p>These instructions are not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-umaddmn4-instruction-pattern"></a><span>&lsquo;<samp class="samp">umadd<var class="var">m</var><var class="var">n</var>4</samp>&rsquo;<a class="copiable-link" href="#index-umaddmn4-instruction-pattern"> &para;</a></span></dt>
<dd><p>Like <code class="code">madd<var class="var">m</var><var class="var">n</var>4</code>, but zero-extend the multiplication
operands instead of sign-extending them.
</p>
</dd>
<dt><a id="index-ssmaddmn4-instruction-pattern"></a><span>&lsquo;<samp class="samp">ssmadd<var class="var">m</var><var class="var">n</var>4</samp>&rsquo;<a class="copiable-link" href="#index-ssmaddmn4-instruction-pattern"> &para;</a></span></dt>
<dd><p>Like <code class="code">madd<var class="var">m</var><var class="var">n</var>4</code>, but all involved operations must be
signed-saturating.
</p>
</dd>
<dt><a id="index-usmaddmn4-instruction-pattern"></a><span>&lsquo;<samp class="samp">usmadd<var class="var">m</var><var class="var">n</var>4</samp>&rsquo;<a class="copiable-link" href="#index-usmaddmn4-instruction-pattern"> &para;</a></span></dt>
<dd><p>Like <code class="code">umadd<var class="var">m</var><var class="var">n</var>4</code>, but all involved operations must be
unsigned-saturating.
</p>
</dd>
<dt><a id="index-msubmn4-instruction-pattern"></a><span>&lsquo;<samp class="samp">msub<var class="var">m</var><var class="var">n</var>4</samp>&rsquo;<a class="copiable-link" href="#index-msubmn4-instruction-pattern"> &para;</a></span></dt>
<dd><p>Multiply operands 1 and 2, sign-extend them to mode <var class="var">n</var>, subtract the
result from operand 3, and store the result in operand 0.  Operands 1 and 2
have mode <var class="var">m</var> and operands 0 and 3 have mode <var class="var">n</var>.
Both modes must be integer or fixed-point modes and <var class="var">n</var> must be twice
the size of <var class="var">m</var>.
</p>
<p>In other words, <code class="code">msub<var class="var">m</var><var class="var">n</var>4</code> is like
<code class="code">mul<var class="var">m</var><var class="var">n</var>3</code> except that it also subtracts the result
from operand 3.
</p>
<p>These instructions are not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-umsubmn4-instruction-pattern"></a><span>&lsquo;<samp class="samp">umsub<var class="var">m</var><var class="var">n</var>4</samp>&rsquo;<a class="copiable-link" href="#index-umsubmn4-instruction-pattern"> &para;</a></span></dt>
<dd><p>Like <code class="code">msub<var class="var">m</var><var class="var">n</var>4</code>, but zero-extend the multiplication
operands instead of sign-extending them.
</p>
</dd>
<dt><a id="index-ssmsubmn4-instruction-pattern"></a><span>&lsquo;<samp class="samp">ssmsub<var class="var">m</var><var class="var">n</var>4</samp>&rsquo;<a class="copiable-link" href="#index-ssmsubmn4-instruction-pattern"> &para;</a></span></dt>
<dd><p>Like <code class="code">msub<var class="var">m</var><var class="var">n</var>4</code>, but all involved operations must be
signed-saturating.
</p>
</dd>
<dt><a id="index-usmsubmn4-instruction-pattern"></a><span>&lsquo;<samp class="samp">usmsub<var class="var">m</var><var class="var">n</var>4</samp>&rsquo;<a class="copiable-link" href="#index-usmsubmn4-instruction-pattern"> &para;</a></span></dt>
<dd><p>Like <code class="code">umsub<var class="var">m</var><var class="var">n</var>4</code>, but all involved operations must be
unsigned-saturating.
</p>
</dd>
<dt><a id="index-divmodm4-instruction-pattern"></a><span>&lsquo;<samp class="samp">divmod<var class="var">m</var>4</samp>&rsquo;<a class="copiable-link" href="#index-divmodm4-instruction-pattern"> &para;</a></span></dt>
<dd><p>Signed division that produces both a quotient and a remainder.
Operand 1 is divided by operand 2 to produce a quotient stored
in operand 0 and a remainder stored in operand 3.
</p>
<p>For machines with an instruction that produces both a quotient and a
remainder, provide a pattern for &lsquo;<samp class="samp">divmod<var class="var">m</var>4</samp>&rsquo; but do not
provide patterns for &lsquo;<samp class="samp">div<var class="var">m</var>3</samp>&rsquo; and &lsquo;<samp class="samp">mod<var class="var">m</var>3</samp>&rsquo;.  This
allows optimization in the relatively common case when both the quotient
and remainder are computed.
</p>
<p>If an instruction that just produces a quotient or just a remainder
exists and is more efficient than the instruction that produces both,
write the output routine of &lsquo;<samp class="samp">divmod<var class="var">m</var>4</samp>&rsquo; to call
<code class="code">find_reg_note</code> and look for a <code class="code">REG_UNUSED</code> note on the
quotient or remainder and generate the appropriate instruction.
</p>
</dd>
<dt><a id="index-udivmodm4-instruction-pattern"></a><span>&lsquo;<samp class="samp">udivmod<var class="var">m</var>4</samp>&rsquo;<a class="copiable-link" href="#index-udivmodm4-instruction-pattern"> &para;</a></span></dt>
<dd><p>Similar, but does unsigned division.
</p>
<a class="anchor" id="shift-patterns"></a></dd>
<dt><a class="index-entry-id" id="index-ssashlm3-instruction-pattern"></a>
<a class="index-entry-id" id="index-usashlm3-instruction-pattern"></a>
<a id="index-ashlm3-instruction-pattern"></a><span>&lsquo;<samp class="samp">ashl<var class="var">m</var>3</samp>&rsquo;, &lsquo;<samp class="samp">ssashl<var class="var">m</var>3</samp>&rsquo;, &lsquo;<samp class="samp">usashl<var class="var">m</var>3</samp>&rsquo;<a class="copiable-link" href="#index-ashlm3-instruction-pattern"> &para;</a></span></dt>
<dd><p>Arithmetic-shift operand 1 left by a number of bits specified by operand
2, and store the result in operand 0.  Here <var class="var">m</var> is the mode of
operand 0 and operand 1; operand 2&rsquo;s mode is specified by the
instruction pattern, and the compiler will convert the operand to that
mode before generating the instruction.  The shift or rotate expander
or instruction pattern should explicitly specify the mode of the operand 2,
it should never be <code class="code">VOIDmode</code>.  The meaning of out-of-range shift
counts can optionally be specified by <code class="code">TARGET_SHIFT_TRUNCATION_MASK</code>.
See <a class="xref" href="Misc.html#TARGET_005fSHIFT_005fTRUNCATION_005fMASK">TARGET_SHIFT_TRUNCATION_MASK</a>.  Operand 2 is always a scalar type.
</p>
</dd>
<dt><a class="index-entry-id" id="index-lshrm3-instruction-pattern"></a>
<a class="index-entry-id" id="index-rotlm3-instruction-pattern"></a>
<a class="index-entry-id" id="index-rotrm3-instruction-pattern"></a>
<a id="index-ashrm3-instruction-pattern"></a><span>&lsquo;<samp class="samp">ashr<var class="var">m</var>3</samp>&rsquo;, &lsquo;<samp class="samp">lshr<var class="var">m</var>3</samp>&rsquo;, &lsquo;<samp class="samp">rotl<var class="var">m</var>3</samp>&rsquo;, &lsquo;<samp class="samp">rotr<var class="var">m</var>3</samp>&rsquo;<a class="copiable-link" href="#index-ashrm3-instruction-pattern"> &para;</a></span></dt>
<dd><p>Other shift and rotate instructions, analogous to the
<code class="code">ashl<var class="var">m</var>3</code> instructions.  Operand 2 is always a scalar type.
</p>
</dd>
<dt><a class="index-entry-id" id="index-vashrm3-instruction-pattern"></a>
<a class="index-entry-id" id="index-vlshrm3-instruction-pattern"></a>
<a class="index-entry-id" id="index-vrotlm3-instruction-pattern"></a>
<a class="index-entry-id" id="index-vrotrm3-instruction-pattern"></a>
<a id="index-vashlm3-instruction-pattern"></a><span>&lsquo;<samp class="samp">vashl<var class="var">m</var>3</samp>&rsquo;, &lsquo;<samp class="samp">vashr<var class="var">m</var>3</samp>&rsquo;, &lsquo;<samp class="samp">vlshr<var class="var">m</var>3</samp>&rsquo;, &lsquo;<samp class="samp">vrotl<var class="var">m</var>3</samp>&rsquo;, &lsquo;<samp class="samp">vrotr<var class="var">m</var>3</samp>&rsquo;<a class="copiable-link" href="#index-vashlm3-instruction-pattern"> &para;</a></span></dt>
<dd><p>Vector shift and rotate instructions that take vectors as operand 2
instead of a scalar type.
</p>
</dd>
<dt><a class="index-entry-id" id="index-sabdm3-instruction-pattern"></a>
<a id="index-uabdm3-instruction-pattern"></a><span>&lsquo;<samp class="samp">uabd<var class="var">m</var></samp>&rsquo;, &lsquo;<samp class="samp">sabd<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-uabdm3-instruction-pattern"> &para;</a></span></dt>
<dd><p>Signed and unsigned absolute difference instructions.  These
instructions find the difference between operands 1 and 2
then return the absolute value.  A C code equivalent would be:
</p><div class="example smallexample">
<pre class="example-preformatted">op0 = op1 &gt; op2 ? op1 - op2 : op2 - op1;
</pre></div>

</dd>
<dt><a class="index-entry-id" id="index-uavgm3_005ffloor-instruction-pattern"></a>
<a id="index-avgm3_005ffloor-instruction-pattern"></a><span>&lsquo;<samp class="samp">avg<var class="var">m</var>3_floor</samp>&rsquo;<a class="copiable-link" href="#index-avgm3_005ffloor-instruction-pattern"> &para;</a></span></dt>
<dt>&lsquo;<samp class="samp">uavg<var class="var">m</var>3_floor</samp>&rsquo;</dt>
<dd><p>Signed and unsigned average instructions.  These instructions add
operands 1 and 2 without truncation, divide the result by 2,
round towards -Inf, and store the result in operand 0.  This is
equivalent to the C code:
</p><div class="example smallexample">
<pre class="example-preformatted">narrow op0, op1, op2;
...
op0 = (narrow) (((wide) op1 + (wide) op2) &gt;&gt; 1);
</pre></div>
<p>where the sign of &lsquo;<samp class="samp">narrow</samp>&rsquo; determines whether this is a signed
or unsigned operation.
</p>
</dd>
<dt><a class="index-entry-id" id="index-uavgm3_005fceil-instruction-pattern"></a>
<a id="index-avgm3_005fceil-instruction-pattern"></a><span>&lsquo;<samp class="samp">avg<var class="var">m</var>3_ceil</samp>&rsquo;<a class="copiable-link" href="#index-avgm3_005fceil-instruction-pattern"> &para;</a></span></dt>
<dt>&lsquo;<samp class="samp">uavg<var class="var">m</var>3_ceil</samp>&rsquo;</dt>
<dd><p>Like &lsquo;<samp class="samp">avg<var class="var">m</var>3_floor</samp>&rsquo; and &lsquo;<samp class="samp">uavg<var class="var">m</var>3_floor</samp>&rsquo;, but round
towards +Inf.  This is equivalent to the C code:
</p><div class="example smallexample">
<pre class="example-preformatted">narrow op0, op1, op2;
...
op0 = (narrow) (((wide) op1 + (wide) op2 + 1) &gt;&gt; 1);
</pre></div>

</dd>
<dt><a id="index-bswapm2-instruction-pattern"></a><span>&lsquo;<samp class="samp">bswap<var class="var">m</var>2</samp>&rsquo;<a class="copiable-link" href="#index-bswapm2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Reverse the order of bytes of operand 1 and store the result in operand 0.
</p>
</dd>
<dt><a class="index-entry-id" id="index-ssnegm2-instruction-pattern"></a>
<a class="index-entry-id" id="index-usnegm2-instruction-pattern"></a>
<a id="index-negm2-instruction-pattern"></a><span>&lsquo;<samp class="samp">neg<var class="var">m</var>2</samp>&rsquo;, &lsquo;<samp class="samp">ssneg<var class="var">m</var>2</samp>&rsquo;, &lsquo;<samp class="samp">usneg<var class="var">m</var>2</samp>&rsquo;<a class="copiable-link" href="#index-negm2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Negate operand 1 and store the result in operand 0.
</p>
</dd>
<dt><a id="index-negvm3-instruction-pattern"></a><span>&lsquo;<samp class="samp">negv<var class="var">m</var>3</samp>&rsquo;<a class="copiable-link" href="#index-negvm3-instruction-pattern"> &para;</a></span></dt>
<dd><p>Like <code class="code">neg<var class="var">m</var>2</code> but takes a <code class="code">code_label</code> as operand 2 and
emits code to jump to it if signed overflow occurs during the negation.
</p>
</dd>
<dt><a id="index-absm2-instruction-pattern"></a><span>&lsquo;<samp class="samp">abs<var class="var">m</var>2</samp>&rsquo;<a class="copiable-link" href="#index-absm2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Store the absolute value of operand 1 into operand 0.
</p>
</dd>
<dt><a id="index-sqrtm2-instruction-pattern"></a><span>&lsquo;<samp class="samp">sqrt<var class="var">m</var>2</samp>&rsquo;<a class="copiable-link" href="#index-sqrtm2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Store the square root of operand 1 into operand 0.  Both operands have
mode <var class="var">m</var>, which is a scalar or vector floating-point mode.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-rsqrtm2-instruction-pattern"></a><span>&lsquo;<samp class="samp">rsqrt<var class="var">m</var>2</samp>&rsquo;<a class="copiable-link" href="#index-rsqrtm2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Store the reciprocal of the square root of operand 1 into operand 0.
Both operands have mode <var class="var">m</var>, which is a scalar or vector
floating-point mode.
</p>
<p>On most architectures this pattern is only approximate, so either
its C condition or the <code class="code">TARGET_OPTAB_SUPPORTED_P</code> hook should
check for the appropriate math flags.  (Using the C condition is
more direct, but using <code class="code">TARGET_OPTAB_SUPPORTED_P</code> can be useful
if a target-specific built-in also uses the &lsquo;<samp class="samp">rsqrt<var class="var">m</var>2</samp>&rsquo;
pattern.)
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-fmodm3-instruction-pattern"></a><span>&lsquo;<samp class="samp">fmod<var class="var">m</var>3</samp>&rsquo;<a class="copiable-link" href="#index-fmodm3-instruction-pattern"> &para;</a></span></dt>
<dd><p>Store the remainder of dividing operand 1 by operand 2 into
operand 0, rounded towards zero to an integer.  All operands have
mode <var class="var">m</var>, which is a scalar or vector floating-point mode.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-remainderm3-instruction-pattern"></a><span>&lsquo;<samp class="samp">remainder<var class="var">m</var>3</samp>&rsquo;<a class="copiable-link" href="#index-remainderm3-instruction-pattern"> &para;</a></span></dt>
<dd><p>Store the remainder of dividing operand 1 by operand 2 into
operand 0, rounded to the nearest integer.  All operands have
mode <var class="var">m</var>, which is a scalar or vector floating-point mode.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-scalbm3-instruction-pattern"></a><span>&lsquo;<samp class="samp">scalb<var class="var">m</var>3</samp>&rsquo;<a class="copiable-link" href="#index-scalbm3-instruction-pattern"> &para;</a></span></dt>
<dd><p>Raise <code class="code">FLT_RADIX</code> to the power of operand 2, multiply it by
operand 1, and store the result in operand 0.  All operands have
mode <var class="var">m</var>, which is a scalar or vector floating-point mode.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-ldexpm3-instruction-pattern"></a><span>&lsquo;<samp class="samp">ldexp<var class="var">m</var>3</samp>&rsquo;<a class="copiable-link" href="#index-ldexpm3-instruction-pattern"> &para;</a></span></dt>
<dd><p>Raise 2 to the power of operand 2, multiply it by operand 1, and store
the result in operand 0.  Operands 0 and 1 have mode <var class="var">m</var>, which is
a scalar or vector floating-point mode.  Operand 2&rsquo;s mode has
the same number of elements as <var class="var">m</var> and each element is wide
enough to store an <code class="code">int</code>.  The integers are signed.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-cosm2-instruction-pattern"></a><span>&lsquo;<samp class="samp">cos<var class="var">m</var>2</samp>&rsquo;<a class="copiable-link" href="#index-cosm2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Store the cosine of operand 1 into operand 0.  Both operands have
mode <var class="var">m</var>, which is a scalar or vector floating-point mode.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-sinm2-instruction-pattern"></a><span>&lsquo;<samp class="samp">sin<var class="var">m</var>2</samp>&rsquo;<a class="copiable-link" href="#index-sinm2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Store the sine of operand 1 into operand 0.  Both operands have
mode <var class="var">m</var>, which is a scalar or vector floating-point mode.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-sincosm3-instruction-pattern"></a><span>&lsquo;<samp class="samp">sincos<var class="var">m</var>3</samp>&rsquo;<a class="copiable-link" href="#index-sincosm3-instruction-pattern"> &para;</a></span></dt>
<dd><p>Store the cosine of operand 2 into operand 0 and the sine of
operand 2 into operand 1.  All operands have mode <var class="var">m</var>,
which is a scalar or vector floating-point mode.
</p>
<p>Targets that can calculate the sine and cosine simultaneously can
implement this pattern as opposed to implementing individual
<code class="code">sin<var class="var">m</var>2</code> and <code class="code">cos<var class="var">m</var>2</code> patterns.  The <code class="code">sin</code>
and <code class="code">cos</code> built-in functions will then be expanded to the
<code class="code">sincos<var class="var">m</var>3</code> pattern, with one of the output values
left unused.
</p>
</dd>
<dt><a id="index-tanm2-instruction-pattern"></a><span>&lsquo;<samp class="samp">tan<var class="var">m</var>2</samp>&rsquo;<a class="copiable-link" href="#index-tanm2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Store the tangent of operand 1 into operand 0.  Both operands have
mode <var class="var">m</var>, which is a scalar or vector floating-point mode.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-asinm2-instruction-pattern"></a><span>&lsquo;<samp class="samp">asin<var class="var">m</var>2</samp>&rsquo;<a class="copiable-link" href="#index-asinm2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Store the arc sine of operand 1 into operand 0.  Both operands have
mode <var class="var">m</var>, which is a scalar or vector floating-point mode.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-acosm2-instruction-pattern"></a><span>&lsquo;<samp class="samp">acos<var class="var">m</var>2</samp>&rsquo;<a class="copiable-link" href="#index-acosm2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Store the arc cosine of operand 1 into operand 0.  Both operands have
mode <var class="var">m</var>, which is a scalar or vector floating-point mode.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-atanm2-instruction-pattern"></a><span>&lsquo;<samp class="samp">atan<var class="var">m</var>2</samp>&rsquo;<a class="copiable-link" href="#index-atanm2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Store the arc tangent of operand 1 into operand 0.  Both operands have
mode <var class="var">m</var>, which is a scalar or vector floating-point mode.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-fegetroundm-instruction-pattern"></a><span>&lsquo;<samp class="samp">fegetround<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-fegetroundm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Store the current machine floating-point rounding mode into operand 0.
Operand 0 has mode <var class="var">m</var>, which is scalar.  This pattern is used to
implement the <code class="code">fegetround</code> function from the ISO C99 standard.
</p>
</dd>
<dt><a class="index-entry-id" id="index-feraiseexceptm-instruction-pattern"></a>
<a id="index-feclearexceptm-instruction-pattern"></a><span>&lsquo;<samp class="samp">feclearexcept<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-feclearexceptm-instruction-pattern"> &para;</a></span></dt>
<dt>&lsquo;<samp class="samp">feraiseexcept<var class="var">m</var></samp>&rsquo;</dt>
<dd><p>Clears or raises the supported machine floating-point exceptions
represented by the bits in operand 1.  Error status is stored as
nonzero value in operand 0.  Both operands have mode <var class="var">m</var>, which is
a scalar.  These patterns are used to implement the
<code class="code">feclearexcept</code> and <code class="code">feraiseexcept</code> functions from the ISO
C99 standard.
</p>
</dd>
<dt><a id="index-expm2-instruction-pattern"></a><span>&lsquo;<samp class="samp">exp<var class="var">m</var>2</samp>&rsquo;<a class="copiable-link" href="#index-expm2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Raise e (the base of natural logarithms) to the power of operand 1
and store the result in operand 0.  Both operands have mode <var class="var">m</var>,
which is a scalar or vector floating-point mode.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-expm1m2-instruction-pattern"></a><span>&lsquo;<samp class="samp">expm1<var class="var">m</var>2</samp>&rsquo;<a class="copiable-link" href="#index-expm1m2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Raise e (the base of natural logarithms) to the power of operand 1,
subtract 1, and store the result in operand 0.  Both operands have
mode <var class="var">m</var>, which is a scalar or vector floating-point mode.
</p>
<p>For inputs close to zero, the pattern is expected to be more
accurate than a separate <code class="code">exp<var class="var">m</var>2</code> and <code class="code">sub<var class="var">m</var>3</code>
would be.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-exp10m2-instruction-pattern"></a><span>&lsquo;<samp class="samp">exp10<var class="var">m</var>2</samp>&rsquo;<a class="copiable-link" href="#index-exp10m2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Raise 10 to the power of operand 1 and store the result in operand 0.
Both operands have mode <var class="var">m</var>, which is a scalar or vector
floating-point mode.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-exp2m2-instruction-pattern"></a><span>&lsquo;<samp class="samp">exp2<var class="var">m</var>2</samp>&rsquo;<a class="copiable-link" href="#index-exp2m2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Raise 2 to the power of operand 1 and store the result in operand 0.
Both operands have mode <var class="var">m</var>, which is a scalar or vector
floating-point mode.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-logm2-instruction-pattern"></a><span>&lsquo;<samp class="samp">log<var class="var">m</var>2</samp>&rsquo;<a class="copiable-link" href="#index-logm2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Store the natural logarithm of operand 1 into operand 0.  Both operands
have mode <var class="var">m</var>, which is a scalar or vector floating-point mode.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-log1pm2-instruction-pattern"></a><span>&lsquo;<samp class="samp">log1p<var class="var">m</var>2</samp>&rsquo;<a class="copiable-link" href="#index-log1pm2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Add 1 to operand 1, compute the natural logarithm, and store
the result in operand 0.  Both operands have mode <var class="var">m</var>, which is
a scalar or vector floating-point mode.
</p>
<p>For inputs close to zero, the pattern is expected to be more
accurate than a separate <code class="code">add<var class="var">m</var>3</code> and <code class="code">log<var class="var">m</var>2</code>
would be.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-log10m2-instruction-pattern"></a><span>&lsquo;<samp class="samp">log10<var class="var">m</var>2</samp>&rsquo;<a class="copiable-link" href="#index-log10m2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Store the base-10 logarithm of operand 1 into operand 0.  Both operands
have mode <var class="var">m</var>, which is a scalar or vector floating-point mode.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-log2m2-instruction-pattern"></a><span>&lsquo;<samp class="samp">log2<var class="var">m</var>2</samp>&rsquo;<a class="copiable-link" href="#index-log2m2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Store the base-2 logarithm of operand 1 into operand 0.  Both operands
have mode <var class="var">m</var>, which is a scalar or vector floating-point mode.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-logbm2-instruction-pattern"></a><span>&lsquo;<samp class="samp">logb<var class="var">m</var>2</samp>&rsquo;<a class="copiable-link" href="#index-logbm2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Store the base-<code class="code">FLT_RADIX</code> logarithm of operand 1 into operand 0.
Both operands have mode <var class="var">m</var>, which is a scalar or vector
floating-point mode.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-signbitm2-instruction-pattern"></a><span>&lsquo;<samp class="samp">signbit<var class="var">m</var>2</samp>&rsquo;<a class="copiable-link" href="#index-signbitm2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Store the sign bit of floating-point operand 1 in operand 0.
<var class="var">m</var> is either a scalar or vector mode.  When it is a scalar,
operand 1 has mode <var class="var">m</var> but operand 0 must have mode <code class="code">SImode</code>.
When <var class="var">m</var> is a vector, operand 1 has the mode <var class="var">m</var>.
operand 0&rsquo;s mode should be an vector integer mode which has
the same number of elements and the same size as mode <var class="var">m</var>.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-significandm2-instruction-pattern"></a><span>&lsquo;<samp class="samp">significand<var class="var">m</var>2</samp>&rsquo;<a class="copiable-link" href="#index-significandm2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Store the significand of floating-point operand 1 in operand 0.
Both operands have mode <var class="var">m</var>, which is a scalar or vector
floating-point mode.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-powm3-instruction-pattern"></a><span>&lsquo;<samp class="samp">pow<var class="var">m</var>3</samp>&rsquo;<a class="copiable-link" href="#index-powm3-instruction-pattern"> &para;</a></span></dt>
<dd><p>Store the value of operand 1 raised to the exponent operand 2
into operand 0.  All operands have mode <var class="var">m</var>, which is a scalar
or vector floating-point mode.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-atan2m3-instruction-pattern"></a><span>&lsquo;<samp class="samp">atan2<var class="var">m</var>3</samp>&rsquo;<a class="copiable-link" href="#index-atan2m3-instruction-pattern"> &para;</a></span></dt>
<dd><p>Store the arc tangent (inverse tangent) of operand 1 divided by
operand 2 into operand 0, using the signs of both arguments to
determine the quadrant of the result.  All operands have mode
<var class="var">m</var>, which is a scalar or vector floating-point mode.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-floorm2-instruction-pattern"></a><span>&lsquo;<samp class="samp">floor<var class="var">m</var>2</samp>&rsquo;<a class="copiable-link" href="#index-floorm2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Store the largest integral value not greater than operand 1 in operand 0.
Both operands have mode <var class="var">m</var>, which is a scalar or vector
floating-point mode.  If <samp class="option">-ffp-int-builtin-inexact</samp> is in
effect, the &ldquo;inexact&rdquo; exception may be raised for noninteger
operands; otherwise, it may not.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-btruncm2-instruction-pattern"></a><span>&lsquo;<samp class="samp">btrunc<var class="var">m</var>2</samp>&rsquo;<a class="copiable-link" href="#index-btruncm2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Round operand 1 to an integer, towards zero, and store the result in
operand 0.  Both operands have mode <var class="var">m</var>, which is a scalar or
vector floating-point mode.  If <samp class="option">-ffp-int-builtin-inexact</samp> is
in effect, the &ldquo;inexact&rdquo; exception may be raised for noninteger
operands; otherwise, it may not.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-roundm2-instruction-pattern"></a><span>&lsquo;<samp class="samp">round<var class="var">m</var>2</samp>&rsquo;<a class="copiable-link" href="#index-roundm2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Round operand 1 to the nearest integer, rounding away from zero in the
event of a tie, and store the result in operand 0.  Both operands have
mode <var class="var">m</var>, which is a scalar or vector floating-point mode.  If
<samp class="option">-ffp-int-builtin-inexact</samp> is in effect, the &ldquo;inexact&rdquo;
exception may be raised for noninteger operands; otherwise, it may
not.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-ceilm2-instruction-pattern"></a><span>&lsquo;<samp class="samp">ceil<var class="var">m</var>2</samp>&rsquo;<a class="copiable-link" href="#index-ceilm2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Store the smallest integral value not less than operand 1 in operand 0.
Both operands have mode <var class="var">m</var>, which is a scalar or vector
floating-point mode.  If <samp class="option">-ffp-int-builtin-inexact</samp> is in
effect, the &ldquo;inexact&rdquo; exception may be raised for noninteger
operands; otherwise, it may not.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-nearbyintm2-instruction-pattern"></a><span>&lsquo;<samp class="samp">nearbyint<var class="var">m</var>2</samp>&rsquo;<a class="copiable-link" href="#index-nearbyintm2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Round operand 1 to an integer, using the current rounding mode, and
store the result in operand 0.  Do not raise an inexact condition when
the result is different from the argument.  Both operands have mode
<var class="var">m</var>, which is a scalar or vector floating-point mode.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-rintm2-instruction-pattern"></a><span>&lsquo;<samp class="samp">rint<var class="var">m</var>2</samp>&rsquo;<a class="copiable-link" href="#index-rintm2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Round operand 1 to an integer, using the current rounding mode, and
store the result in operand 0.  Raise an inexact condition when
the result is different from the argument.  Both operands have mode
<var class="var">m</var>, which is a scalar or vector floating-point mode.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-lrintmn2"></a><span>&lsquo;<samp class="samp">lrint<var class="var">m</var><var class="var">n</var>2</samp>&rsquo;<a class="copiable-link" href="#index-lrintmn2"> &para;</a></span></dt>
<dd><p>Convert operand 1 (valid for floating point mode <var class="var">m</var>) to fixed
point mode <var class="var">n</var> as a signed number according to the current
rounding mode and store in operand 0 (which has mode <var class="var">n</var>).
</p>
</dd>
<dt><a id="index-lroundmn2"></a><span>&lsquo;<samp class="samp">lround<var class="var">m</var><var class="var">n</var>2</samp>&rsquo;<a class="copiable-link" href="#index-lroundmn2"> &para;</a></span></dt>
<dd><p>Convert operand 1 (valid for floating point mode <var class="var">m</var>) to fixed
point mode <var class="var">n</var> as a signed number rounding to nearest and away
from zero and store in operand 0 (which has mode <var class="var">n</var>).
</p>
</dd>
<dt><a id="index-lfloormn2"></a><span>&lsquo;<samp class="samp">lfloor<var class="var">m</var><var class="var">n</var>2</samp>&rsquo;<a class="copiable-link" href="#index-lfloormn2"> &para;</a></span></dt>
<dd><p>Convert operand 1 (valid for floating point mode <var class="var">m</var>) to fixed
point mode <var class="var">n</var> as a signed number rounding down and store in
operand 0 (which has mode <var class="var">n</var>).
</p>
</dd>
<dt><a id="index-lceilmn2"></a><span>&lsquo;<samp class="samp">lceil<var class="var">m</var><var class="var">n</var>2</samp>&rsquo;<a class="copiable-link" href="#index-lceilmn2"> &para;</a></span></dt>
<dd><p>Convert operand 1 (valid for floating point mode <var class="var">m</var>) to fixed
point mode <var class="var">n</var> as a signed number rounding up and store in
operand 0 (which has mode <var class="var">n</var>).
</p>
</dd>
<dt><a id="index-copysignm3-instruction-pattern"></a><span>&lsquo;<samp class="samp">copysign<var class="var">m</var>3</samp>&rsquo;<a class="copiable-link" href="#index-copysignm3-instruction-pattern"> &para;</a></span></dt>
<dd><p>Store a value with the magnitude of operand 1 and the sign of operand
2 into operand 0.  All operands have mode <var class="var">m</var>, which is a scalar or
vector floating-point mode.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-xorsignm3-instruction-pattern"></a><span>&lsquo;<samp class="samp">xorsign<var class="var">m</var>3</samp>&rsquo;<a class="copiable-link" href="#index-xorsignm3-instruction-pattern"> &para;</a></span></dt>
<dd><p>Equivalent to &lsquo;<samp class="samp">op0 = op1 * copysign (1.0, op2)</samp>&rsquo;: store a value with
the magnitude of operand 1 and the sign of operand 2 into operand 0.
All operands have mode <var class="var">m</var>, which is a scalar or vector
floating-point mode.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-issignalingm2-instruction-pattern"></a><span>&lsquo;<samp class="samp">issignaling<var class="var">m</var>2</samp>&rsquo;<a class="copiable-link" href="#index-issignalingm2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Set operand 0 to 1 if operand 1 is a signaling NaN and to 0 otherwise.
</p>
</dd>
<dt><a id="index-cadd90m3-instruction-pattern"></a><span>&lsquo;<samp class="samp">cadd90<var class="var">m</var>3</samp>&rsquo;<a class="copiable-link" href="#index-cadd90m3-instruction-pattern"> &para;</a></span></dt>
<dd><p>Perform vector add and subtract on even/odd number pairs.  The operation being
matched is semantically described as
</p>
<div class="example smallexample">
<pre class="example-preformatted">  for (int i = 0; i &lt; N; i += 2)
    {
      c[i] = a[i] - b[i+1];
      c[i+1] = a[i+1] + b[i];
    }
</pre></div>

<p>This operation is semantically equivalent to performing a vector addition of
complex numbers in operand 1 with operand 2 rotated by 90 degrees around
the argand plane and storing the result in operand 0.
</p>
<p>In GCC lane ordering the real part of the number must be in the even lanes with
the imaginary part in the odd lanes.
</p>
<p>The operation is only supported for vector modes <var class="var">m</var>.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-cadd270m3-instruction-pattern"></a><span>&lsquo;<samp class="samp">cadd270<var class="var">m</var>3</samp>&rsquo;<a class="copiable-link" href="#index-cadd270m3-instruction-pattern"> &para;</a></span></dt>
<dd><p>Perform vector add and subtract on even/odd number pairs.  The operation being
matched is semantically described as
</p>
<div class="example smallexample">
<pre class="example-preformatted">  for (int i = 0; i &lt; N; i += 2)
    {
      c[i] = a[i] + b[i+1];
      c[i+1] = a[i+1] - b[i];
    }
</pre></div>

<p>This operation is semantically equivalent to performing a vector addition of
complex numbers in operand 1 with operand 2 rotated by 270 degrees around
the argand plane and storing the result in operand 0.
</p>
<p>In GCC lane ordering the real part of the number must be in the even lanes with
the imaginary part in the odd lanes.
</p>
<p>The operation is only supported for vector modes <var class="var">m</var>.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-cmlam4-instruction-pattern"></a><span>&lsquo;<samp class="samp">cmla<var class="var">m</var>4</samp>&rsquo;<a class="copiable-link" href="#index-cmlam4-instruction-pattern"> &para;</a></span></dt>
<dd><p>Perform a vector multiply and accumulate that is semantically the same as
a multiply and accumulate of complex numbers.
</p>
<div class="example smallexample">
<pre class="example-preformatted">  complex TYPE op0[N];
  complex TYPE op1[N];
  complex TYPE op2[N];
  complex TYPE op3[N];
  for (int i = 0; i &lt; N; i += 1)
    {
      op0[i] = op1[i] * op2[i] + op3[i];
    }
</pre></div>

<p>In GCC lane ordering the real part of the number must be in the even lanes with
the imaginary part in the odd lanes.
</p>
<p>The operation is only supported for vector modes <var class="var">m</var>.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-cmla_005fconjm4-instruction-pattern"></a><span>&lsquo;<samp class="samp">cmla_conj<var class="var">m</var>4</samp>&rsquo;<a class="copiable-link" href="#index-cmla_005fconjm4-instruction-pattern"> &para;</a></span></dt>
<dd><p>Perform a vector multiply by conjugate and accumulate that is semantically
the same as a multiply and accumulate of complex numbers where the second
multiply arguments is conjugated.
</p>
<div class="example smallexample">
<pre class="example-preformatted">  complex TYPE op0[N];
  complex TYPE op1[N];
  complex TYPE op2[N];
  complex TYPE op3[N];
  for (int i = 0; i &lt; N; i += 1)
    {
      op0[i] = op1[i] * conj (op2[i]) + op3[i];
    }
</pre></div>

<p>In GCC lane ordering the real part of the number must be in the even lanes with
the imaginary part in the odd lanes.
</p>
<p>The operation is only supported for vector modes <var class="var">m</var>.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-cmlsm4-instruction-pattern"></a><span>&lsquo;<samp class="samp">cmls<var class="var">m</var>4</samp>&rsquo;<a class="copiable-link" href="#index-cmlsm4-instruction-pattern"> &para;</a></span></dt>
<dd><p>Perform a vector multiply and subtract that is semantically the same as
a multiply and subtract of complex numbers.
</p>
<div class="example smallexample">
<pre class="example-preformatted">  complex TYPE op0[N];
  complex TYPE op1[N];
  complex TYPE op2[N];
  complex TYPE op3[N];
  for (int i = 0; i &lt; N; i += 1)
    {
      op0[i] = op1[i] * op2[i] - op3[i];
    }
</pre></div>

<p>In GCC lane ordering the real part of the number must be in the even lanes with
the imaginary part in the odd lanes.
</p>
<p>The operation is only supported for vector modes <var class="var">m</var>.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-cmls_005fconjm4-instruction-pattern"></a><span>&lsquo;<samp class="samp">cmls_conj<var class="var">m</var>4</samp>&rsquo;<a class="copiable-link" href="#index-cmls_005fconjm4-instruction-pattern"> &para;</a></span></dt>
<dd><p>Perform a vector multiply by conjugate and subtract that is semantically
the same as a multiply and subtract of complex numbers where the second
multiply arguments is conjugated.
</p>
<div class="example smallexample">
<pre class="example-preformatted">  complex TYPE op0[N];
  complex TYPE op1[N];
  complex TYPE op2[N];
  complex TYPE op3[N];
  for (int i = 0; i &lt; N; i += 1)
    {
      op0[i] = op1[i] * conj (op2[i]) - op3[i];
    }
</pre></div>

<p>In GCC lane ordering the real part of the number must be in the even lanes with
the imaginary part in the odd lanes.
</p>
<p>The operation is only supported for vector modes <var class="var">m</var>.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-cmulm4-instruction-pattern"></a><span>&lsquo;<samp class="samp">cmul<var class="var">m</var>4</samp>&rsquo;<a class="copiable-link" href="#index-cmulm4-instruction-pattern"> &para;</a></span></dt>
<dd><p>Perform a vector multiply that is semantically the same as multiply of
complex numbers.
</p>
<div class="example smallexample">
<pre class="example-preformatted">  complex TYPE op0[N];
  complex TYPE op1[N];
  complex TYPE op2[N];
  for (int i = 0; i &lt; N; i += 1)
    {
      op0[i] = op1[i] * op2[i];
    }
</pre></div>

<p>In GCC lane ordering the real part of the number must be in the even lanes with
the imaginary part in the odd lanes.
</p>
<p>The operation is only supported for vector modes <var class="var">m</var>.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-cmul_005fconjm4-instruction-pattern"></a><span>&lsquo;<samp class="samp">cmul_conj<var class="var">m</var>4</samp>&rsquo;<a class="copiable-link" href="#index-cmul_005fconjm4-instruction-pattern"> &para;</a></span></dt>
<dd><p>Perform a vector multiply by conjugate that is semantically the same as a
multiply of complex numbers where the second multiply arguments is conjugated.
</p>
<div class="example smallexample">
<pre class="example-preformatted">  complex TYPE op0[N];
  complex TYPE op1[N];
  complex TYPE op2[N];
  for (int i = 0; i &lt; N; i += 1)
    {
      op0[i] = op1[i] * conj (op2[i]);
    }
</pre></div>

<p>In GCC lane ordering the real part of the number must be in the even lanes with
the imaginary part in the odd lanes.
</p>
<p>The operation is only supported for vector modes <var class="var">m</var>.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-ffsm2-instruction-pattern"></a><span>&lsquo;<samp class="samp">ffs<var class="var">m</var>2</samp>&rsquo;<a class="copiable-link" href="#index-ffsm2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Store into operand 0 one plus the index of the least significant 1-bit
of operand 1.  If operand 1 is zero, store zero.
</p>
<p><var class="var">m</var> is either a scalar or vector integer mode.  When it is a scalar,
operand 1 has mode <var class="var">m</var> but operand 0 can have whatever scalar
integer mode is suitable for the target.  The compiler will insert
conversion instructions as necessary (typically to convert the result
to the same width as <code class="code">int</code>).  When <var class="var">m</var> is a vector, both
operands must have mode <var class="var">m</var>.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-clrsbm2-instruction-pattern"></a><span>&lsquo;<samp class="samp">clrsb<var class="var">m</var>2</samp>&rsquo;<a class="copiable-link" href="#index-clrsbm2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Count leading redundant sign bits.
Store into operand 0 the number of redundant sign bits in operand 1, starting
at the most significant bit position.
A redundant sign bit is defined as any sign bit after the first. As such,
this count will be one less than the count of leading sign bits.
</p>
<p><var class="var">m</var> is either a scalar or vector integer mode.  When it is a scalar,
operand 1 has mode <var class="var">m</var> but operand 0 can have whatever scalar
integer mode is suitable for the target.  The compiler will insert
conversion instructions as necessary (typically to convert the result
to the same width as <code class="code">int</code>).  When <var class="var">m</var> is a vector, both
operands must have mode <var class="var">m</var>.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-clzm2-instruction-pattern"></a><span>&lsquo;<samp class="samp">clz<var class="var">m</var>2</samp>&rsquo;<a class="copiable-link" href="#index-clzm2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Store into operand 0 the number of leading 0-bits in operand 1, starting
at the most significant bit position.  If operand 1 is 0, the
<code class="code">CLZ_DEFINED_VALUE_AT_ZERO</code> (see <a class="pxref" href="Misc.html">Miscellaneous Parameters</a>) macro defines if
the result is undefined or has a useful value.
</p>
<p><var class="var">m</var> is either a scalar or vector integer mode.  When it is a scalar,
operand 1 has mode <var class="var">m</var> but operand 0 can have whatever scalar
integer mode is suitable for the target.  The compiler will insert
conversion instructions as necessary (typically to convert the result
to the same width as <code class="code">int</code>).  When <var class="var">m</var> is a vector, both
operands must have mode <var class="var">m</var>.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-ctzm2-instruction-pattern"></a><span>&lsquo;<samp class="samp">ctz<var class="var">m</var>2</samp>&rsquo;<a class="copiable-link" href="#index-ctzm2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Store into operand 0 the number of trailing 0-bits in operand 1, starting
at the least significant bit position.  If operand 1 is 0, the
<code class="code">CTZ_DEFINED_VALUE_AT_ZERO</code> (see <a class="pxref" href="Misc.html">Miscellaneous Parameters</a>) macro defines if
the result is undefined or has a useful value.
</p>
<p><var class="var">m</var> is either a scalar or vector integer mode.  When it is a scalar,
operand 1 has mode <var class="var">m</var> but operand 0 can have whatever scalar
integer mode is suitable for the target.  The compiler will insert
conversion instructions as necessary (typically to convert the result
to the same width as <code class="code">int</code>).  When <var class="var">m</var> is a vector, both
operands must have mode <var class="var">m</var>.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-popcountm2-instruction-pattern"></a><span>&lsquo;<samp class="samp">popcount<var class="var">m</var>2</samp>&rsquo;<a class="copiable-link" href="#index-popcountm2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Store into operand 0 the number of 1-bits in operand 1.
</p>
<p><var class="var">m</var> is either a scalar or vector integer mode.  When it is a scalar,
operand 1 has mode <var class="var">m</var> but operand 0 can have whatever scalar
integer mode is suitable for the target.  The compiler will insert
conversion instructions as necessary (typically to convert the result
to the same width as <code class="code">int</code>).  When <var class="var">m</var> is a vector, both
operands must have mode <var class="var">m</var>.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-paritym2-instruction-pattern"></a><span>&lsquo;<samp class="samp">parity<var class="var">m</var>2</samp>&rsquo;<a class="copiable-link" href="#index-paritym2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Store into operand 0 the parity of operand 1, i.e. the number of 1-bits
in operand 1 modulo 2.
</p>
<p><var class="var">m</var> is either a scalar or vector integer mode.  When it is a scalar,
operand 1 has mode <var class="var">m</var> but operand 0 can have whatever scalar
integer mode is suitable for the target.  The compiler will insert
conversion instructions as necessary (typically to convert the result
to the same width as <code class="code">int</code>).  When <var class="var">m</var> is a vector, both
operands must have mode <var class="var">m</var>.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-one_005fcmplm2-instruction-pattern"></a><span>&lsquo;<samp class="samp">one_cmpl<var class="var">m</var>2</samp>&rsquo;<a class="copiable-link" href="#index-one_005fcmplm2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Store the bitwise-complement of operand 1 into operand 0.
</p>
</dd>
<dt><a id="index-cpymemm-instruction-pattern"></a><span>&lsquo;<samp class="samp">cpymem<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-cpymemm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Block copy instruction.  The destination and source blocks of memory
are the first two operands, and both are <code class="code">mem:BLK</code>s with an
address in mode <code class="code">Pmode</code>.
</p>
<p>The number of bytes to copy is the third operand, in mode <var class="var">m</var>.
Usually, you specify <code class="code">Pmode</code> for <var class="var">m</var>.  However, if you can
generate better code knowing the range of valid lengths is smaller than
those representable in a full Pmode pointer, you should provide
a pattern with a
mode corresponding to the range of values you can handle efficiently
(e.g., <code class="code">QImode</code> for values in the range 0&ndash;127; note we avoid numbers
that appear negative) and also a pattern with <code class="code">Pmode</code>.
</p>
<p>The fourth operand is the known shared alignment of the source and
destination, in the form of a <code class="code">const_int</code> rtx.  Thus, if the
compiler knows that both source and destination are word-aligned,
it may provide the value 4 for this operand.
</p>
<p>Optional operands 5 and 6 specify expected alignment and size of block
respectively.  The expected alignment differs from alignment in operand 4
in a way that the blocks are not required to be aligned according to it in
all cases. This expected alignment is also in bytes, just like operand 4.
Expected size, when unknown, is set to <code class="code">(const_int -1)</code>.
</p>
<p>Descriptions of multiple <code class="code">cpymem<var class="var">m</var></code> patterns can only be
beneficial if the patterns for smaller modes have fewer restrictions
on their first, second and fourth operands.  Note that the mode <var class="var">m</var>
in <code class="code">cpymem<var class="var">m</var></code> does not impose any restriction on the mode of
individually copied data units in the block.
</p>
<p>The <code class="code">cpymem<var class="var">m</var></code> patterns need not give special consideration
to the possibility that the source and destination strings might
overlap.  An exception is the case where source and destination are
equal, this case needs to be handled correctly.
These patterns are used to do inline expansion of <code class="code">__builtin_memcpy</code>.
</p>
</dd>
<dt><a id="index-movmemm-instruction-pattern"></a><span>&lsquo;<samp class="samp">movmem<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-movmemm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Block move instruction.  The destination and source blocks of memory
are the first two operands, and both are <code class="code">mem:BLK</code>s with an
address in mode <code class="code">Pmode</code>.
</p>
<p>The number of bytes to copy is the third operand, in mode <var class="var">m</var>.
Usually, you specify <code class="code">Pmode</code> for <var class="var">m</var>.  However, if you can
generate better code knowing the range of valid lengths is smaller than
those representable in a full Pmode pointer, you should provide
a pattern with a
mode corresponding to the range of values you can handle efficiently
(e.g., <code class="code">QImode</code> for values in the range 0&ndash;127; note we avoid numbers
that appear negative) and also a pattern with <code class="code">Pmode</code>.
</p>
<p>The fourth operand is the known shared alignment of the source and
destination, in the form of a <code class="code">const_int</code> rtx.  Thus, if the
compiler knows that both source and destination are word-aligned,
it may provide the value 4 for this operand.
</p>
<p>Optional operands 5 and 6 specify expected alignment and size of block
respectively.  The expected alignment differs from alignment in operand 4
in a way that the blocks are not required to be aligned according to it in
all cases. This expected alignment is also in bytes, just like operand 4.
Expected size, when unknown, is set to <code class="code">(const_int -1)</code>.
</p>
<p>Descriptions of multiple <code class="code">movmem<var class="var">m</var></code> patterns can only be
beneficial if the patterns for smaller modes have fewer restrictions
on their first, second and fourth operands.  Note that the mode <var class="var">m</var>
in <code class="code">movmem<var class="var">m</var></code> does not impose any restriction on the mode of
individually copied data units in the block.
</p>
<p>The <code class="code">movmem<var class="var">m</var></code> patterns must correctly handle the case where
the source and destination strings overlap. These patterns are used to
do inline expansion of <code class="code">__builtin_memmove</code>.
</p>
</dd>
<dt><a id="index-movstr-instruction-pattern"></a><span>&lsquo;<samp class="samp">movstr</samp>&rsquo;<a class="copiable-link" href="#index-movstr-instruction-pattern"> &para;</a></span></dt>
<dd><p>String copy instruction, with <code class="code">stpcpy</code> semantics.  Operand 0 is
an output operand in mode <code class="code">Pmode</code>.  The addresses of the
destination and source strings are operands 1 and 2, and both are
<code class="code">mem:BLK</code>s with addresses in mode <code class="code">Pmode</code>.  The execution of
the expansion of this pattern should store in operand 0 the address in
which the <code class="code">NUL</code> terminator was stored in the destination string.
</p>
<p>This pattern has also several optional operands that are same as in
<code class="code">setmem</code>.
</p>
</dd>
<dt><a id="index-setmemm-instruction-pattern"></a><span>&lsquo;<samp class="samp">setmem<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-setmemm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Block set instruction.  The destination string is the first operand,
given as a <code class="code">mem:BLK</code> whose address is in mode <code class="code">Pmode</code>.  The
number of bytes to set is the second operand, in mode <var class="var">m</var>.  The value to
initialize the memory with is the third operand. Targets that only support the
clearing of memory should reject any value that is not the constant 0.  See
&lsquo;<samp class="samp">cpymem<var class="var">m</var></samp>&rsquo; for a discussion of the choice of mode.
</p>
<p>The fourth operand is the known alignment of the destination, in the form
of a <code class="code">const_int</code> rtx.  Thus, if the compiler knows that the
destination is word-aligned, it may provide the value 4 for this
operand.
</p>
<p>Optional operands 5 and 6 specify expected alignment and size of block
respectively.  The expected alignment differs from alignment in operand 4
in a way that the blocks are not required to be aligned according to it in
all cases. This expected alignment is also in bytes, just like operand 4.
Expected size, when unknown, is set to <code class="code">(const_int -1)</code>.
Operand 7 is the minimal size of the block and operand 8 is the
maximal size of the block (NULL if it cannot be represented as CONST_INT).
Operand 9 is the probable maximal size (i.e. we cannot rely on it for
correctness, but it can be used for choosing proper code sequence for a
given size).
</p>
<p>The use for multiple <code class="code">setmem<var class="var">m</var></code> is as for <code class="code">cpymem<var class="var">m</var></code>.
</p>
</dd>
<dt><a id="index-cmpstrnm-instruction-pattern"></a><span>&lsquo;<samp class="samp">cmpstrn<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-cmpstrnm-instruction-pattern"> &para;</a></span></dt>
<dd><p>String compare instruction, with five operands.  Operand 0 is the output;
it has mode <var class="var">m</var>.  The remaining four operands are like the operands
of &lsquo;<samp class="samp">cpymem<var class="var">m</var></samp>&rsquo;.  The two memory blocks specified are compared
byte by byte in lexicographic order starting at the beginning of each
string.  The instruction is not allowed to prefetch more than one byte
at a time since either string may end in the first byte and reading past
that may access an invalid page or segment and cause a fault.  The
comparison terminates early if the fetched bytes are different or if
they are equal to zero.  The effect of the instruction is to store a
value in operand 0 whose sign indicates the result of the comparison.
</p>
</dd>
<dt><a id="index-cmpstrm-instruction-pattern"></a><span>&lsquo;<samp class="samp">cmpstr<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-cmpstrm-instruction-pattern"> &para;</a></span></dt>
<dd><p>String compare instruction, without known maximum length.  Operand 0 is the
output; it has mode <var class="var">m</var>.  The second and third operand are the blocks of
memory to be compared; both are <code class="code">mem:BLK</code> with an address in mode
<code class="code">Pmode</code>.
</p>
<p>The fourth operand is the known shared alignment of the source and
destination, in the form of a <code class="code">const_int</code> rtx.  Thus, if the
compiler knows that both source and destination are word-aligned,
it may provide the value 4 for this operand.
</p>
<p>The two memory blocks specified are compared byte by byte in lexicographic
order starting at the beginning of each string.  The instruction is not allowed
to prefetch more than one byte at a time since either string may end in the
first byte and reading past that may access an invalid page or segment and
cause a fault.  The comparison will terminate when the fetched bytes
are different or if they are equal to zero.  The effect of the
instruction is to store a value in operand 0 whose sign indicates the
result of the comparison.
</p>
</dd>
<dt><a id="index-cmpmemm-instruction-pattern"></a><span>&lsquo;<samp class="samp">cmpmem<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-cmpmemm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Block compare instruction, with five operands like the operands
of &lsquo;<samp class="samp">cmpstr<var class="var">m</var></samp>&rsquo;.  The two memory blocks specified are compared
byte by byte in lexicographic order starting at the beginning of each
block.  Unlike &lsquo;<samp class="samp">cmpstr<var class="var">m</var></samp>&rsquo; the instruction can prefetch
any bytes in the two memory blocks.  Also unlike &lsquo;<samp class="samp">cmpstr<var class="var">m</var></samp>&rsquo;
the comparison will not stop if both bytes are zero.  The effect of
the instruction is to store a value in operand 0 whose sign indicates
the result of the comparison.
</p>
</dd>
<dt><a id="index-strlenm-instruction-pattern"></a><span>&lsquo;<samp class="samp">strlen<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-strlenm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Compute the length of a string, with three operands.
Operand 0 is the result (of mode <var class="var">m</var>), operand 1 is
a <code class="code">mem</code> referring to the first character of the string,
operand 2 is the character to search for (normally zero),
and operand 3 is a constant describing the known alignment
of the beginning of the string.
</p>
</dd>
<dt><a id="index-rawmemchrm-instruction-pattern"></a><span>&lsquo;<samp class="samp">rawmemchr<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-rawmemchrm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Scan memory referred to by operand 1 for the first occurrence of operand 2.
Operand 1 is a <code class="code">mem</code> and operand 2 a <code class="code">const_int</code> of mode <var class="var">m</var>.
Operand 0 is the result, i.e., a pointer to the first occurrence of operand 2
in the memory block given by operand 1.
</p>
</dd>
<dt><a id="index-floatmn2-instruction-pattern"></a><span>&lsquo;<samp class="samp">float<var class="var">m</var><var class="var">n</var>2</samp>&rsquo;<a class="copiable-link" href="#index-floatmn2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Convert signed integer operand 1 (valid for fixed point mode <var class="var">m</var>) to
floating point mode <var class="var">n</var> and store in operand 0 (which has mode
<var class="var">n</var>).
</p>
</dd>
<dt><a id="index-floatunsmn2-instruction-pattern"></a><span>&lsquo;<samp class="samp">floatuns<var class="var">m</var><var class="var">n</var>2</samp>&rsquo;<a class="copiable-link" href="#index-floatunsmn2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Convert unsigned integer operand 1 (valid for fixed point mode <var class="var">m</var>)
to floating point mode <var class="var">n</var> and store in operand 0 (which has mode
<var class="var">n</var>).
</p>
</dd>
<dt><a id="index-fixmn2-instruction-pattern"></a><span>&lsquo;<samp class="samp">fix<var class="var">m</var><var class="var">n</var>2</samp>&rsquo;<a class="copiable-link" href="#index-fixmn2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Convert operand 1 (valid for floating point mode <var class="var">m</var>) to fixed
point mode <var class="var">n</var> as a signed number and store in operand 0 (which
has mode <var class="var">n</var>).  This instruction&rsquo;s result is defined only when
the value of operand 1 is an integer.
</p>
<p>If the machine description defines this pattern, it also needs to
define the <code class="code">ftrunc</code> pattern.
</p>
</dd>
<dt><a id="index-fixunsmn2-instruction-pattern"></a><span>&lsquo;<samp class="samp">fixuns<var class="var">m</var><var class="var">n</var>2</samp>&rsquo;<a class="copiable-link" href="#index-fixunsmn2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Convert operand 1 (valid for floating point mode <var class="var">m</var>) to fixed
point mode <var class="var">n</var> as an unsigned number and store in operand 0 (which
has mode <var class="var">n</var>).  This instruction&rsquo;s result is defined only when the
value of operand 1 is an integer.
</p>
</dd>
<dt><a id="index-ftruncm2-instruction-pattern"></a><span>&lsquo;<samp class="samp">ftrunc<var class="var">m</var>2</samp>&rsquo;<a class="copiable-link" href="#index-ftruncm2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Convert operand 1 (valid for floating point mode <var class="var">m</var>) to an
integer value, still represented in floating point mode <var class="var">m</var>, and
store it in operand 0 (valid for floating point mode <var class="var">m</var>).
</p>
</dd>
<dt><a id="index-fix_005ftruncmn2-instruction-pattern"></a><span>&lsquo;<samp class="samp">fix_trunc<var class="var">m</var><var class="var">n</var>2</samp>&rsquo;<a class="copiable-link" href="#index-fix_005ftruncmn2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Like &lsquo;<samp class="samp">fix<var class="var">m</var><var class="var">n</var>2</samp>&rsquo; but works for any floating point value
of mode <var class="var">m</var> by converting the value to an integer.
</p>
</dd>
<dt><a id="index-fixuns_005ftruncmn2-instruction-pattern"></a><span>&lsquo;<samp class="samp">fixuns_trunc<var class="var">m</var><var class="var">n</var>2</samp>&rsquo;<a class="copiable-link" href="#index-fixuns_005ftruncmn2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Like &lsquo;<samp class="samp">fixuns<var class="var">m</var><var class="var">n</var>2</samp>&rsquo; but works for any floating point
value of mode <var class="var">m</var> by converting the value to an integer.
</p>
</dd>
<dt><a id="index-truncmn2-instruction-pattern"></a><span>&lsquo;<samp class="samp">trunc<var class="var">m</var><var class="var">n</var>2</samp>&rsquo;<a class="copiable-link" href="#index-truncmn2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Truncate operand 1 (valid for mode <var class="var">m</var>) to mode <var class="var">n</var> and
store in operand 0 (which has mode <var class="var">n</var>).  Both modes must be fixed
point or both floating point.
</p>
</dd>
<dt><a id="index-extendmn2-instruction-pattern"></a><span>&lsquo;<samp class="samp">extend<var class="var">m</var><var class="var">n</var>2</samp>&rsquo;<a class="copiable-link" href="#index-extendmn2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Sign-extend operand 1 (valid for mode <var class="var">m</var>) to mode <var class="var">n</var> and
store in operand 0 (which has mode <var class="var">n</var>).  Both modes must be fixed
point or both floating point.
</p>
</dd>
<dt><a id="index-zero_005fextendmn2-instruction-pattern"></a><span>&lsquo;<samp class="samp">zero_extend<var class="var">m</var><var class="var">n</var>2</samp>&rsquo;<a class="copiable-link" href="#index-zero_005fextendmn2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Zero-extend operand 1 (valid for mode <var class="var">m</var>) to mode <var class="var">n</var> and
store in operand 0 (which has mode <var class="var">n</var>).  Both modes must be fixed
point.
</p>
</dd>
<dt><a id="index-fractmn2-instruction-pattern"></a><span>&lsquo;<samp class="samp">fract<var class="var">m</var><var class="var">n</var>2</samp>&rsquo;<a class="copiable-link" href="#index-fractmn2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Convert operand 1 of mode <var class="var">m</var> to mode <var class="var">n</var> and store in
operand 0 (which has mode <var class="var">n</var>).  Mode <var class="var">m</var> and mode <var class="var">n</var>
could be fixed-point to fixed-point, signed integer to fixed-point,
fixed-point to signed integer, floating-point to fixed-point,
or fixed-point to floating-point.
When overflows or underflows happen, the results are undefined.
</p>
</dd>
<dt><a id="index-satfractmn2-instruction-pattern"></a><span>&lsquo;<samp class="samp">satfract<var class="var">m</var><var class="var">n</var>2</samp>&rsquo;<a class="copiable-link" href="#index-satfractmn2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Convert operand 1 of mode <var class="var">m</var> to mode <var class="var">n</var> and store in
operand 0 (which has mode <var class="var">n</var>).  Mode <var class="var">m</var> and mode <var class="var">n</var>
could be fixed-point to fixed-point, signed integer to fixed-point,
or floating-point to fixed-point.
When overflows or underflows happen, the instruction saturates the
results to the maximum or the minimum.
</p>
</dd>
<dt><a id="index-fractunsmn2-instruction-pattern"></a><span>&lsquo;<samp class="samp">fractuns<var class="var">m</var><var class="var">n</var>2</samp>&rsquo;<a class="copiable-link" href="#index-fractunsmn2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Convert operand 1 of mode <var class="var">m</var> to mode <var class="var">n</var> and store in
operand 0 (which has mode <var class="var">n</var>).  Mode <var class="var">m</var> and mode <var class="var">n</var>
could be unsigned integer to fixed-point, or
fixed-point to unsigned integer.
When overflows or underflows happen, the results are undefined.
</p>
</dd>
<dt><a id="index-satfractunsmn2-instruction-pattern"></a><span>&lsquo;<samp class="samp">satfractuns<var class="var">m</var><var class="var">n</var>2</samp>&rsquo;<a class="copiable-link" href="#index-satfractunsmn2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Convert unsigned integer operand 1 of mode <var class="var">m</var> to fixed-point mode
<var class="var">n</var> and store in operand 0 (which has mode <var class="var">n</var>).
When overflows or underflows happen, the instruction saturates the
results to the maximum or the minimum.
</p>
</dd>
<dt><a id="index-extvm-instruction-pattern"></a><span>&lsquo;<samp class="samp">extv<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-extvm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Extract a bit-field from register operand 1, sign-extend it, and store
it in operand 0.  Operand 2 specifies the width of the field in bits
and operand 3 the starting bit, which counts from the most significant
bit if &lsquo;<samp class="samp">BITS_BIG_ENDIAN</samp>&rsquo; is true and from the least significant bit
otherwise.
</p>
<p>Operands 0 and 1 both have mode <var class="var">m</var>.  Operands 2 and 3 have a
target-specific mode.
</p>
</dd>
<dt><a id="index-extvmisalignm-instruction-pattern"></a><span>&lsquo;<samp class="samp">extvmisalign<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-extvmisalignm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Extract a bit-field from memory operand 1, sign extend it, and store
it in operand 0.  Operand 2 specifies the width in bits and operand 3
the starting bit.  The starting bit is always somewhere in the first byte of
operand 1; it counts from the most significant bit if &lsquo;<samp class="samp">BITS_BIG_ENDIAN</samp>&rsquo;
is true and from the least significant bit otherwise.
</p>
<p>Operand 0 has mode <var class="var">m</var> while operand 1 has <code class="code">BLK</code> mode.
Operands 2 and 3 have a target-specific mode.
</p>
<p>The instruction must not read beyond the last byte of the bit-field.
</p>
</dd>
<dt><a id="index-extzvm-instruction-pattern"></a><span>&lsquo;<samp class="samp">extzv<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-extzvm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Like &lsquo;<samp class="samp">extv<var class="var">m</var></samp>&rsquo; except that the bit-field value is zero-extended.
</p>
</dd>
<dt><a id="index-extzvmisalignm-instruction-pattern"></a><span>&lsquo;<samp class="samp">extzvmisalign<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-extzvmisalignm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Like &lsquo;<samp class="samp">extvmisalign<var class="var">m</var></samp>&rsquo; except that the bit-field value is
zero-extended.
</p>
</dd>
<dt><a id="index-insvm-instruction-pattern"></a><span>&lsquo;<samp class="samp">insv<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-insvm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Insert operand 3 into a bit-field of register operand 0.  Operand 1
specifies the width of the field in bits and operand 2 the starting bit,
which counts from the most significant bit if &lsquo;<samp class="samp">BITS_BIG_ENDIAN</samp>&rsquo;
is true and from the least significant bit otherwise.
</p>
<p>Operands 0 and 3 both have mode <var class="var">m</var>.  Operands 1 and 2 have a
target-specific mode.
</p>
</dd>
<dt><a id="index-insvmisalignm-instruction-pattern"></a><span>&lsquo;<samp class="samp">insvmisalign<var class="var">m</var></samp>&rsquo;<a class="copiable-link" href="#index-insvmisalignm-instruction-pattern"> &para;</a></span></dt>
<dd><p>Insert operand 3 into a bit-field of memory operand 0.  Operand 1
specifies the width of the field in bits and operand 2 the starting bit.
The starting bit is always somewhere in the first byte of operand 0;
it counts from the most significant bit if &lsquo;<samp class="samp">BITS_BIG_ENDIAN</samp>&rsquo;
is true and from the least significant bit otherwise.
</p>
<p>Operand 3 has mode <var class="var">m</var> while operand 0 has <code class="code">BLK</code> mode.
Operands 1 and 2 have a target-specific mode.
</p>
<p>The instruction must not read or write beyond the last byte of the bit-field.
</p>
</dd>
<dt><a id="index-extv-instruction-pattern"></a><span>&lsquo;<samp class="samp">extv</samp>&rsquo;<a class="copiable-link" href="#index-extv-instruction-pattern"> &para;</a></span></dt>
<dd><p>Extract a bit-field from operand 1 (a register or memory operand), where
operand 2 specifies the width in bits and operand 3 the starting bit,
and store it in operand 0.  Operand 0 must have mode <code class="code">word_mode</code>.
Operand 1 may have mode <code class="code">byte_mode</code> or <code class="code">word_mode</code>; often
<code class="code">word_mode</code> is allowed only for registers.  Operands 2 and 3 must
be valid for <code class="code">word_mode</code>.
</p>
<p>The RTL generation pass generates this instruction only with constants
for operands 2 and 3 and the constant is never zero for operand 2.
</p>
<p>The bit-field value is sign-extended to a full word integer
before it is stored in operand 0.
</p>
<p>This pattern is deprecated; please use &lsquo;<samp class="samp">extv<var class="var">m</var></samp>&rsquo; and
<code class="code">extvmisalign<var class="var">m</var></code> instead.
</p>
</dd>
<dt><a id="index-extzv-instruction-pattern"></a><span>&lsquo;<samp class="samp">extzv</samp>&rsquo;<a class="copiable-link" href="#index-extzv-instruction-pattern"> &para;</a></span></dt>
<dd><p>Like &lsquo;<samp class="samp">extv</samp>&rsquo; except that the bit-field value is zero-extended.
</p>
<p>This pattern is deprecated; please use &lsquo;<samp class="samp">extzv<var class="var">m</var></samp>&rsquo; and
<code class="code">extzvmisalign<var class="var">m</var></code> instead.
</p>
</dd>
<dt><a id="index-insv-instruction-pattern"></a><span>&lsquo;<samp class="samp">insv</samp>&rsquo;<a class="copiable-link" href="#index-insv-instruction-pattern"> &para;</a></span></dt>
<dd><p>Store operand 3 (which must be valid for <code class="code">word_mode</code>) into a
bit-field in operand 0, where operand 1 specifies the width in bits and
operand 2 the starting bit.  Operand 0 may have mode <code class="code">byte_mode</code> or
<code class="code">word_mode</code>; often <code class="code">word_mode</code> is allowed only for registers.
Operands 1 and 2 must be valid for <code class="code">word_mode</code>.
</p>
<p>The RTL generation pass generates this instruction only with constants
for operands 1 and 2 and the constant is never zero for operand 1.
</p>
<p>This pattern is deprecated; please use &lsquo;<samp class="samp">insv<var class="var">m</var></samp>&rsquo; and
<code class="code">insvmisalign<var class="var">m</var></code> instead.
</p>
</dd>
<dt><a id="index-movmodecc-instruction-pattern"></a><span>&lsquo;<samp class="samp">mov<var class="var">mode</var>cc</samp>&rsquo;<a class="copiable-link" href="#index-movmodecc-instruction-pattern"> &para;</a></span></dt>
<dd><p>Conditionally move operand 2 or operand 3 into operand 0 according to the
comparison in operand 1.  If the comparison is true, operand 2 is moved
into operand 0, otherwise operand 3 is moved.
</p>
<p>The mode of the operands being compared need not be the same as the operands
being moved.  Some machines, sparc64 for example, have instructions that
conditionally move an integer value based on the floating point condition
codes and vice versa.
</p>
<p>If the machine does not have conditional move instructions, do not
define these patterns.
</p>
</dd>
<dt><a id="index-addmodecc-instruction-pattern"></a><span>&lsquo;<samp class="samp">add<var class="var">mode</var>cc</samp>&rsquo;<a class="copiable-link" href="#index-addmodecc-instruction-pattern"> &para;</a></span></dt>
<dd><p>Similar to &lsquo;<samp class="samp">mov<var class="var">mode</var>cc</samp>&rsquo; but for conditional addition.  Conditionally
move operand 2 or (operands 2 + operand 3) into operand 0 according to the
comparison in operand 1.  If the comparison is false, operand 2 is moved into
operand 0, otherwise (operand 2 + operand 3) is moved.
</p>
</dd>
<dt><a class="index-entry-id" id="index-cond_005fone_005fcmplmode-instruction-pattern"></a>
<a id="index-cond_005fnegmode-instruction-pattern"></a><span>&lsquo;<samp class="samp">cond_neg<var class="var">mode</var></samp>&rsquo;<a class="copiable-link" href="#index-cond_005fnegmode-instruction-pattern"> &para;</a></span></dt>
<dt>&lsquo;<samp class="samp">cond_one_cmpl<var class="var">mode</var></samp>&rsquo;</dt>
<dd><p>When operand 1 is true, perform an operation on operands 2 and
store the result in operand 0, otherwise store operand 3 in operand 0.
The operation works elementwise if the operands are vectors.
</p>
<p>The scalar case is equivalent to:
</p>
<div class="example smallexample">
<pre class="example-preformatted">op0 = op1 ? <var class="var">op</var> op2 : op3;
</pre></div>

<p>while the vector case is equivalent to:
</p>
<div class="example smallexample">
<pre class="example-preformatted">for (i = 0; i &lt; GET_MODE_NUNITS (<var class="var">m</var>); i++)
  op0[i] = op1[i] ? <var class="var">op</var> op2[i] : op3[i];
</pre></div>

<p>where, for example, <var class="var">op</var> is <code class="code">~</code> for &lsquo;<samp class="samp">cond_one_cmpl<var class="var">mode</var></samp>&rsquo;.
</p>
<p>When defined for floating-point modes, the contents of &lsquo;<samp class="samp">op2[i]</samp>&rsquo;
are not interpreted if &lsquo;<samp class="samp">op1[i]</samp>&rsquo; is false, just like they would not
be in a normal C &lsquo;<samp class="samp">?:</samp>&rsquo; condition.
</p>
<p>Operands 0, 2, and 3 all have mode <var class="var">m</var>.  Operand 1 is a scalar
integer if <var class="var">m</var> is scalar, otherwise it has the mode returned by
<code class="code">TARGET_VECTORIZE_GET_MASK_MODE</code>.
</p>
<p>&lsquo;<samp class="samp">cond_<var class="var">op</var><var class="var">mode</var></samp>&rsquo; generally corresponds to a conditional
form of &lsquo;<samp class="samp"><var class="var">op</var><var class="var">mode</var>2</samp>&rsquo;.
</p>
</dd>
<dt><a class="index-entry-id" id="index-cond_005fsubmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005fmulmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005fdivmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005fudivmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005fmodmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005fumodmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005fandmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005fiormode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005fxormode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005fsminmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005fsmaxmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005fuminmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005fumaxmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005fcopysignmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005ffminmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005ffmaxmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005fashlmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005fashrmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005flshrmode-instruction-pattern"></a>
<a id="index-cond_005faddmode-instruction-pattern"></a><span>&lsquo;<samp class="samp">cond_add<var class="var">mode</var></samp>&rsquo;<a class="copiable-link" href="#index-cond_005faddmode-instruction-pattern"> &para;</a></span></dt>
<dt>&lsquo;<samp class="samp">cond_sub<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_mul<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_div<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_udiv<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_mod<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_umod<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_and<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_ior<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_xor<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_smin<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_smax<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_umin<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_umax<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_copysign<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_fmin<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_fmax<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_ashl<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_ashr<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_lshr<var class="var">mode</var></samp>&rsquo;</dt>
<dd><p>When operand 1 is true, perform an operation on operands 2 and 3 and
store the result in operand 0, otherwise store operand 4 in operand 0.
The operation works elementwise if the operands are vectors.
</p>
<p>The scalar case is equivalent to:
</p>
<div class="example smallexample">
<pre class="example-preformatted">op0 = op1 ? op2 <var class="var">op</var> op3 : op4;
</pre></div>

<p>while the vector case is equivalent to:
</p>
<div class="example smallexample">
<pre class="example-preformatted">for (i = 0; i &lt; GET_MODE_NUNITS (<var class="var">m</var>); i++)
  op0[i] = op1[i] ? op2[i] <var class="var">op</var> op3[i] : op4[i];
</pre></div>

<p>where, for example, <var class="var">op</var> is <code class="code">+</code> for &lsquo;<samp class="samp">cond_add<var class="var">mode</var></samp>&rsquo;.
</p>
<p>When defined for floating-point modes, the contents of &lsquo;<samp class="samp">op3[i]</samp>&rsquo;
are not interpreted if &lsquo;<samp class="samp">op1[i]</samp>&rsquo; is false, just like they would not
be in a normal C &lsquo;<samp class="samp">?:</samp>&rsquo; condition.
</p>
<p>Operands 0, 2, 3 and 4 all have mode <var class="var">m</var>.  Operand 1 is a scalar
integer if <var class="var">m</var> is scalar, otherwise it has the mode returned by
<code class="code">TARGET_VECTORIZE_GET_MASK_MODE</code>.
</p>
<p>&lsquo;<samp class="samp">cond_<var class="var">op</var><var class="var">mode</var></samp>&rsquo; generally corresponds to a conditional
form of &lsquo;<samp class="samp"><var class="var">op</var><var class="var">mode</var>3</samp>&rsquo;.  As an exception, the vector forms
of shifts correspond to patterns like <code class="code">vashl<var class="var">mode</var>3</code> rather
than patterns like <code class="code">ashl<var class="var">mode</var>3</code>.
</p>
<p>&lsquo;<samp class="samp">cond_copysign<var class="var">mode</var></samp>&rsquo; is only defined for floating point modes.
</p>
</dd>
<dt><a class="index-entry-id" id="index-cond_005ffmsmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005ffnmamode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005ffnmsmode-instruction-pattern"></a>
<a id="index-cond_005ffmamode-instruction-pattern"></a><span>&lsquo;<samp class="samp">cond_fma<var class="var">mode</var></samp>&rsquo;<a class="copiable-link" href="#index-cond_005ffmamode-instruction-pattern"> &para;</a></span></dt>
<dt>&lsquo;<samp class="samp">cond_fms<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_fnma<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_fnms<var class="var">mode</var></samp>&rsquo;</dt>
<dd><p>Like &lsquo;<samp class="samp">cond_add<var class="var">m</var></samp>&rsquo;, except that the conditional operation
takes 3 operands rather than two.  For example, the vector form of
&lsquo;<samp class="samp">cond_fma<var class="var">mode</var></samp>&rsquo; is equivalent to:
</p>
<div class="example smallexample">
<pre class="example-preformatted">for (i = 0; i &lt; GET_MODE_NUNITS (<var class="var">m</var>); i++)
  op0[i] = op1[i] ? fma (op2[i], op3[i], op4[i]) : op5[i];
</pre></div>

</dd>
<dt><a class="index-entry-id" id="index-cond_005flen_005fone_005fcmplmode-instruction-pattern"></a>
<a id="index-cond_005flen_005fnegmode-instruction-pattern"></a><span>&lsquo;<samp class="samp">cond_len_neg<var class="var">mode</var></samp>&rsquo;<a class="copiable-link" href="#index-cond_005flen_005fnegmode-instruction-pattern"> &para;</a></span></dt>
<dt>&lsquo;<samp class="samp">cond_len_one_cmpl<var class="var">mode</var></samp>&rsquo;</dt>
<dd><p>When operand 1 is true and element index &lt; operand 4 + operand 5, perform an operation on operands 1 and
store the result in operand 0, otherwise store operand 2 in operand 0.
The operation only works for the operands are vectors.
</p>
<div class="example smallexample">
<pre class="example-preformatted">for (i = 0; i &lt; GET_MODE_NUNITS (<var class="var">m</var>); i++)
  op0[i] = (i &lt; ops[4] + ops[5] &amp;&amp; op1[i]
            ? <var class="var">op</var> op2[i]
            : op3[i]);
</pre></div>

<p>where, for example, <var class="var">op</var> is <code class="code">~</code> for &lsquo;<samp class="samp">cond_len_one_cmpl<var class="var">mode</var></samp>&rsquo;.
</p>
<p>When defined for floating-point modes, the contents of &lsquo;<samp class="samp">op2[i]</samp>&rsquo;
are not interpreted if &lsquo;<samp class="samp">op1[i]</samp>&rsquo; is false, just like they would not
be in a normal C &lsquo;<samp class="samp">?:</samp>&rsquo; condition.
</p>
<p>Operands 0, 2, and 3 all have mode <var class="var">m</var>.  Operand 1 is a scalar
integer if <var class="var">m</var> is scalar, otherwise it has the mode returned by
<code class="code">TARGET_VECTORIZE_GET_MASK_MODE</code>.  Operand 4 has whichever
integer mode the target prefers.
</p>
<p>&lsquo;<samp class="samp">cond_len_<var class="var">op</var><var class="var">mode</var></samp>&rsquo; generally corresponds to a conditional
form of &lsquo;<samp class="samp"><var class="var">op</var><var class="var">mode</var>2</samp>&rsquo;.
</p>

</dd>
<dt><a class="index-entry-id" id="index-cond_005flen_005fsubmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005flen_005fmulmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005flen_005fdivmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005flen_005fudivmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005flen_005fmodmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005flen_005fumodmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005flen_005fandmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005flen_005fiormode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005flen_005fxormode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005flen_005fsminmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005flen_005fsmaxmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005flen_005fuminmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005flen_005fumaxmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005flen_005fcopysignmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005flen_005ffminmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005flen_005ffmaxmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005flen_005fashlmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005flen_005fashrmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005flen_005flshrmode-instruction-pattern"></a>
<a id="index-cond_005flen_005faddmode-instruction-pattern"></a><span>&lsquo;<samp class="samp">cond_len_add<var class="var">mode</var></samp>&rsquo;<a class="copiable-link" href="#index-cond_005flen_005faddmode-instruction-pattern"> &para;</a></span></dt>
<dt>&lsquo;<samp class="samp">cond_len_sub<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_len_mul<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_len_div<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_len_udiv<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_len_mod<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_len_umod<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_len_and<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_len_ior<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_len_xor<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_len_smin<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_len_smax<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_len_umin<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_len_umax<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_len_copysign<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_len_fmin<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_len_fmax<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_len_ashl<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_len_ashr<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_len_lshr<var class="var">mode</var></samp>&rsquo;</dt>
<dd><p>When operand 1 is true and element index &lt; operand 5 + operand 6, perform an operation on operands 2 and 3 and
store the result in operand 0, otherwise store operand 4 in operand 0.
The operation only works for the operands are vectors.
</p>
<div class="example smallexample">
<pre class="example-preformatted">for (i = 0; i &lt; GET_MODE_NUNITS (<var class="var">m</var>); i++)
  op0[i] = (i &lt; ops[5] + ops[6] &amp;&amp; op1[i]
            ? op2[i] <var class="var">op</var> op3[i]
            : op4[i]);
</pre></div>

<p>where, for example, <var class="var">op</var> is <code class="code">+</code> for &lsquo;<samp class="samp">cond_len_add<var class="var">mode</var></samp>&rsquo;.
</p>
<p>When defined for floating-point modes, the contents of &lsquo;<samp class="samp">op3[i]</samp>&rsquo;
are not interpreted if &lsquo;<samp class="samp">op1[i]</samp>&rsquo; is false, just like they would not
be in a normal C &lsquo;<samp class="samp">?:</samp>&rsquo; condition.
</p>
<p>Operands 0, 2, 3 and 4 all have mode <var class="var">m</var>.  Operand 1 is a scalar
integer if <var class="var">m</var> is scalar, otherwise it has the mode returned by
<code class="code">TARGET_VECTORIZE_GET_MASK_MODE</code>.  Operand 5 has whichever
integer mode the target prefers.
</p>
<p>&lsquo;<samp class="samp">cond_len_<var class="var">op</var><var class="var">mode</var></samp>&rsquo; generally corresponds to a conditional
form of &lsquo;<samp class="samp"><var class="var">op</var><var class="var">mode</var>3</samp>&rsquo;.  As an exception, the vector forms
of shifts correspond to patterns like <code class="code">vashl<var class="var">mode</var>3</code> rather
than patterns like <code class="code">ashl<var class="var">mode</var>3</code>.
</p>
<p>&lsquo;<samp class="samp">cond_len_copysign<var class="var">mode</var></samp>&rsquo; is only defined for floating point modes.
</p>
</dd>
<dt><a class="index-entry-id" id="index-cond_005flen_005ffmsmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005flen_005ffnmamode-instruction-pattern"></a>
<a class="index-entry-id" id="index-cond_005flen_005ffnmsmode-instruction-pattern"></a>
<a id="index-cond_005flen_005ffmamode-instruction-pattern"></a><span>&lsquo;<samp class="samp">cond_len_fma<var class="var">mode</var></samp>&rsquo;<a class="copiable-link" href="#index-cond_005flen_005ffmamode-instruction-pattern"> &para;</a></span></dt>
<dt>&lsquo;<samp class="samp">cond_len_fms<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_len_fnma<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">cond_len_fnms<var class="var">mode</var></samp>&rsquo;</dt>
<dd><p>Like &lsquo;<samp class="samp">cond_len_add<var class="var">m</var></samp>&rsquo;, except that the conditional operation
takes 3 operands rather than two.  For example, the vector form of
&lsquo;<samp class="samp">cond_len_fma<var class="var">mode</var></samp>&rsquo; is equivalent to:
</p>
<div class="example smallexample">
<pre class="example-preformatted">for (i = 0; i &lt; GET_MODE_NUNITS (<var class="var">m</var>); i++)
  op0[i] = (i &lt; ops[6] + ops[7] &amp;&amp; op1[i]
            ? fma (op2[i], op3[i], op4[i])
            : op5[i]);
</pre></div>

</dd>
<dt><a id="index-negmodecc-instruction-pattern"></a><span>&lsquo;<samp class="samp">neg<var class="var">mode</var>cc</samp>&rsquo;<a class="copiable-link" href="#index-negmodecc-instruction-pattern"> &para;</a></span></dt>
<dd><p>Similar to &lsquo;<samp class="samp">mov<var class="var">mode</var>cc</samp>&rsquo; but for conditional negation.  Conditionally
move the negation of operand 2 or the unchanged operand 3 into operand 0
according to the comparison in operand 1.  If the comparison is true, the negation
of operand 2 is moved into operand 0, otherwise operand 3 is moved.
</p>
</dd>
<dt><a id="index-notmodecc-instruction-pattern"></a><span>&lsquo;<samp class="samp">not<var class="var">mode</var>cc</samp>&rsquo;<a class="copiable-link" href="#index-notmodecc-instruction-pattern"> &para;</a></span></dt>
<dd><p>Similar to &lsquo;<samp class="samp">neg<var class="var">mode</var>cc</samp>&rsquo; but for conditional complement.
Conditionally move the bitwise complement of operand 2 or the unchanged
operand 3 into operand 0 according to the comparison in operand 1.
If the comparison is true, the complement of operand 2 is moved into
operand 0, otherwise operand 3 is moved.
</p>
</dd>
<dt><a id="index-cstoremode4-instruction-pattern"></a><span>&lsquo;<samp class="samp">cstore<var class="var">mode</var>4</samp>&rsquo;<a class="copiable-link" href="#index-cstoremode4-instruction-pattern"> &para;</a></span></dt>
<dd><p>Store zero or nonzero in operand 0 according to whether a comparison
is true.  Operand 1 is a comparison operator.  Operand 2 and operand 3
are the first and second operand of the comparison, respectively.
You specify the mode that operand 0 must have when you write the
<code class="code">match_operand</code> expression.  The compiler automatically sees which
mode you have used and supplies an operand of that mode.
</p>
<p>The value stored for a true condition must have 1 as its low bit, or
else must be negative.  Otherwise the instruction is not suitable and
you should omit it from the machine description.  You describe to the
compiler exactly which value is stored by defining the macro
<code class="code">STORE_FLAG_VALUE</code> (see <a class="pxref" href="Misc.html">Miscellaneous Parameters</a>).  If a description cannot be
found that can be used for all the possible comparison operators, you
should pick one and use a <code class="code">define_expand</code> to map all results
onto the one you chose.
</p>
<p>These operations may <code class="code">FAIL</code>, but should do so only in relatively
uncommon cases; if they would <code class="code">FAIL</code> for common cases involving
integer comparisons, it is best to restrict the predicates to not
allow these operands.  Likewise if a given comparison operator will
always fail, independent of the operands (for floating-point modes, the
<code class="code">ordered_comparison_operator</code> predicate is often useful in this case).
</p>
<p>If this pattern is omitted, the compiler will generate a conditional
branch&mdash;for example, it may copy a constant one to the target and branching
around an assignment of zero to the target&mdash;or a libcall.  If the predicate
for operand 1 only rejects some operators, it will also try reordering the
operands and/or inverting the result value (e.g. by an exclusive OR).
These possibilities could be cheaper or equivalent to the instructions
used for the &lsquo;<samp class="samp">cstore<var class="var">mode</var>4</samp>&rsquo; pattern followed by those required
to convert a positive result from <code class="code">STORE_FLAG_VALUE</code> to 1; in this
case, you can and should make operand 1&rsquo;s predicate reject some operators
in the &lsquo;<samp class="samp">cstore<var class="var">mode</var>4</samp>&rsquo; pattern, or remove the pattern altogether
from the machine description.
</p>
</dd>
<dt><a id="index-tbranch_005fopmode3-instruction-pattern"></a><span>&lsquo;<samp class="samp">tbranch_<var class="var">op</var><var class="var">mode</var>3</samp>&rsquo;<a class="copiable-link" href="#index-tbranch_005fopmode3-instruction-pattern"> &para;</a></span></dt>
<dd><p>Conditional branch instruction combined with a bit test-and-compare
instruction. Operand 0 is the operand of the comparison.  Operand 1 is the bit
position of Operand 1 to test.  Operand 3 is the <code class="code">code_label</code> to jump to.
<var class="var">op</var> is one of <var class="var">eq</var> or <var class="var">ne</var>.
</p>
</dd>
<dt><a id="index-cbranchmode4-instruction-pattern"></a><span>&lsquo;<samp class="samp">cbranch<var class="var">mode</var>4</samp>&rsquo;<a class="copiable-link" href="#index-cbranchmode4-instruction-pattern"> &para;</a></span></dt>
<dd><p>Conditional branch instruction combined with a compare instruction.
Operand 0 is a comparison operator.  Operand 1 and operand 2 are the
first and second operands of the comparison, respectively.  Operand 3
is the <code class="code">code_label</code> to jump to.
</p>
</dd>
<dt><a id="index-jump-instruction-pattern"></a><span>&lsquo;<samp class="samp">jump</samp>&rsquo;<a class="copiable-link" href="#index-jump-instruction-pattern"> &para;</a></span></dt>
<dd><p>A jump inside a function; an unconditional branch.  Operand 0 is the
<code class="code">code_label</code> to jump to.  This pattern name is mandatory on all
machines.
</p>
</dd>
<dt><a id="index-call-instruction-pattern"></a><span>&lsquo;<samp class="samp">call</samp>&rsquo;<a class="copiable-link" href="#index-call-instruction-pattern"> &para;</a></span></dt>
<dd><p>Subroutine call instruction returning no value.  Operand 0 is the
function to call; operand 1 is the number of bytes of arguments pushed
as a <code class="code">const_int</code>.  Operand 2 is the result of calling the target
hook <code class="code">TARGET_FUNCTION_ARG</code> with the second argument <code class="code">arg</code>
yielding true for <code class="code">arg.end_marker_p ()</code>, in a call after all
parameters have been passed to that hook.  By default this is the first
register beyond those used for arguments in the call, or <code class="code">NULL</code> if
all the argument-registers are used in the call.
</p>
<p>On most machines, operand 2 is not actually stored into the RTL
pattern.  It is supplied for the sake of some RISC machines which need
to put this information into the assembler code; they can put it in
the RTL instead of operand 1.
</p>
<p>Operand 0 should be a <code class="code">mem</code> RTX whose address is the address of the
function.  Note, however, that this address can be a <code class="code">symbol_ref</code>
expression even if it would not be a legitimate memory address on the
target machine.  If it is also not a valid argument for a call
instruction, the pattern for this operation should be a
<code class="code">define_expand</code> (see <a class="pxref" href="Expander-Definitions.html">Defining RTL Sequences for Code Generation</a>) that places the
address into a register and uses that register in the call instruction.
</p>
</dd>
<dt><a id="index-call_005fvalue-instruction-pattern"></a><span>&lsquo;<samp class="samp">call_value</samp>&rsquo;<a class="copiable-link" href="#index-call_005fvalue-instruction-pattern"> &para;</a></span></dt>
<dd><p>Subroutine call instruction returning a value.  Operand 0 is the hard
register in which the value is returned.  There are three more
operands, the same as the three operands of the &lsquo;<samp class="samp">call</samp>&rsquo;
instruction (but with numbers increased by one).
</p>
<p>Subroutines that return <code class="code">BLKmode</code> objects use the &lsquo;<samp class="samp">call</samp>&rsquo;
insn.
</p>
</dd>
<dt><a class="index-entry-id" id="index-call_005fvalue_005fpop-instruction-pattern"></a>
<a id="index-call_005fpop-instruction-pattern"></a><span>&lsquo;<samp class="samp">call_pop</samp>&rsquo;, &lsquo;<samp class="samp">call_value_pop</samp>&rsquo;<a class="copiable-link" href="#index-call_005fpop-instruction-pattern"> &para;</a></span></dt>
<dd><p>Similar to &lsquo;<samp class="samp">call</samp>&rsquo; and &lsquo;<samp class="samp">call_value</samp>&rsquo;, except used if defined and
if <code class="code">RETURN_POPS_ARGS</code> is nonzero.  They should emit a <code class="code">parallel</code>
that contains both the function call and a <code class="code">set</code> to indicate the
adjustment made to the frame pointer.
</p>
<p>For machines where <code class="code">RETURN_POPS_ARGS</code> can be nonzero, the use of these
patterns increases the number of functions for which the frame pointer
can be eliminated, if desired.
</p>
</dd>
<dt><a id="index-untyped_005fcall-instruction-pattern"></a><span>&lsquo;<samp class="samp">untyped_call</samp>&rsquo;<a class="copiable-link" href="#index-untyped_005fcall-instruction-pattern"> &para;</a></span></dt>
<dd><p>Subroutine call instruction returning a value of any type.  Operand 0 is
the function to call; operand 1 is a memory location where the result of
calling the function is to be stored; operand 2 is a <code class="code">parallel</code>
expression where each element is a <code class="code">set</code> expression that indicates
the saving of a function return value into the result block.
</p>
<p>This instruction pattern should be defined to support
<code class="code">__builtin_apply</code> on machines where special instructions are needed
to call a subroutine with arbitrary arguments or to save the value
returned.  This instruction pattern is required on machines that have
multiple registers that can hold a return value
(i.e. <code class="code">FUNCTION_VALUE_REGNO_P</code> is true for more than one register).
</p>
</dd>
<dt><a id="index-return-instruction-pattern"></a><span>&lsquo;<samp class="samp">return</samp>&rsquo;<a class="copiable-link" href="#index-return-instruction-pattern"> &para;</a></span></dt>
<dd><p>Subroutine return instruction.  This instruction pattern name should be
defined only if a single instruction can do all the work of returning
from a function.
</p>
<p>Like the &lsquo;<samp class="samp">mov<var class="var">m</var></samp>&rsquo; patterns, this pattern is also used after the
RTL generation phase.  In this case it is to support machines where
multiple instructions are usually needed to return from a function, but
some class of functions only requires one instruction to implement a
return.  Normally, the applicable functions are those which do not need
to save any registers or allocate stack space.
</p>
<p>It is valid for this pattern to expand to an instruction using
<code class="code">simple_return</code> if no epilogue is required.
</p>
</dd>
<dt><a id="index-simple_005freturn-instruction-pattern"></a><span>&lsquo;<samp class="samp">simple_return</samp>&rsquo;<a class="copiable-link" href="#index-simple_005freturn-instruction-pattern"> &para;</a></span></dt>
<dd><p>Subroutine return instruction.  This instruction pattern name should be
defined only if a single instruction can do all the work of returning
from a function on a path where no epilogue is required.  This pattern
is very similar to the <code class="code">return</code> instruction pattern, but it is emitted
only by the shrink-wrapping optimization on paths where the function
prologue has not been executed, and a function return should occur without
any of the effects of the epilogue.  Additional uses may be introduced on
paths where both the prologue and the epilogue have executed.
</p>
<a class="index-entry-id" id="index-reload_005fcompleted"></a>
<a class="index-entry-id" id="index-leaf_005ffunction_005fp"></a>
<p>For such machines, the condition specified in this pattern should only
be true when <code class="code">reload_completed</code> is nonzero and the function&rsquo;s
epilogue would only be a single instruction.  For machines with register
windows, the routine <code class="code">leaf_function_p</code> may be used to determine if
a register window push is required.
</p>
<p>Machines that have conditional return instructions should define patterns
such as
</p>
<div class="example smallexample">
<pre class="example-preformatted">(define_insn &quot;&quot;
  [(set (pc)
        (if_then_else (match_operator
                         0 &quot;comparison_operator&quot;
                         [(reg:CC CC_REG) (const_int 0)])
                      (return)
                      (pc)))]
  &quot;<var class="var">condition</var>&quot;
  &quot;...&quot;)
</pre></div>

<p>where <var class="var">condition</var> would normally be the same condition specified on the
named &lsquo;<samp class="samp">return</samp>&rsquo; pattern.
</p>
</dd>
<dt><a id="index-untyped_005freturn-instruction-pattern"></a><span>&lsquo;<samp class="samp">untyped_return</samp>&rsquo;<a class="copiable-link" href="#index-untyped_005freturn-instruction-pattern"> &para;</a></span></dt>
<dd><p>Untyped subroutine return instruction.  This instruction pattern should
be defined to support <code class="code">__builtin_return</code> on machines where special
instructions are needed to return a value of any type.
</p>
<p>Operand 0 is a memory location where the result of calling a function
with <code class="code">__builtin_apply</code> is stored; operand 1 is a <code class="code">parallel</code>
expression where each element is a <code class="code">set</code> expression that indicates
the restoring of a function return value from the result block.
</p>
</dd>
<dt><a id="index-nop-instruction-pattern"></a><span>&lsquo;<samp class="samp">nop</samp>&rsquo;<a class="copiable-link" href="#index-nop-instruction-pattern"> &para;</a></span></dt>
<dd><p>No-op instruction.  This instruction pattern name should always be defined
to output a no-op in assembler code.  <code class="code">(const_int 0)</code> will do as an
RTL pattern.
</p>
</dd>
<dt><a id="index-indirect_005fjump-instruction-pattern"></a><span>&lsquo;<samp class="samp">indirect_jump</samp>&rsquo;<a class="copiable-link" href="#index-indirect_005fjump-instruction-pattern"> &para;</a></span></dt>
<dd><p>An instruction to jump to an address which is operand zero.
This pattern name is mandatory on all machines.
</p>
</dd>
<dt><a id="index-casesi-instruction-pattern"></a><span>&lsquo;<samp class="samp">casesi</samp>&rsquo;<a class="copiable-link" href="#index-casesi-instruction-pattern"> &para;</a></span></dt>
<dd><p>Instruction to jump through a dispatch table, including bounds checking.
This instruction takes five operands:
</p>
<ol class="enumerate">
<li> The index to dispatch on, which has mode <code class="code">SImode</code>.

</li><li> The lower bound for indices in the table, an integer constant.

</li><li> The total range of indices in the table&mdash;the largest index
minus the smallest one (both inclusive).

</li><li> A label that precedes the table itself.

</li><li> A label to jump to if the index has a value outside the bounds.
</li></ol>

<p>The table is an <code class="code">addr_vec</code> or <code class="code">addr_diff_vec</code> inside of a
<code class="code">jump_table_data</code>.  The number of elements in the table is one plus the
difference between the upper bound and the lower bound.
</p>
</dd>
<dt><a id="index-tablejump-instruction-pattern"></a><span>&lsquo;<samp class="samp">tablejump</samp>&rsquo;<a class="copiable-link" href="#index-tablejump-instruction-pattern"> &para;</a></span></dt>
<dd><p>Instruction to jump to a variable address.  This is a low-level
capability which can be used to implement a dispatch table when there
is no &lsquo;<samp class="samp">casesi</samp>&rsquo; pattern.
</p>
<p>This pattern requires two operands: the address or offset, and a label
which should immediately precede the jump table.  If the macro
<code class="code">CASE_VECTOR_PC_RELATIVE</code> evaluates to a nonzero value then the first
operand is an offset which counts from the address of the table; otherwise,
it is an absolute address to jump to.  In either case, the first operand has
mode <code class="code">Pmode</code>.
</p>
<p>The &lsquo;<samp class="samp">tablejump</samp>&rsquo; insn is always the last insn before the jump
table it uses.  Its assembler code normally has no need to use the
second operand, but you should incorporate it in the RTL pattern so
that the jump optimizer will not delete the table as unreachable code.
</p>

</dd>
<dt><a id="index-doloop_005fend-instruction-pattern"></a><span>&lsquo;<samp class="samp">doloop_end</samp>&rsquo;<a class="copiable-link" href="#index-doloop_005fend-instruction-pattern"> &para;</a></span></dt>
<dd><p>Conditional branch instruction that decrements a register and
jumps if the register is nonzero.  Operand 0 is the register to
decrement and test; operand 1 is the label to jump to if the
register is nonzero.
See <a class="xref" href="Looping-Patterns.html">Defining Looping Instruction Patterns</a>.
</p>
<p>This optional instruction pattern should be defined for machines with
low-overhead looping instructions as the loop optimizer will try to
modify suitable loops to utilize it.  The target hook
<code class="code">TARGET_CAN_USE_DOLOOP_P</code> controls the conditions under which
low-overhead loops can be used.
</p>
</dd>
<dt><a id="index-doloop_005fbegin-instruction-pattern"></a><span>&lsquo;<samp class="samp">doloop_begin</samp>&rsquo;<a class="copiable-link" href="#index-doloop_005fbegin-instruction-pattern"> &para;</a></span></dt>
<dd><p>Companion instruction to <code class="code">doloop_end</code> required for machines that
need to perform some initialization, such as loading a special counter
register.  Operand 1 is the associated <code class="code">doloop_end</code> pattern and
operand 0 is the register that it decrements.
</p>
<p>If initialization insns do not always need to be emitted, use a
<code class="code">define_expand</code> (see <a class="pxref" href="Expander-Definitions.html">Defining RTL Sequences for Code Generation</a>) and make it fail.
</p>
</dd>
<dt><a id="index-canonicalize_005ffuncptr_005ffor_005fcompare-instruction-pattern"></a><span>&lsquo;<samp class="samp">canonicalize_funcptr_for_compare</samp>&rsquo;<a class="copiable-link" href="#index-canonicalize_005ffuncptr_005ffor_005fcompare-instruction-pattern"> &para;</a></span></dt>
<dd><p>Canonicalize the function pointer in operand 1 and store the result
into operand 0.
</p>
<p>Operand 0 is always a <code class="code">reg</code> and has mode <code class="code">Pmode</code>; operand 1
may be a <code class="code">reg</code>, <code class="code">mem</code>, <code class="code">symbol_ref</code>, <code class="code">const_int</code>, etc
and also has mode <code class="code">Pmode</code>.
</p>
<p>Canonicalization of a function pointer usually involves computing
the address of the function which would be called if the function
pointer were used in an indirect call.
</p>
<p>Only define this pattern if function pointers on the target machine
can have different values but still call the same function when
used in an indirect call.
</p>
</dd>
<dt><a class="index-entry-id" id="index-save_005fstack_005ffunction-instruction-pattern"></a>
<a class="index-entry-id" id="index-save_005fstack_005fnonlocal-instruction-pattern"></a>
<a class="index-entry-id" id="index-restore_005fstack_005fblock-instruction-pattern"></a>
<a class="index-entry-id" id="index-restore_005fstack_005ffunction-instruction-pattern"></a>
<a class="index-entry-id" id="index-restore_005fstack_005fnonlocal-instruction-pattern"></a>
<a id="index-save_005fstack_005fblock-instruction-pattern"></a><span>&lsquo;<samp class="samp">save_stack_block</samp>&rsquo;<a class="copiable-link" href="#index-save_005fstack_005fblock-instruction-pattern"> &para;</a></span></dt>
<dt>&lsquo;<samp class="samp">save_stack_function</samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">save_stack_nonlocal</samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">restore_stack_block</samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">restore_stack_function</samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">restore_stack_nonlocal</samp>&rsquo;</dt>
<dd><p>Most machines save and restore the stack pointer by copying it to or
from an object of mode <code class="code">Pmode</code>.  Do not define these patterns on
such machines.
</p>
<p>Some machines require special handling for stack pointer saves and
restores.  On those machines, define the patterns corresponding to the
non-standard cases by using a <code class="code">define_expand</code> (see <a class="pxref" href="Expander-Definitions.html">Defining RTL Sequences for Code Generation</a>) that produces the required insns.  The three types of
saves and restores are:
</p>
<ol class="enumerate">
<li> &lsquo;<samp class="samp">save_stack_block</samp>&rsquo; saves the stack pointer at the start of a block
that allocates a variable-sized object, and &lsquo;<samp class="samp">restore_stack_block</samp>&rsquo;
restores the stack pointer when the block is exited.

</li><li> &lsquo;<samp class="samp">save_stack_function</samp>&rsquo; and &lsquo;<samp class="samp">restore_stack_function</samp>&rsquo; do a
similar job for the outermost block of a function and are used when the
function allocates variable-sized objects or calls <code class="code">alloca</code>.  Only
the epilogue uses the restored stack pointer, allowing a simpler save or
restore sequence on some machines.

</li><li> &lsquo;<samp class="samp">save_stack_nonlocal</samp>&rsquo; is used in functions that contain labels
branched to by nested functions.  It saves the stack pointer in such a
way that the inner function can use &lsquo;<samp class="samp">restore_stack_nonlocal</samp>&rsquo; to
restore the stack pointer.  The compiler generates code to restore the
frame and argument pointer registers, but some machines require saving
and restoring additional data such as register window information or
stack backchains.  Place insns in these patterns to save and restore any
such required data.
</li></ol>

<p>When saving the stack pointer, operand 0 is the save area and operand 1
is the stack pointer.  The mode used to allocate the save area defaults
to <code class="code">Pmode</code> but you can override that choice by defining the
<code class="code">STACK_SAVEAREA_MODE</code> macro (see <a class="pxref" href="Storage-Layout.html">Storage Layout</a>).  You must
specify an integral mode, or <code class="code">VOIDmode</code> if no save area is needed
for a particular type of save (either because no save is needed or
because a machine-specific save area can be used).  Operand 0 is the
stack pointer and operand 1 is the save area for restore operations.  If
&lsquo;<samp class="samp">save_stack_block</samp>&rsquo; is defined, operand 0 must not be
<code class="code">VOIDmode</code> since these saves can be arbitrarily nested.
</p>
<p>A save area is a <code class="code">mem</code> that is at a constant offset from
<code class="code">virtual_stack_vars_rtx</code> when the stack pointer is saved for use by
nonlocal gotos and a <code class="code">reg</code> in the other two cases.
</p>
</dd>
<dt><a id="index-allocate_005fstack-instruction-pattern"></a><span>&lsquo;<samp class="samp">allocate_stack</samp>&rsquo;<a class="copiable-link" href="#index-allocate_005fstack-instruction-pattern"> &para;</a></span></dt>
<dd><p>Subtract (or add if <code class="code">STACK_GROWS_DOWNWARD</code> is undefined) operand 1 from
the stack pointer to create space for dynamically allocated data.
</p>
<p>Store the resultant pointer to this space into operand 0.  If you
are allocating space from the main stack, do this by emitting a
move insn to copy <code class="code">virtual_stack_dynamic_rtx</code> to operand 0.
If you are allocating the space elsewhere, generate code to copy the
location of the space to operand 0.  In the latter case, you must
ensure this space gets freed when the corresponding space on the main
stack is free.
</p>
<p>Do not define this pattern if all that must be done is the subtraction.
Some machines require other operations such as stack probes or
maintaining the back chain.  Define this pattern to emit those
operations in addition to updating the stack pointer.
</p>
</dd>
<dt><a id="index-check_005fstack-instruction-pattern"></a><span>&lsquo;<samp class="samp">check_stack</samp>&rsquo;<a class="copiable-link" href="#index-check_005fstack-instruction-pattern"> &para;</a></span></dt>
<dd><p>If stack checking (see <a class="pxref" href="Stack-Checking.html">Specifying How Stack Checking is Done</a>) cannot be done on your system by
probing the stack, define this pattern to perform the needed check and signal
an error if the stack has overflowed.  The single operand is the address in
the stack farthest from the current stack pointer that you need to validate.
Normally, on platforms where this pattern is needed, you would obtain the
stack limit from a global or thread-specific variable or register.
</p>
</dd>
<dt><a id="index-probe_005fstack_005faddress-instruction-pattern"></a><span>&lsquo;<samp class="samp">probe_stack_address</samp>&rsquo;<a class="copiable-link" href="#index-probe_005fstack_005faddress-instruction-pattern"> &para;</a></span></dt>
<dd><p>If stack checking (see <a class="pxref" href="Stack-Checking.html">Specifying How Stack Checking is Done</a>) can be done on your system by
probing the stack but without the need to actually access it, define this
pattern and signal an error if the stack has overflowed.  The single operand
is the memory address in the stack that needs to be probed.
</p>
</dd>
<dt><a id="index-probe_005fstack-instruction-pattern"></a><span>&lsquo;<samp class="samp">probe_stack</samp>&rsquo;<a class="copiable-link" href="#index-probe_005fstack-instruction-pattern"> &para;</a></span></dt>
<dd><p>If stack checking (see <a class="pxref" href="Stack-Checking.html">Specifying How Stack Checking is Done</a>) can be done on your system by
probing the stack but doing it with a &ldquo;store zero&rdquo; instruction is not valid
or optimal, define this pattern to do the probing differently and signal an
error if the stack has overflowed.  The single operand is the memory reference
in the stack that needs to be probed.
</p>
</dd>
<dt><a id="index-nonlocal_005fgoto-instruction-pattern"></a><span>&lsquo;<samp class="samp">nonlocal_goto</samp>&rsquo;<a class="copiable-link" href="#index-nonlocal_005fgoto-instruction-pattern"> &para;</a></span></dt>
<dd><p>Emit code to generate a non-local goto, e.g., a jump from one function
to a label in an outer function.  This pattern has four arguments,
each representing a value to be used in the jump.  The first
argument is to be loaded into the frame pointer, the second is
the address to branch to (code to dispatch to the actual label),
the third is the address of a location where the stack is saved,
and the last is the address of the label, to be placed in the
location for the incoming static chain.
</p>
<p>On most machines you need not define this pattern, since GCC will
already generate the correct code, which is to load the frame pointer
and static chain, restore the stack (using the
&lsquo;<samp class="samp">restore_stack_nonlocal</samp>&rsquo; pattern, if defined), and jump indirectly
to the dispatcher.  You need only define this pattern if this code will
not work on your machine.
</p>
</dd>
<dt><a id="index-nonlocal_005fgoto_005freceiver-instruction-pattern"></a><span>&lsquo;<samp class="samp">nonlocal_goto_receiver</samp>&rsquo;<a class="copiable-link" href="#index-nonlocal_005fgoto_005freceiver-instruction-pattern"> &para;</a></span></dt>
<dd><p>This pattern, if defined, contains code needed at the target of a
nonlocal goto after the code already generated by GCC.  You will not
normally need to define this pattern.  A typical reason why you might
need this pattern is if some value, such as a pointer to a global table,
must be restored when the frame pointer is restored.  Note that a nonlocal
goto only occurs within a unit-of-translation, so a global table pointer
that is shared by all functions of a given module need not be restored.
There are no arguments.
</p>
</dd>
<dt><a id="index-exception_005freceiver-instruction-pattern"></a><span>&lsquo;<samp class="samp">exception_receiver</samp>&rsquo;<a class="copiable-link" href="#index-exception_005freceiver-instruction-pattern"> &para;</a></span></dt>
<dd><p>This pattern, if defined, contains code needed at the site of an
exception handler that isn&rsquo;t needed at the site of a nonlocal goto.  You
will not normally need to define this pattern.  A typical reason why you
might need this pattern is if some value, such as a pointer to a global
table, must be restored after control flow is branched to the handler of
an exception.  There are no arguments.
</p>
</dd>
<dt><a id="index-builtin_005fsetjmp_005fsetup-instruction-pattern"></a><span>&lsquo;<samp class="samp">builtin_setjmp_setup</samp>&rsquo;<a class="copiable-link" href="#index-builtin_005fsetjmp_005fsetup-instruction-pattern"> &para;</a></span></dt>
<dd><p>This pattern, if defined, contains additional code needed to initialize
the <code class="code">jmp_buf</code>.  You will not normally need to define this pattern.
A typical reason why you might need this pattern is if some value, such
as a pointer to a global table, must be restored.  Though it is
preferred that the pointer value be recalculated if possible (given the
address of a label for instance).  The single argument is a pointer to
the <code class="code">jmp_buf</code>.  Note that the buffer is five words long and that
the first three are normally used by the generic mechanism.
</p>
</dd>
<dt><a id="index-builtin_005fsetjmp_005freceiver-instruction-pattern"></a><span>&lsquo;<samp class="samp">builtin_setjmp_receiver</samp>&rsquo;<a class="copiable-link" href="#index-builtin_005fsetjmp_005freceiver-instruction-pattern"> &para;</a></span></dt>
<dd><p>This pattern, if defined, contains code needed at the site of a
built-in setjmp that isn&rsquo;t needed at the site of a nonlocal goto.  You
will not normally need to define this pattern.  A typical reason why you
might need this pattern is if some value, such as a pointer to a global
table, must be restored.  It takes one argument, which is the label
to which builtin_longjmp transferred control; this pattern may be emitted
at a small offset from that label.
</p>
</dd>
<dt><a id="index-builtin_005flongjmp-instruction-pattern"></a><span>&lsquo;<samp class="samp">builtin_longjmp</samp>&rsquo;<a class="copiable-link" href="#index-builtin_005flongjmp-instruction-pattern"> &para;</a></span></dt>
<dd><p>This pattern, if defined, performs the entire action of the longjmp.
You will not normally need to define this pattern unless you also define
<code class="code">builtin_setjmp_setup</code>.  The single argument is a pointer to the
<code class="code">jmp_buf</code>.
</p>
</dd>
<dt><a id="index-eh_005freturn-instruction-pattern"></a><span>&lsquo;<samp class="samp">eh_return</samp>&rsquo;<a class="copiable-link" href="#index-eh_005freturn-instruction-pattern"> &para;</a></span></dt>
<dd><p>This pattern, if defined, affects the way <code class="code">__builtin_eh_return</code>,
and thence the call frame exception handling library routines, are
built.  It is intended to handle non-trivial actions needed along
the abnormal return path.
</p>
<p>The address of the exception handler to which the function should return
is passed as operand to this pattern.  It will normally need to copied by
the pattern to some special register or memory location.
If the pattern needs to determine the location of the target call
frame in order to do so, it may use <code class="code">EH_RETURN_STACKADJ_RTX</code>,
if defined; it will have already been assigned.
</p>
<p>If this pattern is not defined, the default action will be to simply
copy the return address to <code class="code">EH_RETURN_HANDLER_RTX</code>.  Either
that macro or this pattern needs to be defined if call frame exception
handling is to be used.
</p>
<a class="index-entry-id" id="index-prologue-instruction-pattern"></a>
<a class="anchor" id="prologue-instruction-pattern"></a></dd>
<dt>&lsquo;<samp class="samp">prologue</samp>&rsquo;</dt>
<dd><p>This pattern, if defined, emits RTL for entry to a function.  The function
entry is responsible for setting up the stack frame, initializing the frame
pointer register, saving callee saved registers, etc.
</p>
<p>Using a prologue pattern is generally preferred over defining
<code class="code">TARGET_ASM_FUNCTION_PROLOGUE</code> to emit assembly code for the prologue.
</p>
<p>The <code class="code">prologue</code> pattern is particularly useful for targets which perform
instruction scheduling.
</p>
<a class="index-entry-id" id="index-window_005fsave-instruction-pattern"></a>
<a class="anchor" id="window_005fsave-instruction-pattern"></a></dd>
<dt>&lsquo;<samp class="samp">window_save</samp>&rsquo;</dt>
<dd><p>This pattern, if defined, emits RTL for a register window save.  It should
be defined if the target machine has register windows but the window events
are decoupled from calls to subroutines.  The canonical example is the SPARC
architecture.
</p>
<a class="index-entry-id" id="index-epilogue-instruction-pattern"></a>
<a class="anchor" id="epilogue-instruction-pattern"></a></dd>
<dt>&lsquo;<samp class="samp">epilogue</samp>&rsquo;</dt>
<dd><p>This pattern emits RTL for exit from a function.  The function
exit is responsible for deallocating the stack frame, restoring callee saved
registers and emitting the return instruction.
</p>
<p>Using an epilogue pattern is generally preferred over defining
<code class="code">TARGET_ASM_FUNCTION_EPILOGUE</code> to emit assembly code for the epilogue.
</p>
<p>The <code class="code">epilogue</code> pattern is particularly useful for targets which perform
instruction scheduling or which have delay slots for their return instruction.
</p>
</dd>
<dt><a id="index-sibcall_005fepilogue-instruction-pattern"></a><span>&lsquo;<samp class="samp">sibcall_epilogue</samp>&rsquo;<a class="copiable-link" href="#index-sibcall_005fepilogue-instruction-pattern"> &para;</a></span></dt>
<dd><p>This pattern, if defined, emits RTL for exit from a function without the final
branch back to the calling function.  This pattern will be emitted before any
sibling call (aka tail call) sites.
</p>
<p>The <code class="code">sibcall_epilogue</code> pattern must not clobber any arguments used for
parameter passing or any stack slots for arguments passed to the current
function.
</p>
</dd>
<dt><a id="index-trap-instruction-pattern"></a><span>&lsquo;<samp class="samp">trap</samp>&rsquo;<a class="copiable-link" href="#index-trap-instruction-pattern"> &para;</a></span></dt>
<dd><p>This pattern, if defined, signals an error, typically by causing some
kind of signal to be raised.
</p>
</dd>
<dt><a id="index-ctrapMM4-instruction-pattern"></a><span>&lsquo;<samp class="samp">ctrap<var class="var">MM</var>4</samp>&rsquo;<a class="copiable-link" href="#index-ctrapMM4-instruction-pattern"> &para;</a></span></dt>
<dd><p>Conditional trap instruction.  Operand 0 is a piece of RTL which
performs a comparison, and operands 1 and 2 are the arms of the
comparison.  Operand 3 is the trap code, an integer.
</p>
<p>A typical <code class="code">ctrap</code> pattern looks like
</p>
<div class="example smallexample">
<pre class="example-preformatted">(define_insn &quot;ctrapsi4&quot;
  [(trap_if (match_operator 0 &quot;trap_operator&quot;
             [(match_operand 1 &quot;register_operand&quot;)
              (match_operand 2 &quot;immediate_operand&quot;)])
            (match_operand 3 &quot;const_int_operand&quot; &quot;i&quot;))]
  &quot;&quot;
  &quot;...&quot;)
</pre></div>

</dd>
<dt><a id="index-prefetch-instruction-pattern"></a><span>&lsquo;<samp class="samp">prefetch</samp>&rsquo;<a class="copiable-link" href="#index-prefetch-instruction-pattern"> &para;</a></span></dt>
<dd><p>This pattern, if defined, emits code for a non-faulting data prefetch
instruction.  Operand 0 is the address of the memory to prefetch.  Operand 1
is a constant 1 if the prefetch is preparing for a write to the memory
address, or a constant 0 otherwise.  Operand 2 is the expected degree of
temporal locality of the data and is a value between 0 and 3, inclusive; 0
means that the data has no temporal locality, so it need not be left in the
cache after the access; 3 means that the data has a high degree of temporal
locality and should be left in all levels of cache possible;  1 and 2 mean,
respectively, a low or moderate degree of temporal locality.
</p>
<p>Targets that do not support write prefetches or locality hints can ignore
the values of operands 1 and 2.
</p>
</dd>
<dt><a id="index-blockage-instruction-pattern"></a><span>&lsquo;<samp class="samp">blockage</samp>&rsquo;<a class="copiable-link" href="#index-blockage-instruction-pattern"> &para;</a></span></dt>
<dd><p>This pattern defines a pseudo insn that prevents the instruction
scheduler and other passes from moving instructions and using register
equivalences across the boundary defined by the blockage insn.
This needs to be an UNSPEC_VOLATILE pattern or a volatile ASM.
</p>
</dd>
<dt><a id="index-memory_005fblockage-instruction-pattern"></a><span>&lsquo;<samp class="samp">memory_blockage</samp>&rsquo;<a class="copiable-link" href="#index-memory_005fblockage-instruction-pattern"> &para;</a></span></dt>
<dd><p>This pattern, if defined, represents a compiler memory barrier, and will be
placed at points across which RTL passes may not propagate memory accesses.
This instruction needs to read and write volatile BLKmode memory.  It does
not need to generate any machine instruction.  If this pattern is not defined,
the compiler falls back to emitting an instruction corresponding
to <code class="code">asm volatile (&quot;&quot; ::: &quot;memory&quot;)</code>.
</p>
</dd>
<dt><a id="index-memory_005fbarrier-instruction-pattern"></a><span>&lsquo;<samp class="samp">memory_barrier</samp>&rsquo;<a class="copiable-link" href="#index-memory_005fbarrier-instruction-pattern"> &para;</a></span></dt>
<dd><p>If the target memory model is not fully synchronous, then this pattern
should be defined to an instruction that orders both loads and stores
before the instruction with respect to loads and stores after the instruction.
This pattern has no operands.
</p>
</dd>
<dt><a id="index-speculation_005fbarrier-instruction-pattern"></a><span>&lsquo;<samp class="samp">speculation_barrier</samp>&rsquo;<a class="copiable-link" href="#index-speculation_005fbarrier-instruction-pattern"> &para;</a></span></dt>
<dd><p>If the target can support speculative execution, then this pattern should
be defined to an instruction that will block subsequent execution until
any prior speculation conditions has been resolved.  The pattern must also
ensure that the compiler cannot move memory operations past the barrier,
so it needs to be an UNSPEC_VOLATILE pattern.  The pattern has no
operands.
</p>
<p>If this pattern is not defined then the default expansion of
<code class="code">__builtin_speculation_safe_value</code> will emit a warning.  You can
suppress this warning by defining this pattern with a final condition
of <code class="code">0</code> (zero), which tells the compiler that a speculation
barrier is not needed for this target.
</p>
</dd>
<dt><a id="index-sync_005fcompare_005fand_005fswapmode-instruction-pattern"></a><span>&lsquo;<samp class="samp">sync_compare_and_swap<var class="var">mode</var></samp>&rsquo;<a class="copiable-link" href="#index-sync_005fcompare_005fand_005fswapmode-instruction-pattern"> &para;</a></span></dt>
<dd><p>This pattern, if defined, emits code for an atomic compare-and-swap
operation.  Operand 1 is the memory on which the atomic operation is
performed.  Operand 2 is the &ldquo;old&rdquo; value to be compared against the
current contents of the memory location.  Operand 3 is the &ldquo;new&rdquo; value
to store in the memory if the compare succeeds.  Operand 0 is the result
of the operation; it should contain the contents of the memory
before the operation.  If the compare succeeds, this should obviously be
a copy of operand 2.
</p>
<p>This pattern must show that both operand 0 and operand 1 are modified.
</p>
<p>This pattern must issue any memory barrier instructions such that all
memory operations before the atomic operation occur before the atomic
operation and all memory operations after the atomic operation occur
after the atomic operation.
</p>
<p>For targets where the success or failure of the compare-and-swap
operation is available via the status flags, it is possible to
avoid a separate compare operation and issue the subsequent
branch or store-flag operation immediately after the compare-and-swap.
To this end, GCC will look for a <code class="code">MODE_CC</code> set in the
output of <code class="code">sync_compare_and_swap<var class="var">mode</var></code>; if the machine
description includes such a set, the target should also define special
<code class="code">cbranchcc4</code> and/or <code class="code">cstorecc4</code> instructions.  GCC will then
be able to take the destination of the <code class="code">MODE_CC</code> set and pass it
to the <code class="code">cbranchcc4</code> or <code class="code">cstorecc4</code> pattern as the first
operand of the comparison (the second will be <code class="code">(const_int 0)</code>).
</p>
<p>For targets where the operating system may provide support for this
operation via library calls, the <code class="code">sync_compare_and_swap_optab</code>
may be initialized to a function with the same interface as the
<code class="code">__sync_val_compare_and_swap_<var class="var">n</var></code> built-in.  If the entire
set of <var class="var">__sync</var> builtins are supported via library calls, the
target can initialize all of the optabs at once with
<code class="code">init_sync_libfuncs</code>.
For the purposes of C++11 <code class="code">std::atomic::is_lock_free</code>, it is
assumed that these library calls do <em class="emph">not</em> use any kind of
interruptable locking.
</p>
</dd>
<dt><a class="index-entry-id" id="index-sync_005fsubmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-sync_005fiormode-instruction-pattern"></a>
<a class="index-entry-id" id="index-sync_005fandmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-sync_005fxormode-instruction-pattern"></a>
<a class="index-entry-id" id="index-sync_005fnandmode-instruction-pattern"></a>
<a id="index-sync_005faddmode-instruction-pattern"></a><span>&lsquo;<samp class="samp">sync_add<var class="var">mode</var></samp>&rsquo;, &lsquo;<samp class="samp">sync_sub<var class="var">mode</var></samp>&rsquo;<a class="copiable-link" href="#index-sync_005faddmode-instruction-pattern"> &para;</a></span></dt>
<dt>&lsquo;<samp class="samp">sync_ior<var class="var">mode</var></samp>&rsquo;, &lsquo;<samp class="samp">sync_and<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">sync_xor<var class="var">mode</var></samp>&rsquo;, &lsquo;<samp class="samp">sync_nand<var class="var">mode</var></samp>&rsquo;</dt>
<dd><p>These patterns emit code for an atomic operation on memory.
Operand 0 is the memory on which the atomic operation is performed.
Operand 1 is the second operand to the binary operator.
</p>
<p>This pattern must issue any memory barrier instructions such that all
memory operations before the atomic operation occur before the atomic
operation and all memory operations after the atomic operation occur
after the atomic operation.
</p>
<p>If these patterns are not defined, the operation will be constructed
from a compare-and-swap operation, if defined.
</p>
</dd>
<dt><a class="index-entry-id" id="index-sync_005fold_005fsubmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-sync_005fold_005fiormode-instruction-pattern"></a>
<a class="index-entry-id" id="index-sync_005fold_005fandmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-sync_005fold_005fxormode-instruction-pattern"></a>
<a class="index-entry-id" id="index-sync_005fold_005fnandmode-instruction-pattern"></a>
<a id="index-sync_005fold_005faddmode-instruction-pattern"></a><span>&lsquo;<samp class="samp">sync_old_add<var class="var">mode</var></samp>&rsquo;, &lsquo;<samp class="samp">sync_old_sub<var class="var">mode</var></samp>&rsquo;<a class="copiable-link" href="#index-sync_005fold_005faddmode-instruction-pattern"> &para;</a></span></dt>
<dt>&lsquo;<samp class="samp">sync_old_ior<var class="var">mode</var></samp>&rsquo;, &lsquo;<samp class="samp">sync_old_and<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">sync_old_xor<var class="var">mode</var></samp>&rsquo;, &lsquo;<samp class="samp">sync_old_nand<var class="var">mode</var></samp>&rsquo;</dt>
<dd><p>These patterns emit code for an atomic operation on memory,
and return the value that the memory contained before the operation.
Operand 0 is the result value, operand 1 is the memory on which the
atomic operation is performed, and operand 2 is the second operand
to the binary operator.
</p>
<p>This pattern must issue any memory barrier instructions such that all
memory operations before the atomic operation occur before the atomic
operation and all memory operations after the atomic operation occur
after the atomic operation.
</p>
<p>If these patterns are not defined, the operation will be constructed
from a compare-and-swap operation, if defined.
</p>
</dd>
<dt><a class="index-entry-id" id="index-sync_005fnew_005fsubmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-sync_005fnew_005fiormode-instruction-pattern"></a>
<a class="index-entry-id" id="index-sync_005fnew_005fandmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-sync_005fnew_005fxormode-instruction-pattern"></a>
<a class="index-entry-id" id="index-sync_005fnew_005fnandmode-instruction-pattern"></a>
<a id="index-sync_005fnew_005faddmode-instruction-pattern"></a><span>&lsquo;<samp class="samp">sync_new_add<var class="var">mode</var></samp>&rsquo;, &lsquo;<samp class="samp">sync_new_sub<var class="var">mode</var></samp>&rsquo;<a class="copiable-link" href="#index-sync_005fnew_005faddmode-instruction-pattern"> &para;</a></span></dt>
<dt>&lsquo;<samp class="samp">sync_new_ior<var class="var">mode</var></samp>&rsquo;, &lsquo;<samp class="samp">sync_new_and<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">sync_new_xor<var class="var">mode</var></samp>&rsquo;, &lsquo;<samp class="samp">sync_new_nand<var class="var">mode</var></samp>&rsquo;</dt>
<dd><p>These patterns are like their <code class="code">sync_old_<var class="var">op</var></code> counterparts,
except that they return the value that exists in the memory location
after the operation, rather than before the operation.
</p>
</dd>
<dt><a id="index-sync_005flock_005ftest_005fand_005fsetmode-instruction-pattern"></a><span>&lsquo;<samp class="samp">sync_lock_test_and_set<var class="var">mode</var></samp>&rsquo;<a class="copiable-link" href="#index-sync_005flock_005ftest_005fand_005fsetmode-instruction-pattern"> &para;</a></span></dt>
<dd><p>This pattern takes two forms, based on the capabilities of the target.
In either case, operand 0 is the result of the operand, operand 1 is
the memory on which the atomic operation is performed, and operand 2
is the value to set in the lock.
</p>
<p>In the ideal case, this operation is an atomic exchange operation, in
which the previous value in memory operand is copied into the result
operand, and the value operand is stored in the memory operand.
</p>
<p>For less capable targets, any value operand that is not the constant 1
should be rejected with <code class="code">FAIL</code>.  In this case the target may use
an atomic test-and-set bit operation.  The result operand should contain
1 if the bit was previously set and 0 if the bit was previously clear.
The true contents of the memory operand are implementation defined.
</p>
<p>This pattern must issue any memory barrier instructions such that the
pattern as a whole acts as an acquire barrier, that is all memory
operations after the pattern do not occur until the lock is acquired.
</p>
<p>If this pattern is not defined, the operation will be constructed from
a compare-and-swap operation, if defined.
</p>
</dd>
<dt><a id="index-sync_005flock_005freleasemode-instruction-pattern"></a><span>&lsquo;<samp class="samp">sync_lock_release<var class="var">mode</var></samp>&rsquo;<a class="copiable-link" href="#index-sync_005flock_005freleasemode-instruction-pattern"> &para;</a></span></dt>
<dd><p>This pattern, if defined, releases a lock set by
<code class="code">sync_lock_test_and_set<var class="var">mode</var></code>.  Operand 0 is the memory
that contains the lock; operand 1 is the value to store in the lock.
</p>
<p>If the target doesn&rsquo;t implement full semantics for
<code class="code">sync_lock_test_and_set<var class="var">mode</var></code>, any value operand which is not
the constant 0 should be rejected with <code class="code">FAIL</code>, and the true contents
of the memory operand are implementation defined.
</p>
<p>This pattern must issue any memory barrier instructions such that the
pattern as a whole acts as a release barrier, that is the lock is
released only after all previous memory operations have completed.
</p>
<p>If this pattern is not defined, then a <code class="code">memory_barrier</code> pattern
will be emitted, followed by a store of the value to the memory operand.
</p>
</dd>
<dt><a id="index-atomic_005fcompare_005fand_005fswapmode-instruction-pattern"></a><span>&lsquo;<samp class="samp">atomic_compare_and_swap<var class="var">mode</var></samp>&rsquo;<a class="copiable-link" href="#index-atomic_005fcompare_005fand_005fswapmode-instruction-pattern"> &para;</a></span></dt>
<dd><p>This pattern, if defined, emits code for an atomic compare-and-swap
operation with memory model semantics.  Operand 2 is the memory on which
the atomic operation is performed.  Operand 0 is an output operand which
is set to true or false based on whether the operation succeeded.  Operand
1 is an output operand which is set to the contents of the memory before
the operation was attempted.  Operand 3 is the value that is expected to
be in memory.  Operand 4 is the value to put in memory if the expected
value is found there.  Operand 5 is set to 1 if this compare and swap is to
be treated as a weak operation.  Operand 6 is the memory model to be used
if the operation is a success.  Operand 7 is the memory model to be used
if the operation fails.
</p>
<p>If memory referred to in operand 2 contains the value in operand 3, then
operand 4 is stored in memory pointed to by operand 2 and fencing based on
the memory model in operand 6 is issued.  
</p>
<p>If memory referred to in operand 2 does not contain the value in operand 3,
then fencing based on the memory model in operand 7 is issued.
</p>
<p>If a target does not support weak compare-and-swap operations, or the port
elects not to implement weak operations, the argument in operand 5 can be
ignored.  Note a strong implementation must be provided.
</p>
<p>If this pattern is not provided, the <code class="code">__atomic_compare_exchange</code>
built-in functions will utilize the legacy <code class="code">sync_compare_and_swap</code>
pattern with an <code class="code">__ATOMIC_SEQ_CST</code> memory model.
</p>
</dd>
<dt><a id="index-atomic_005floadmode-instruction-pattern"></a><span>&lsquo;<samp class="samp">atomic_load<var class="var">mode</var></samp>&rsquo;<a class="copiable-link" href="#index-atomic_005floadmode-instruction-pattern"> &para;</a></span></dt>
<dd><p>This pattern implements an atomic load operation with memory model
semantics.  Operand 1 is the memory address being loaded from.  Operand 0
is the result of the load.  Operand 2 is the memory model to be used for
the load operation.
</p>
<p>If not present, the <code class="code">__atomic_load</code> built-in function will either
resort to a normal load with memory barriers, or a compare-and-swap
operation if a normal load would not be atomic.
</p>
</dd>
<dt><a id="index-atomic_005fstoremode-instruction-pattern"></a><span>&lsquo;<samp class="samp">atomic_store<var class="var">mode</var></samp>&rsquo;<a class="copiable-link" href="#index-atomic_005fstoremode-instruction-pattern"> &para;</a></span></dt>
<dd><p>This pattern implements an atomic store operation with memory model
semantics.  Operand 0 is the memory address being stored to.  Operand 1
is the value to be written.  Operand 2 is the memory model to be used for
the operation.
</p>
<p>If not present, the <code class="code">__atomic_store</code> built-in function will attempt to
perform a normal store and surround it with any required memory fences.  If
the store would not be atomic, then an <code class="code">__atomic_exchange</code> is
attempted with the result being ignored.
</p>
</dd>
<dt><a id="index-atomic_005fexchangemode-instruction-pattern"></a><span>&lsquo;<samp class="samp">atomic_exchange<var class="var">mode</var></samp>&rsquo;<a class="copiable-link" href="#index-atomic_005fexchangemode-instruction-pattern"> &para;</a></span></dt>
<dd><p>This pattern implements an atomic exchange operation with memory model
semantics.  Operand 1 is the memory location the operation is performed on.
Operand 0 is an output operand which is set to the original value contained
in the memory pointed to by operand 1.  Operand 2 is the value to be
stored.  Operand 3 is the memory model to be used.
</p>
<p>If this pattern is not present, the built-in function
<code class="code">__atomic_exchange</code> will attempt to preform the operation with a
compare and swap loop.
</p>
</dd>
<dt><a class="index-entry-id" id="index-atomic_005fsubmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-atomic_005formode-instruction-pattern"></a>
<a class="index-entry-id" id="index-atomic_005fandmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-atomic_005fxormode-instruction-pattern"></a>
<a class="index-entry-id" id="index-atomic_005fnandmode-instruction-pattern"></a>
<a id="index-atomic_005faddmode-instruction-pattern"></a><span>&lsquo;<samp class="samp">atomic_add<var class="var">mode</var></samp>&rsquo;, &lsquo;<samp class="samp">atomic_sub<var class="var">mode</var></samp>&rsquo;<a class="copiable-link" href="#index-atomic_005faddmode-instruction-pattern"> &para;</a></span></dt>
<dt>&lsquo;<samp class="samp">atomic_or<var class="var">mode</var></samp>&rsquo;, &lsquo;<samp class="samp">atomic_and<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">atomic_xor<var class="var">mode</var></samp>&rsquo;, &lsquo;<samp class="samp">atomic_nand<var class="var">mode</var></samp>&rsquo;</dt>
<dd><p>These patterns emit code for an atomic operation on memory with memory
model semantics. Operand 0 is the memory on which the atomic operation is
performed.  Operand 1 is the second operand to the binary operator.
Operand 2 is the memory model to be used by the operation.
</p>
<p>If these patterns are not defined, attempts will be made to use legacy
<code class="code">sync</code> patterns, or equivalent patterns which return a result.  If
none of these are available a compare-and-swap loop will be used.
</p>
</dd>
<dt><a class="index-entry-id" id="index-atomic_005ffetch_005fsubmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-atomic_005ffetch_005formode-instruction-pattern"></a>
<a class="index-entry-id" id="index-atomic_005ffetch_005fandmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-atomic_005ffetch_005fxormode-instruction-pattern"></a>
<a class="index-entry-id" id="index-atomic_005ffetch_005fnandmode-instruction-pattern"></a>
<a id="index-atomic_005ffetch_005faddmode-instruction-pattern"></a><span>&lsquo;<samp class="samp">atomic_fetch_add<var class="var">mode</var></samp>&rsquo;, &lsquo;<samp class="samp">atomic_fetch_sub<var class="var">mode</var></samp>&rsquo;<a class="copiable-link" href="#index-atomic_005ffetch_005faddmode-instruction-pattern"> &para;</a></span></dt>
<dt>&lsquo;<samp class="samp">atomic_fetch_or<var class="var">mode</var></samp>&rsquo;, &lsquo;<samp class="samp">atomic_fetch_and<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">atomic_fetch_xor<var class="var">mode</var></samp>&rsquo;, &lsquo;<samp class="samp">atomic_fetch_nand<var class="var">mode</var></samp>&rsquo;</dt>
<dd><p>These patterns emit code for an atomic operation on memory with memory
model semantics, and return the original value. Operand 0 is an output 
operand which contains the value of the memory location before the 
operation was performed.  Operand 1 is the memory on which the atomic 
operation is performed.  Operand 2 is the second operand to the binary
operator.  Operand 3 is the memory model to be used by the operation.
</p>
<p>If these patterns are not defined, attempts will be made to use legacy
<code class="code">sync</code> patterns.  If none of these are available a compare-and-swap
loop will be used.
</p>
</dd>
<dt><a class="index-entry-id" id="index-atomic_005fsub_005ffetchmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-atomic_005for_005ffetchmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-atomic_005fand_005ffetchmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-atomic_005fxor_005ffetchmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-atomic_005fnand_005ffetchmode-instruction-pattern"></a>
<a id="index-atomic_005fadd_005ffetchmode-instruction-pattern"></a><span>&lsquo;<samp class="samp">atomic_add_fetch<var class="var">mode</var></samp>&rsquo;, &lsquo;<samp class="samp">atomic_sub_fetch<var class="var">mode</var></samp>&rsquo;<a class="copiable-link" href="#index-atomic_005fadd_005ffetchmode-instruction-pattern"> &para;</a></span></dt>
<dt>&lsquo;<samp class="samp">atomic_or_fetch<var class="var">mode</var></samp>&rsquo;, &lsquo;<samp class="samp">atomic_and_fetch<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">atomic_xor_fetch<var class="var">mode</var></samp>&rsquo;, &lsquo;<samp class="samp">atomic_nand_fetch<var class="var">mode</var></samp>&rsquo;</dt>
<dd><p>These patterns emit code for an atomic operation on memory with memory
model semantics and return the result after the operation is performed.
Operand 0 is an output operand which contains the value after the
operation.  Operand 1 is the memory on which the atomic operation is
performed.  Operand 2 is the second operand to the binary operator.
Operand 3 is the memory model to be used by the operation.
</p>
<p>If these patterns are not defined, attempts will be made to use legacy
<code class="code">sync</code> patterns, or equivalent patterns which return the result before
the operation followed by the arithmetic operation required to produce the
result.  If none of these are available a compare-and-swap loop will be
used.
</p>
</dd>
<dt><a id="index-atomic_005ftest_005fand_005fset-instruction-pattern"></a><span>&lsquo;<samp class="samp">atomic_test_and_set</samp>&rsquo;<a class="copiable-link" href="#index-atomic_005ftest_005fand_005fset-instruction-pattern"> &para;</a></span></dt>
<dd><p>This pattern emits code for <code class="code">__builtin_atomic_test_and_set</code>.
Operand 0 is an output operand which is set to true if the previous
previous contents of the byte was &quot;set&quot;, and false otherwise.  Operand 1
is the <code class="code">QImode</code> memory to be modified.  Operand 2 is the memory
model to be used.
</p>
<p>The specific value that defines &quot;set&quot; is implementation defined, and
is normally based on what is performed by the native atomic test and set
instruction.
</p>
</dd>
<dt><a class="index-entry-id" id="index-atomic_005fbit_005ftest_005fand_005fcomplementmode-instruction-pattern"></a>
<a class="index-entry-id" id="index-atomic_005fbit_005ftest_005fand_005fresetmode-instruction-pattern"></a>
<a id="index-atomic_005fbit_005ftest_005fand_005fsetmode-instruction-pattern"></a><span>&lsquo;<samp class="samp">atomic_bit_test_and_set<var class="var">mode</var></samp>&rsquo;<a class="copiable-link" href="#index-atomic_005fbit_005ftest_005fand_005fsetmode-instruction-pattern"> &para;</a></span></dt>
<dt>&lsquo;<samp class="samp">atomic_bit_test_and_complement<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">atomic_bit_test_and_reset<var class="var">mode</var></samp>&rsquo;</dt>
<dd><p>These patterns emit code for an atomic bitwise operation on memory with memory
model semantics, and return the original value of the specified bit.
Operand 0 is an output operand which contains the value of the specified bit
from the memory location before the operation was performed.  Operand 1 is the
memory on which the atomic operation is performed.  Operand 2 is the bit within
the operand, starting with least significant bit.  Operand 3 is the memory model
to be used by the operation.  Operand 4 is a flag - it is <code class="code">const1_rtx</code>
if operand 0 should contain the original value of the specified bit in the
least significant bit of the operand, and <code class="code">const0_rtx</code> if the bit should
be in its original position in the operand.
<code class="code">atomic_bit_test_and_set<var class="var">mode</var></code> atomically sets the specified bit after
remembering its original value, <code class="code">atomic_bit_test_and_complement<var class="var">mode</var></code>
inverts the specified bit and <code class="code">atomic_bit_test_and_reset<var class="var">mode</var></code> clears
the specified bit.
</p>
<p>If these patterns are not defined, attempts will be made to use
<code class="code">atomic_fetch_or<var class="var">mode</var></code>, <code class="code">atomic_fetch_xor<var class="var">mode</var></code> or
<code class="code">atomic_fetch_and<var class="var">mode</var></code> instruction patterns, or their <code class="code">sync</code>
counterparts.  If none of these are available a compare-and-swap
loop will be used.
</p>
</dd>
<dt><a class="index-entry-id" id="index-atomic_005fsub_005ffetch_005fcmp_005f0mode-instruction-pattern"></a>
<a class="index-entry-id" id="index-atomic_005fand_005ffetch_005fcmp_005f0mode-instruction-pattern"></a>
<a class="index-entry-id" id="index-atomic_005for_005ffetch_005fcmp_005f0mode-instruction-pattern"></a>
<a class="index-entry-id" id="index-atomic_005fxor_005ffetch_005fcmp_005f0mode-instruction-pattern"></a>
<a id="index-atomic_005fadd_005ffetch_005fcmp_005f0mode-instruction-pattern"></a><span>&lsquo;<samp class="samp">atomic_add_fetch_cmp_0<var class="var">mode</var></samp>&rsquo;<a class="copiable-link" href="#index-atomic_005fadd_005ffetch_005fcmp_005f0mode-instruction-pattern"> &para;</a></span></dt>
<dt>&lsquo;<samp class="samp">atomic_sub_fetch_cmp_0<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">atomic_and_fetch_cmp_0<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">atomic_or_fetch_cmp_0<var class="var">mode</var></samp>&rsquo;</dt>
<dt>&lsquo;<samp class="samp">atomic_xor_fetch_cmp_0<var class="var">mode</var></samp>&rsquo;</dt>
<dd><p>These patterns emit code for an atomic operation on memory with memory
model semantics if the fetch result is used only in a comparison against
zero.
Operand 0 is an output operand which contains a boolean result of comparison
of the value after the operation against zero.  Operand 1 is the memory on
which the atomic operation is performed.  Operand 2 is the second operand
to the binary operator.  Operand 3 is the memory model to be used by the
operation.  Operand 4 is an integer holding the comparison code, one of
<code class="code">EQ</code>, <code class="code">NE</code>, <code class="code">LT</code>, <code class="code">GT</code>, <code class="code">LE</code> or <code class="code">GE</code>.
</p>
<p>If these patterns are not defined, attempts will be made to use separate
atomic operation and fetch pattern followed by comparison of the result
against zero.
</p>
</dd>
<dt><a id="index-mem_005fthread_005ffence-instruction-pattern"></a><span>&lsquo;<samp class="samp">mem_thread_fence</samp>&rsquo;<a class="copiable-link" href="#index-mem_005fthread_005ffence-instruction-pattern"> &para;</a></span></dt>
<dd><p>This pattern emits code required to implement a thread fence with
memory model semantics.  Operand 0 is the memory model to be used.
</p>
<p>For the <code class="code">__ATOMIC_RELAXED</code> model no instructions need to be issued
and this expansion is not invoked.
</p>
<p>The compiler always emits a compiler memory barrier regardless of what
expanding this pattern produced.
</p>
<p>If this pattern is not defined, the compiler falls back to expanding the
<code class="code">memory_barrier</code> pattern, then to emitting <code class="code">__sync_synchronize</code>
library call, and finally to just placing a compiler memory barrier.
</p>
</dd>
<dt><a class="index-entry-id" id="index-set_005fthread_005fpointermode-instruction-pattern"></a>
<a id="index-get_005fthread_005fpointermode-instruction-pattern"></a><span>&lsquo;<samp class="samp">get_thread_pointer<var class="var">mode</var></samp>&rsquo;<a class="copiable-link" href="#index-get_005fthread_005fpointermode-instruction-pattern"> &para;</a></span></dt>
<dt>&lsquo;<samp class="samp">set_thread_pointer<var class="var">mode</var></samp>&rsquo;</dt>
<dd><p>These patterns emit code that reads/sets the TLS thread pointer. Currently,
these are only needed if the target needs to support the
<code class="code">__builtin_thread_pointer</code> and <code class="code">__builtin_set_thread_pointer</code>
builtins.
</p>
<p>The get/set patterns have a single output/input operand respectively,
with <var class="var">mode</var> intended to be <code class="code">Pmode</code>.
</p>
</dd>
<dt><a id="index-stack_005fprotect_005fcombined_005fset-instruction-pattern"></a><span>&lsquo;<samp class="samp">stack_protect_combined_set</samp>&rsquo;<a class="copiable-link" href="#index-stack_005fprotect_005fcombined_005fset-instruction-pattern"> &para;</a></span></dt>
<dd><p>This pattern, if defined, moves a <code class="code">ptr_mode</code> value from an address
whose declaration RTX is given in operand 1 to the memory in operand 0
without leaving the value in a register afterward.  If several
instructions are needed by the target to perform the operation (eg. to
load the address from a GOT entry then load the <code class="code">ptr_mode</code> value
and finally store it), it is the backend&rsquo;s responsibility to ensure no
intermediate result gets spilled.  This is to avoid leaking the value
some place that an attacker might use to rewrite the stack guard slot
after having clobbered it.
</p>
<p>If this pattern is not defined, then the address declaration is
expanded first in the standard way and a <code class="code">stack_protect_set</code>
pattern is then generated to move the value from that address to the
address in operand 0.
</p>
</dd>
<dt><a id="index-stack_005fprotect_005fset-instruction-pattern"></a><span>&lsquo;<samp class="samp">stack_protect_set</samp>&rsquo;<a class="copiable-link" href="#index-stack_005fprotect_005fset-instruction-pattern"> &para;</a></span></dt>
<dd><p>This pattern, if defined, moves a <code class="code">ptr_mode</code> value from the valid
memory location in operand 1 to the memory in operand 0 without leaving
the value in a register afterward.  This is to avoid leaking the value
some place that an attacker might use to rewrite the stack guard slot
after having clobbered it.
</p>
<p>Note: on targets where the addressing modes do not allow to load
directly from stack guard address, the address is expanded in a standard
way first which could cause some spills.
</p>
<p>If this pattern is not defined, then a plain move pattern is generated.
</p>
</dd>
<dt><a id="index-stack_005fprotect_005fcombined_005ftest-instruction-pattern"></a><span>&lsquo;<samp class="samp">stack_protect_combined_test</samp>&rsquo;<a class="copiable-link" href="#index-stack_005fprotect_005fcombined_005ftest-instruction-pattern"> &para;</a></span></dt>
<dd><p>This pattern, if defined, compares a <code class="code">ptr_mode</code> value from an
address whose declaration RTX is given in operand 1 with the memory in
operand 0 without leaving the value in a register afterward and
branches to operand 2 if the values were equal.  If several
instructions are needed by the target to perform the operation (eg. to
load the address from a GOT entry then load the <code class="code">ptr_mode</code> value
and finally store it), it is the backend&rsquo;s responsibility to ensure no
intermediate result gets spilled.  This is to avoid leaking the value
some place that an attacker might use to rewrite the stack guard slot
after having clobbered it.
</p>
<p>If this pattern is not defined, then the address declaration is
expanded first in the standard way and a <code class="code">stack_protect_test</code>
pattern is then generated to compare the value from that address to the
value at the memory in operand 0.
</p>
</dd>
<dt><a id="index-stack_005fprotect_005ftest-instruction-pattern"></a><span>&lsquo;<samp class="samp">stack_protect_test</samp>&rsquo;<a class="copiable-link" href="#index-stack_005fprotect_005ftest-instruction-pattern"> &para;</a></span></dt>
<dd><p>This pattern, if defined, compares a <code class="code">ptr_mode</code> value from the
valid memory location in operand 1 with the memory in operand 0 without
leaving the value in a register afterward and branches to operand 2 if
the values were equal.
</p>
<p>If this pattern is not defined, then a plain compare pattern and
conditional branch pattern is used.
</p>
</dd>
<dt><a id="index-clear_005fcache-instruction-pattern"></a><span>&lsquo;<samp class="samp">clear_cache</samp>&rsquo;<a class="copiable-link" href="#index-clear_005fcache-instruction-pattern"> &para;</a></span></dt>
<dd><p>This pattern, if defined, flushes the instruction cache for a region of
memory.  The region is bounded to by the Pmode pointers in operand 0
inclusive and operand 1 exclusive.
</p>
<p>If this pattern is not defined, a call to the library function
<code class="code">__clear_cache</code> is used.
</p>
</dd>
<dt><a id="index-spaceshipm4-instruction-pattern"></a><span>&lsquo;<samp class="samp">spaceship<var class="var">m</var>4</samp>&rsquo;<a class="copiable-link" href="#index-spaceshipm4-instruction-pattern"> &para;</a></span></dt>
<dd><p>Initialize output operand 0 with mode of integer type to -1, 0, 1 or 2
if operand 1 with mode <var class="var">m</var> compares less than operand 2, equal to
operand 2, greater than operand 2 or is unordered with operand 2.
Operand 3 should be <code class="code">const0_rtx</code> if the result is used in comparisons,
<code class="code">const1_rtx</code> if the result is used as integer value and the comparison
is integral unsigned, <code class="code">constm1_rtx</code> if the result is used as integer
value and the comparison is integral signed and some other <code class="code">CONST_INT</code>
if the result is used as integer value and the comparison is floating point.
In the last case, instead of setting output operand 0 to 2 for unordered,
set it to operand 3.
<var class="var">m</var> should be a scalar floating point mode.
</p>
<p>This pattern is not allowed to <code class="code">FAIL</code>.
</p>
</dd>
<dt><a id="index-isfinitem2-instruction-pattern"></a><span>&lsquo;<samp class="samp">isfinite<var class="var">m</var>2</samp>&rsquo;<a class="copiable-link" href="#index-isfinitem2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Return 1 if operand 1 is a finite floating point number and 0
otherwise.  <var class="var">m</var> is a scalar floating point mode.  Operand 0
has mode <code class="code">SImode</code>, and operand 1 has mode <var class="var">m</var>.
</p>
</dd>
<dt><a id="index-isnormalm2-instruction-pattern"></a><span>&lsquo;<samp class="samp">isnormal<var class="var">m</var>2</samp>&rsquo;<a class="copiable-link" href="#index-isnormalm2-instruction-pattern"> &para;</a></span></dt>
<dd><p>Return 1 if operand 1 is a normal floating point number and 0
otherwise.  <var class="var">m</var> is a scalar floating point mode.  Operand 0
has mode <code class="code">SImode</code>, and operand 1 has mode <var class="var">m</var>.
</p>
</dd>
<dt><a id="index-crcmn4-instruction-pattern"></a><span>&lsquo;<samp class="samp">crc<var class="var">m</var><var class="var">n</var>4</samp>&rsquo;<a class="copiable-link" href="#index-crcmn4-instruction-pattern"> &para;</a></span></dt>
<dd><p>Calculate a bit-forward CRC using operands 1, 2 and 3,
then store the result in operand 0.
Operands 1 is the initial CRC, operands 2 is the data and operands 3 is the
polynomial without leading 1.
Operands 0, 1 and 3 have mode <var class="var">n</var> and operand 2 has mode <var class="var">m</var>, where
both modes are integers.  The size of CRC to be calculated is determined by the
mode; for example, if <var class="var">n</var> is <code class="code">HImode</code>, a CRC16 is calculated.
</p>
</dd>
<dt><a id="index-crc_005frevmn4-instruction-pattern"></a><span>&lsquo;<samp class="samp">crc_rev<var class="var">m</var><var class="var">n</var>4</samp>&rsquo;<a class="copiable-link" href="#index-crc_005frevmn4-instruction-pattern"> &para;</a></span></dt>
<dd><p>Similar to &lsquo;<samp class="samp">crc<var class="var">m</var><var class="var">n</var>4</samp>&rsquo;, but calculates a bit-reversed CRC.
</p>
</dd>
</dl>

</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Pattern-Ordering.html">When the Order of Patterns Matters</a>, Previous: <a href="Constraints.html">Operand Constraints</a>, Up: <a href="Machine-Desc.html">Machine Descriptions</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Option-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>

<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- Copyright Â© 1988-2025 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Funding Free Software", the Front-Cover
Texts being (a) (see below), and with the Back-Cover Texts being (b)
(see below).  A copy of the license is included in the section entitled
"GNU Free Documentation License".

(a) The FSF's Front-Cover Text is:

A GNU Manual

(b) The FSF's Back-Cover Text is:

You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development. -->
<title>Frame Layout (GNU Compiler Collection (GCC) Internals)</title>

<meta name="description" content="Frame Layout (GNU Compiler Collection (GCC) Internals)">
<meta name="keywords" content="Frame Layout (GNU Compiler Collection (GCC) Internals)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Option-Index.html" rel="index" title="Option Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Stack-and-Calling.html" rel="up" title="Stack and Calling">
<link href="Exception-Handling.html" rel="next" title="Exception Handling">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>


</head>

<body lang="en">
<div class="subsection-level-extent" id="Frame-Layout">
<div class="nav-panel">
<p>
Next: <a href="Exception-Handling.html" accesskey="n" rel="next">Exception Handling Support</a>, Up: <a href="Stack-and-Calling.html" accesskey="u" rel="up">Stack Layout and Calling Conventions</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Option-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h4 class="subsection" id="Basic-Stack-Layout"><span>17.9.1 Basic Stack Layout<a class="copiable-link" href="#Basic-Stack-Layout"> &para;</a></span></h4>
<a class="index-entry-id" id="index-stack-frame-layout"></a>
<a class="index-entry-id" id="index-frame-layout"></a>

<p>Here is the basic stack layout.
</p>
<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-STACK_005fGROWS_005fDOWNWARD"><span class="category-def">Macro: </span><span><strong class="def-name">STACK_GROWS_DOWNWARD</strong><a class="copiable-link" href="#index-STACK_005fGROWS_005fDOWNWARD"> &para;</a></span></dt>
<dd><p>Define this macro to be true if pushing a word onto the stack moves the stack
pointer to a smaller address, and false otherwise.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-STACK_005fPUSH_005fCODE"><span class="category-def">Macro: </span><span><strong class="def-name">STACK_PUSH_CODE</strong><a class="copiable-link" href="#index-STACK_005fPUSH_005fCODE"> &para;</a></span></dt>
<dd><p>This macro defines the operation used when something is pushed
on the stack.  In RTL, a push operation will be
<code class="code">(set (mem (STACK_PUSH_CODE (reg sp))) &hellip;)</code>
</p>
<p>The choices are <code class="code">PRE_DEC</code>, <code class="code">POST_DEC</code>, <code class="code">PRE_INC</code>,
and <code class="code">POST_INC</code>.  Which of these is correct depends on
the stack direction and on whether the stack pointer points
to the last item on the stack or whether it points to the
space for the next item on the stack.
</p>
<p>The default is <code class="code">PRE_DEC</code> when <code class="code">STACK_GROWS_DOWNWARD</code> is
true, which is almost always right, and <code class="code">PRE_INC</code> otherwise,
which is often wrong.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-FRAME_005fGROWS_005fDOWNWARD"><span class="category-def">Macro: </span><span><strong class="def-name">FRAME_GROWS_DOWNWARD</strong><a class="copiable-link" href="#index-FRAME_005fGROWS_005fDOWNWARD"> &para;</a></span></dt>
<dd><p>Define this macro to nonzero value if the addresses of local variable slots
are at negative offsets from the frame pointer.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-ARGS_005fGROW_005fDOWNWARD"><span class="category-def">Macro: </span><span><strong class="def-name">ARGS_GROW_DOWNWARD</strong><a class="copiable-link" href="#index-ARGS_005fGROW_005fDOWNWARD"> &para;</a></span></dt>
<dd><p>Define this macro if successive arguments to a function occupy decreasing
addresses on the stack.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSTARTING_005fFRAME_005fOFFSET"><span class="category-def">Target Hook: </span><span><code class="def-type">HOST_WIDE_INT</code> <strong class="def-name">TARGET_STARTING_FRAME_OFFSET</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fSTARTING_005fFRAME_005fOFFSET"> &para;</a></span></dt>
<dd><p>This hook returns the offset from the frame pointer to the first local
variable slot to be allocated.  If <code class="code">FRAME_GROWS_DOWNWARD</code>, it is the
offset to <em class="emph">end</em> of the first slot allocated, otherwise it is the
offset to <em class="emph">beginning</em> of the first slot allocated.  The default
implementation returns 0.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-STACK_005fALIGNMENT_005fNEEDED"><span class="category-def">Macro: </span><span><strong class="def-name">STACK_ALIGNMENT_NEEDED</strong><a class="copiable-link" href="#index-STACK_005fALIGNMENT_005fNEEDED"> &para;</a></span></dt>
<dd><p>Define to zero to disable final alignment of the stack during reload.
The nonzero default for this macro is suitable for most ports.
</p>
<p>On ports where <code class="code">TARGET_STARTING_FRAME_OFFSET</code> is nonzero or where there
is a register save block following the local block that doesn&rsquo;t require
alignment to <code class="code">STACK_BOUNDARY</code>, it may be beneficial to disable
stack alignment and do it in the backend.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-STACK_005fPOINTER_005fOFFSET"><span class="category-def">Macro: </span><span><strong class="def-name">STACK_POINTER_OFFSET</strong><a class="copiable-link" href="#index-STACK_005fPOINTER_005fOFFSET"> &para;</a></span></dt>
<dd><p>Offset from the stack pointer register to the first location at which
outgoing arguments are placed.  If not specified, the default value of
zero is used.  This is the proper value for most machines.
</p>
<p>If <code class="code">ARGS_GROW_DOWNWARD</code>, this is the offset to the location above
the first location at which outgoing arguments are placed.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-FIRST_005fPARM_005fOFFSET"><span class="category-def">Macro: </span><span><strong class="def-name">FIRST_PARM_OFFSET</strong> <var class="def-var-arguments">(<var class="var">fundecl</var>)</var><a class="copiable-link" href="#index-FIRST_005fPARM_005fOFFSET"> &para;</a></span></dt>
<dd><p>Offset from the argument pointer register to the first argument&rsquo;s
address.  On some machines it may depend on the data type of the
function.
</p>
<p>If <code class="code">ARGS_GROW_DOWNWARD</code>, this is the offset to the location above
the first argument&rsquo;s address.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-STACK_005fDYNAMIC_005fOFFSET"><span class="category-def">Macro: </span><span><strong class="def-name">STACK_DYNAMIC_OFFSET</strong> <var class="def-var-arguments">(<var class="var">fundecl</var>)</var><a class="copiable-link" href="#index-STACK_005fDYNAMIC_005fOFFSET"> &para;</a></span></dt>
<dd><p>Offset from the stack pointer register to an item dynamically allocated
on the stack, e.g., by <code class="code">alloca</code>.
</p>
<p>The default value for this macro is <code class="code">STACK_POINTER_OFFSET</code> plus the
length of the outgoing arguments.  The default is correct for most
machines.  See <samp class="file">function.cc</samp> for details.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-INITIAL_005fFRAME_005fADDRESS_005fRTX"><span class="category-def">Macro: </span><span><strong class="def-name">INITIAL_FRAME_ADDRESS_RTX</strong><a class="copiable-link" href="#index-INITIAL_005fFRAME_005fADDRESS_005fRTX"> &para;</a></span></dt>
<dd><p>A C expression whose value is RTL representing the address of the initial
stack frame. This address is passed to <code class="code">RETURN_ADDR_RTX</code> and
<code class="code">DYNAMIC_CHAIN_ADDRESS</code>.  If you don&rsquo;t define this macro, a reasonable
default value will be used.  Define this macro in order to make frame pointer
elimination work in the presence of <code class="code">__builtin_frame_address (count)</code> and
<code class="code">__builtin_return_address (count)</code> for <code class="code">count</code> not equal to zero.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-DYNAMIC_005fCHAIN_005fADDRESS"><span class="category-def">Macro: </span><span><strong class="def-name">DYNAMIC_CHAIN_ADDRESS</strong> <var class="def-var-arguments">(<var class="var">frameaddr</var>)</var><a class="copiable-link" href="#index-DYNAMIC_005fCHAIN_005fADDRESS"> &para;</a></span></dt>
<dd><p>A C expression whose value is RTL representing the address in a stack
frame where the pointer to the caller&rsquo;s frame is stored.  Assume that
<var class="var">frameaddr</var> is an RTL expression for the address of the stack frame
itself.
</p>
<p>If you don&rsquo;t define this macro, the default is to return the value
of <var class="var">frameaddr</var>&mdash;that is, the stack frame address is also the
address of the stack word that points to the previous frame.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-SETUP_005fFRAME_005fADDRESSES"><span class="category-def">Macro: </span><span><strong class="def-name">SETUP_FRAME_ADDRESSES</strong><a class="copiable-link" href="#index-SETUP_005fFRAME_005fADDRESSES"> &para;</a></span></dt>
<dd><p>A C expression that produces the machine-specific code to
setup the stack so that arbitrary frames can be accessed.  For example,
on the SPARC, we must flush all of the register windows to the stack
before we can access arbitrary stack frames.  You will seldom need to
define this macro.  The default is to do nothing.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fBUILTIN_005fSETJMP_005fFRAME_005fVALUE"><span class="category-def">Target Hook: </span><span><code class="def-type">rtx</code> <strong class="def-name">TARGET_BUILTIN_SETJMP_FRAME_VALUE</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fBUILTIN_005fSETJMP_005fFRAME_005fVALUE"> &para;</a></span></dt>
<dd><p>This target hook should return an rtx that is used to store
the address of the current frame into the built in <code class="code">setjmp</code> buffer.
The default value, <code class="code">virtual_stack_vars_rtx</code>, is correct for most
machines.  One reason you may need to define this target hook is if
<code class="code">hard_frame_pointer_rtx</code> is the appropriate value on your machine.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-FRAME_005fADDR_005fRTX"><span class="category-def">Macro: </span><span><strong class="def-name">FRAME_ADDR_RTX</strong> <var class="def-var-arguments">(<var class="var">frameaddr</var>)</var><a class="copiable-link" href="#index-FRAME_005fADDR_005fRTX"> &para;</a></span></dt>
<dd><p>A C expression whose value is RTL representing the value of the frame
address for the current frame.  <var class="var">frameaddr</var> is the frame pointer
of the current frame.  This is used for __builtin_frame_address.
You need only define this macro if the frame address is not the same
as the frame pointer.  Most machines do not need to define it.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-RETURN_005fADDR_005fRTX"><span class="category-def">Macro: </span><span><strong class="def-name">RETURN_ADDR_RTX</strong> <var class="def-var-arguments">(<var class="var">count</var>, <var class="var">frameaddr</var>)</var><a class="copiable-link" href="#index-RETURN_005fADDR_005fRTX"> &para;</a></span></dt>
<dd><p>A C expression whose value is RTL representing the value of the return
address for the frame <var class="var">count</var> steps up from the current frame, after
the prologue.  <var class="var">frameaddr</var> is the frame pointer of the <var class="var">count</var>
frame, or the frame pointer of the <var class="var">count</var> &minus; 1 frame if
<code class="code">RETURN_ADDR_IN_PREVIOUS_FRAME</code> is nonzero.
</p>
<p>The value of the expression must always be the correct address when
<var class="var">count</var> is zero, but may be <code class="code">NULL_RTX</code> if there is no way to
determine the return address of other frames.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-RETURN_005fADDR_005fIN_005fPREVIOUS_005fFRAME"><span class="category-def">Macro: </span><span><strong class="def-name">RETURN_ADDR_IN_PREVIOUS_FRAME</strong><a class="copiable-link" href="#index-RETURN_005fADDR_005fIN_005fPREVIOUS_005fFRAME"> &para;</a></span></dt>
<dd><p>Define this macro to nonzero value if the return address of a particular
stack frame is accessed from the frame pointer of the previous stack
frame.  The zero default for this macro is suitable for most ports.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-INCOMING_005fRETURN_005fADDR_005fRTX"><span class="category-def">Macro: </span><span><strong class="def-name">INCOMING_RETURN_ADDR_RTX</strong><a class="copiable-link" href="#index-INCOMING_005fRETURN_005fADDR_005fRTX"> &para;</a></span></dt>
<dd><p>A C expression whose value is RTL representing the location of the
incoming return address at the beginning of any function, before the
prologue.  This RTL is either a <code class="code">REG</code>, indicating that the return
value is saved in &lsquo;<samp class="samp">REG</samp>&rsquo;, or a <code class="code">MEM</code> representing a location in
the stack.
</p>
<p>You only need to define this macro if you want to support call frame
debugging information like that provided by DWARF 2.
</p>
<p>If this RTL is a <code class="code">REG</code>, you should also define
<code class="code">DWARF_FRAME_RETURN_COLUMN</code> to <code class="code">DWARF_FRAME_REGNUM (REGNO)</code>.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-DWARF_005fALT_005fFRAME_005fRETURN_005fCOLUMN"><span class="category-def">Macro: </span><span><strong class="def-name">DWARF_ALT_FRAME_RETURN_COLUMN</strong><a class="copiable-link" href="#index-DWARF_005fALT_005fFRAME_005fRETURN_005fCOLUMN"> &para;</a></span></dt>
<dd><p>A C expression whose value is an integer giving a DWARF 2 column
number that may be used as an alternative return column.  The column
must not correspond to any gcc hard register (that is, it must not
be in the range of <code class="code">DWARF_FRAME_REGNUM</code>).
</p>
<p>This macro can be useful if <code class="code">DWARF_FRAME_RETURN_COLUMN</code> is set to a
general register, but an alternative column needs to be used for signal
frames.  Some targets have also used different frame return columns
over time.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-DWARF_005fZERO_005fREG"><span class="category-def">Macro: </span><span><strong class="def-name">DWARF_ZERO_REG</strong><a class="copiable-link" href="#index-DWARF_005fZERO_005fREG"> &para;</a></span></dt>
<dd><p>A C expression whose value is an integer giving a DWARF 2 register
number that is considered to always have the value zero.  This should
only be defined if the target has an architected zero register, and
someone decided it was a good idea to use that register number to
terminate the stack backtrace.  New ports should avoid this.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-DWARF_005fVERSION_005fDEFAULT"><span class="category-def">Macro: </span><span><strong class="def-name">DWARF_VERSION_DEFAULT</strong><a class="copiable-link" href="#index-DWARF_005fVERSION_005fDEFAULT"> &para;</a></span></dt>
<dd><p>A C expression whose value is the default dwarf standard version we&rsquo;ll honor
and advertise when generating dwarf debug information, in absence of
an explicit <samp class="option">-gdwarf-<var class="var">version</var></samp> option on the command line.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fDWARF_005fHANDLE_005fFRAME_005fUNSPEC"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_DWARF_HANDLE_FRAME_UNSPEC</strong> <code class="def-code-arguments">(const char *<var class="var">label</var>, rtx <var class="var">pattern</var>, int <var class="var">index</var>)</code><a class="copiable-link" href="#index-TARGET_005fDWARF_005fHANDLE_005fFRAME_005fUNSPEC"> &para;</a></span></dt>
<dd><p>This target hook allows the backend to emit frame-related insns that
contain UNSPECs or UNSPEC_VOLATILEs.  The DWARF 2 call frame debugging
info engine will invoke it on insns of the form
</p><div class="example smallexample">
<pre class="example-preformatted">(set (reg) (unspec [...] UNSPEC_INDEX))
</pre></div>
<p>and
</p><div class="example smallexample">
<pre class="example-preformatted">(set (reg) (unspec_volatile [...] UNSPECV_INDEX)).
</pre></div>
<p>to let the backend emit the call frame instructions.  <var class="var">label</var> is
the CFI label attached to the insn, <var class="var">pattern</var> is the pattern of
the insn and <var class="var">index</var> is <code class="code">UNSPEC_INDEX</code> or <code class="code">UNSPECV_INDEX</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fDWARF_005fPOLY_005fINDETERMINATE_005fVALUE"><span class="category-def">Target Hook: </span><span><code class="def-type">unsigned int</code> <strong class="def-name">TARGET_DWARF_POLY_INDETERMINATE_VALUE</strong> <code class="def-code-arguments">(unsigned int <var class="var">i</var>, unsigned int *<var class="var">factor</var>, int *<var class="var">offset</var>)</code><a class="copiable-link" href="#index-TARGET_005fDWARF_005fPOLY_005fINDETERMINATE_005fVALUE"> &para;</a></span></dt>
<dd><p>Express the value of <code class="code">poly_int</code> indeterminate <var class="var">i</var> as a DWARF
expression, with <var class="var">i</var> counting from 1.  Return the number of a DWARF
register <var class="var">R</var> and set &lsquo;<samp class="samp">*<var class="var">factor</var></samp>&rsquo; and &lsquo;<samp class="samp">*<var class="var">offset</var></samp>&rsquo; such
that the value of the indeterminate is:
</p><div class="example smallexample">
<pre class="example-preformatted">value_of(<var class="var">R</var>) / <var class="var">factor</var> - <var class="var">offset</var>
</pre></div>

<p>A target only needs to define this hook if it sets
&lsquo;<samp class="samp">NUM_POLY_INT_COEFFS</samp>&rsquo; to a value greater than 1.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-INCOMING_005fFRAME_005fSP_005fOFFSET"><span class="category-def">Macro: </span><span><strong class="def-name">INCOMING_FRAME_SP_OFFSET</strong><a class="copiable-link" href="#index-INCOMING_005fFRAME_005fSP_005fOFFSET"> &para;</a></span></dt>
<dd><p>A C expression whose value is an integer giving the offset, in bytes,
from the value of the stack pointer register to the top of the stack
frame at the beginning of any function, before the prologue.  The top of
the frame is defined to be the value of the stack pointer in the
previous frame, just before the call instruction.
</p>
<p>You only need to define this macro if you want to support call frame
debugging information like that provided by DWARF 2.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-DEFAULT_005fINCOMING_005fFRAME_005fSP_005fOFFSET"><span class="category-def">Macro: </span><span><strong class="def-name">DEFAULT_INCOMING_FRAME_SP_OFFSET</strong><a class="copiable-link" href="#index-DEFAULT_005fINCOMING_005fFRAME_005fSP_005fOFFSET"> &para;</a></span></dt>
<dd><p>Like <code class="code">INCOMING_FRAME_SP_OFFSET</code>, but must be the same for all
functions of the same ABI, and when using GAS <code class="code">.cfi_*</code> directives
must also agree with the default CFI GAS emits.  Define this macro
only if <code class="code">INCOMING_FRAME_SP_OFFSET</code> can have different values
between different functions of the same ABI or when
<code class="code">INCOMING_FRAME_SP_OFFSET</code> does not agree with GAS default CFI.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-ARG_005fPOINTER_005fCFA_005fOFFSET"><span class="category-def">Macro: </span><span><strong class="def-name">ARG_POINTER_CFA_OFFSET</strong> <var class="def-var-arguments">(<var class="var">fundecl</var>)</var><a class="copiable-link" href="#index-ARG_005fPOINTER_005fCFA_005fOFFSET"> &para;</a></span></dt>
<dd><p>A C expression whose value is an integer giving the offset, in bytes,
from the argument pointer to the canonical frame address (cfa).  The
final value should coincide with that calculated by
<code class="code">INCOMING_FRAME_SP_OFFSET</code>.  Which is unfortunately not usable
during virtual register instantiation.
</p>
<p>The default value for this macro is
<code class="code">FIRST_PARM_OFFSET (fundecl) + crtl-&gt;args.pretend_args_size</code>,
which is correct for most machines; in general, the arguments are found
immediately before the stack frame.  Note that this is not the case on
some targets that save registers into the caller&rsquo;s frame, such as SPARC
and rs6000, and so such targets need to define this macro.
</p>
<p>You only need to define this macro if the default is incorrect, and you
want to support call frame debugging information like that provided by
DWARF 2.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-FRAME_005fPOINTER_005fCFA_005fOFFSET"><span class="category-def">Macro: </span><span><strong class="def-name">FRAME_POINTER_CFA_OFFSET</strong> <var class="def-var-arguments">(<var class="var">fundecl</var>)</var><a class="copiable-link" href="#index-FRAME_005fPOINTER_005fCFA_005fOFFSET"> &para;</a></span></dt>
<dd><p>If defined, a C expression whose value is an integer giving the offset
in bytes from the frame pointer to the canonical frame address (cfa).
The final value should coincide with that calculated by
<code class="code">INCOMING_FRAME_SP_OFFSET</code>.
</p>
<p>Normally the CFA is calculated as an offset from the argument pointer,
via <code class="code">ARG_POINTER_CFA_OFFSET</code>, but if the argument pointer is
variable due to the ABI, this may not be possible.  If this macro is
defined, it implies that the virtual register instantiation should be
based on the frame pointer instead of the argument pointer.  Only one
of <code class="code">FRAME_POINTER_CFA_OFFSET</code> and <code class="code">ARG_POINTER_CFA_OFFSET</code>
should be defined.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-CFA_005fFRAME_005fBASE_005fOFFSET"><span class="category-def">Macro: </span><span><strong class="def-name">CFA_FRAME_BASE_OFFSET</strong> <var class="def-var-arguments">(<var class="var">fundecl</var>)</var><a class="copiable-link" href="#index-CFA_005fFRAME_005fBASE_005fOFFSET"> &para;</a></span></dt>
<dd><p>If defined, a C expression whose value is an integer giving the offset
in bytes from the canonical frame address (cfa) to the frame base used
in DWARF 2 debug information.  The default is zero.  A different value
may reduce the size of debug information on some ports.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fHAVE_005fSTRUB_005fSUPPORT_005fFOR"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_HAVE_STRUB_SUPPORT_FOR</strong> <code class="def-code-arguments">(tree)</code><a class="copiable-link" href="#index-TARGET_005fHAVE_005fSTRUB_005fSUPPORT_005fFOR"> &para;</a></span></dt>
<dd><p>Returns true if the target supports stack scrubbing for the given function
or type, otherwise return false.  The default implementation always returns
true.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-STACK_005fADDRESS_005fOFFSET"><span class="category-def">Macro: </span><span><strong class="def-name">STACK_ADDRESS_OFFSET</strong><a class="copiable-link" href="#index-STACK_005fADDRESS_005fOFFSET"> &para;</a></span></dt>
<dd><p>Offset from the stack pointer register to the boundary address between
the stack area claimed by an active function, and stack ranges that
could get clobbered if it called another function.  It should NOT
encompass any stack red zone, that is used in leaf functions.
</p>
<p>This value is added to the stack pointer register to compute the address
returned by <code class="code">__builtin_stack_address</code>, and this is its only use.
If this macro is not defined, no offset is added.  Defining it like
<code class="code">STACK_POINTER_OFFSET</code> may be appropriate for many machines, but
not all.
</p>
<p>On SPARC, for example, the register save area is *not* considered active
or used by the active function, but rather as akin to the area in which
call-preserved registers are saved by callees, so the stack address is
above that area, even though the (unbiased) stack pointer points below
it.  This enables <code class="code">__strub_leave</code> to clear what would otherwise
overlap with its own register save area.
</p>
<p>On PowerPC, <code class="code">STACK_POINTER_OFFSET</code> also reserves space for a save
area, but that area is used by the caller rather than the callee, so the
boundary address is below it.
</p>
<p>If the address is computed too high or too low, parts of a stack range
that should be scrubbed may be left unscrubbed, scrubbing may corrupt
active portions of the stack frame, and stack ranges may be
doubly-scrubbed by caller and callee.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-TARGET_005fSTRUB_005fUSE_005fDYNAMIC_005fARRAY"><span class="category-def">Macro: </span><span><strong class="def-name">TARGET_STRUB_USE_DYNAMIC_ARRAY</strong><a class="copiable-link" href="#index-TARGET_005fSTRUB_005fUSE_005fDYNAMIC_005fARRAY"> &para;</a></span></dt>
<dd><p>If defined to nonzero, <code class="code">__strub_leave</code> will allocate a dynamic
array covering the stack range that needs scrubbing before clearing it.
Allocating the array tends to make scrubbing slower, but it enables the
scrubbing to be safely implemented with a <code class="code">memset</code> call, which
could make up for the difference.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-TARGET_005fSTRUB_005fMAY_005fUSE_005fMEMSET"><span class="category-def">Macro: </span><span><strong class="def-name">TARGET_STRUB_MAY_USE_MEMSET</strong><a class="copiable-link" href="#index-TARGET_005fSTRUB_005fMAY_005fUSE_005fMEMSET"> &para;</a></span></dt>
<dd><p>If defined to nonzero, enable <code class="code">__strub_leave</code> to be optimized so as
to call <code class="code">memset</code> for stack scrubbing.  This is only enabled by
default if <code class="code">TARGET_STRUB_USE_DYNAMIC_ARRAY</code> is enabled; it&rsquo;s not
advisable to enable it otherwise, since <code class="code">memset</code> would then likely
overwrite its own stack frame, but it might work if the target ABI
enables <code class="code">memset</code> to not use the stack at all, not even for
arguments or its return address, and its implementation is trivial
enough that it doesn&rsquo;t use a stack frame.
</p></dd></dl>

</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Exception-Handling.html">Exception Handling Support</a>, Up: <a href="Stack-and-Calling.html">Stack Layout and Calling Conventions</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Option-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>

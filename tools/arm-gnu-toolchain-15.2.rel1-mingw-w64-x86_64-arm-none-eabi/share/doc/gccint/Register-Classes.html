<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- Copyright Â© 1988-2025 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Funding Free Software", the Front-Cover
Texts being (a) (see below), and with the Back-Cover Texts being (b)
(see below).  A copy of the license is included in the section entitled
"GNU Free Documentation License".

(a) The FSF's Front-Cover Text is:

A GNU Manual

(b) The FSF's Back-Cover Text is:

You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development. -->
<title>Register Classes (GNU Compiler Collection (GCC) Internals)</title>

<meta name="description" content="Register Classes (GNU Compiler Collection (GCC) Internals)">
<meta name="keywords" content="Register Classes (GNU Compiler Collection (GCC) Internals)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Option-Index.html" rel="index" title="Option Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Target-Macros.html" rel="up" title="Target Macros">
<link href="Stack-and-Calling.html" rel="next" title="Stack and Calling">
<link href="Registers.html" rel="prev" title="Registers">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>


</head>

<body lang="en">
<div class="section-level-extent" id="Register-Classes">
<div class="nav-panel">
<p>
Next: <a href="Stack-and-Calling.html" accesskey="n" rel="next">Stack Layout and Calling Conventions</a>, Previous: <a href="Registers.html" accesskey="p" rel="prev">Register Usage</a>, Up: <a href="Target-Macros.html" accesskey="u" rel="up">Target Description Macros and Functions</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Option-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="Register-Classes-1"><span>17.8 Register Classes<a class="copiable-link" href="#Register-Classes-1"> &para;</a></span></h3>
<a class="index-entry-id" id="index-register-class-definitions"></a>
<a class="index-entry-id" id="index-class-definitions_002c-register"></a>

<p>On many machines, the numbered registers are not all equivalent.
For example, certain registers may not be allowed for indexed addressing;
certain registers may not be allowed in some instructions.  These machine
restrictions are described to the compiler using <em class="dfn">register classes</em>.
</p>
<p>You define a number of register classes, giving each one a name and saying
which of the registers belong to it.  Then you can specify register classes
that are allowed as operands to particular instruction patterns.
</p>
<a class="index-entry-id" id="index-ALL_005fREGS"></a>
<a class="index-entry-id" id="index-NO_005fREGS"></a>
<p>In general, each register will belong to several classes.  In fact, one
class must be named <code class="code">ALL_REGS</code> and contain all the registers.  Another
class must be named <code class="code">NO_REGS</code> and contain no registers.  Often the
union of two classes will be another class; however, this is not required.
</p>
<a class="index-entry-id" id="index-GENERAL_005fREGS"></a>
<p>One of the classes must be named <code class="code">GENERAL_REGS</code>.  There is nothing
terribly special about the name, but the operand constraint letters
&lsquo;<samp class="samp">r</samp>&rsquo; and &lsquo;<samp class="samp">g</samp>&rsquo; specify this class.  If <code class="code">GENERAL_REGS</code> is
the same as <code class="code">ALL_REGS</code>, just define it as a macro which expands
to <code class="code">ALL_REGS</code>.
</p>
<p>Order the classes so that if class <var class="var">x</var> is contained in class <var class="var">y</var>
then <var class="var">x</var> has a lower class number than <var class="var">y</var>.
</p>
<p>The way classes other than <code class="code">GENERAL_REGS</code> are specified in operand
constraints is through machine-dependent operand constraint letters.
You can define such letters to correspond to various classes, then use
them in operand constraints.
</p>
<p>You must define the narrowest register classes for allocatable
registers, so that each class either has no subclasses, or that for
some mode, the move cost between registers within the class is
cheaper than moving a register in the class to or from memory
(see <a class="pxref" href="Costs.html">Describing Relative Costs of Operations</a>).
</p>
<p>You should define a class for the union of two classes whenever some
instruction allows both classes.  For example, if an instruction allows
either a floating point (coprocessor) register or a general register for a
certain operand, you should define a class <code class="code">FLOAT_OR_GENERAL_REGS</code>
which includes both of them.  Otherwise you will get suboptimal code,
or even internal compiler errors when reload cannot find a register in the
class computed via <code class="code">reg_class_subunion</code>.
</p>
<p>You must also specify certain redundant information about the register
classes: for each class, which classes contain it and which ones are
contained in it; for each pair of classes, the largest class contained
in their union.
</p>
<p>When a value occupying several consecutive registers is expected in a
certain class, all the registers used must belong to that class.
Therefore, register classes cannot be used to enforce a requirement for
a register pair to start with an even-numbered register.  The way to
specify this requirement is with <code class="code">TARGET_HARD_REGNO_MODE_OK</code>,
or with a filter expression in a <code class="code">define_register_constraint</code>.
</p>
<p>Register classes used for input-operands of bitwise-and or shift
instructions have a special requirement: each such class must have, for
each fixed-point machine mode, a subclass whose registers can transfer that
mode to or from memory.  For example, on some machines, the operations for
single-byte values (<code class="code">QImode</code>) are limited to certain registers.  When
this is so, each register class that is used in a bitwise-and or shift
instruction must have a subclass consisting of registers from which
single-byte values can be loaded or stored.  This is so that
<code class="code">PREFERRED_RELOAD_CLASS</code> can always have a possible value to return.
</p>
<dl class="first-deftp">
<dt class="deftp" id="index-enum-reg_005fclass"><span class="category-def">Data type: </span><span><strong class="def-name">enum reg_class</strong><a class="copiable-link" href="#index-enum-reg_005fclass"> &para;</a></span></dt>
<dd><p>An enumerated type that must be defined with all the register class names
as enumerated values.  <code class="code">NO_REGS</code> must be first.  <code class="code">ALL_REGS</code>
must be the last register class, followed by one more enumerated value,
<code class="code">LIM_REG_CLASSES</code>, which is not a register class but rather
tells how many classes there are.
</p>
<p>Each register class has a number, which is the value of casting
the class name to type <code class="code">int</code>.  The number serves as an index
in many of the tables described below.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-N_005fREG_005fCLASSES"><span class="category-def">Macro: </span><span><strong class="def-name">N_REG_CLASSES</strong><a class="copiable-link" href="#index-N_005fREG_005fCLASSES"> &para;</a></span></dt>
<dd><p>The number of distinct register classes, defined as follows:
</p>
<div class="example smallexample">
<pre class="example-preformatted">#define N_REG_CLASSES (int) LIM_REG_CLASSES
</pre></div>
</dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-REG_005fCLASS_005fNAMES"><span class="category-def">Macro: </span><span><strong class="def-name">REG_CLASS_NAMES</strong><a class="copiable-link" href="#index-REG_005fCLASS_005fNAMES"> &para;</a></span></dt>
<dd><p>An initializer containing the names of the register classes as C string
constants.  These names are used in writing some of the debugging dumps.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-REG_005fCLASS_005fCONTENTS"><span class="category-def">Macro: </span><span><strong class="def-name">REG_CLASS_CONTENTS</strong><a class="copiable-link" href="#index-REG_005fCLASS_005fCONTENTS"> &para;</a></span></dt>
<dd><p>An initializer containing the contents of the register classes, as integers
which are bit masks.  The <var class="var">n</var>th integer specifies the contents of class
<var class="var">n</var>.  The way the integer <var class="var">mask</var> is interpreted is that
register <var class="var">r</var> is in the class if <code class="code"><var class="var">mask</var> &amp; (1 &lt;&lt; <var class="var">r</var>)</code> is 1.
</p>
<p>When the machine has more than 32 registers, an integer does not suffice.
Then the integers are replaced by sub-initializers, braced groupings containing
several integers.  Each sub-initializer must be suitable as an initializer
for the type <code class="code">HARD_REG_SET</code> which is defined in <samp class="file">hard-reg-set.h</samp>.
In this situation, the first integer in each sub-initializer corresponds to
registers 0 through 31, the second integer to registers 32 through 63, and
so on.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-REGNO_005fREG_005fCLASS"><span class="category-def">Macro: </span><span><strong class="def-name">REGNO_REG_CLASS</strong> <var class="def-var-arguments">(<var class="var">regno</var>)</var><a class="copiable-link" href="#index-REGNO_005fREG_005fCLASS"> &para;</a></span></dt>
<dd><p>A C expression whose value is a register class containing hard register
<var class="var">regno</var>.  In general there is more than one such class; choose a class
which is <em class="dfn">minimal</em>, meaning that no smaller class also contains the
register.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-BASE_005fREG_005fCLASS"><span class="category-def">Macro: </span><span><strong class="def-name">BASE_REG_CLASS</strong><a class="copiable-link" href="#index-BASE_005fREG_005fCLASS"> &para;</a></span></dt>
<dd><p>A macro whose definition is the name of the class to which a valid
base register must belong.  A base register is one used in an address
which is the register value plus a displacement.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-MODE_005fBASE_005fREG_005fCLASS"><span class="category-def">Macro: </span><span><strong class="def-name">MODE_BASE_REG_CLASS</strong> <var class="def-var-arguments">(<var class="var">mode</var>)</var><a class="copiable-link" href="#index-MODE_005fBASE_005fREG_005fCLASS"> &para;</a></span></dt>
<dd><p>This is a variation of the <code class="code">BASE_REG_CLASS</code> macro which allows
the selection of a base register in a mode dependent manner.  If
<var class="var">mode</var> is VOIDmode then it should return the same value as
<code class="code">BASE_REG_CLASS</code>.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-MODE_005fBASE_005fREG_005fREG_005fCLASS"><span class="category-def">Macro: </span><span><strong class="def-name">MODE_BASE_REG_REG_CLASS</strong> <var class="def-var-arguments">(<var class="var">mode</var>)</var><a class="copiable-link" href="#index-MODE_005fBASE_005fREG_005fREG_005fCLASS"> &para;</a></span></dt>
<dd><p>A C expression whose value is the register class to which a valid
base register must belong in order to be used in a base plus index
register address.  You should define this macro if base plus index
addresses have different requirements than other base register uses.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-MODE_005fCODE_005fBASE_005fREG_005fCLASS"><span class="category-def">Macro: </span><span><strong class="def-name">MODE_CODE_BASE_REG_CLASS</strong> <var class="def-var-arguments">(<var class="var">mode</var>, <var class="var">address_space</var>, <var class="var">outer_code</var>, <var class="var">index_code</var>)</var><a class="copiable-link" href="#index-MODE_005fCODE_005fBASE_005fREG_005fCLASS"> &para;</a></span></dt>
<dd><p>A C expression whose value is the register class to which a valid
base register for a memory reference in mode <var class="var">mode</var> to address
space <var class="var">address_space</var> must belong.  <var class="var">outer_code</var> and <var class="var">index_code</var>
define the context in which the base register occurs.  <var class="var">outer_code</var> is
the code of the immediately enclosing expression (<code class="code">MEM</code> for the top level
of an address, <code class="code">ADDRESS</code> for something that occurs in an
<code class="code">address_operand</code>).  <var class="var">index_code</var> is the code of the corresponding
index expression if <var class="var">outer_code</var> is <code class="code">PLUS</code>; <code class="code">SCRATCH</code> otherwise.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-INSN_005fBASE_005fREG_005fCLASS"><span class="category-def">Macro: </span><span><strong class="def-name">INSN_BASE_REG_CLASS</strong> <var class="def-var-arguments">(<var class="var">insn</var>)</var><a class="copiable-link" href="#index-INSN_005fBASE_005fREG_005fCLASS"> &para;</a></span></dt>
<dd><p>A C expression whose value is the register class to which a valid
base register for a specified <var class="var">insn</var> must belong. This macro is
used when some backend insns may have limited usage of base register
compared with other insns. If you define this macro, the compiler will
use it instead of all other defined macros that relate to
BASE_REG_CLASS.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-INDEX_005fREG_005fCLASS"><span class="category-def">Macro: </span><span><strong class="def-name">INDEX_REG_CLASS</strong><a class="copiable-link" href="#index-INDEX_005fREG_005fCLASS"> &para;</a></span></dt>
<dd><p>A macro whose definition is the name of the class to which a valid
index register must belong.  An index register is one used in an
address where its value is either multiplied by a scale factor or
added to another register (as well as added to a displacement).
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-INSN_005fINDEX_005fREG_005fCLASS"><span class="category-def">Macro: </span><span><strong class="def-name">INSN_INDEX_REG_CLASS</strong> <var class="def-var-arguments">(<var class="var">insn</var>)</var><a class="copiable-link" href="#index-INSN_005fINDEX_005fREG_005fCLASS"> &para;</a></span></dt>
<dd><p>A C expression whose value is the register class to which a valid
index register for a specified <var class="var">insn</var> must belong. This macro is
used when some backend insns may have limited usage of index register
compared with other insns. If you defined this macro, the compiler
will use it instead of <code class="code">INDEX_REG_CLASS</code>.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-REGNO_005fOK_005fFOR_005fBASE_005fP"><span class="category-def">Macro: </span><span><strong class="def-name">REGNO_OK_FOR_BASE_P</strong> <var class="def-var-arguments">(<var class="var">num</var>)</var><a class="copiable-link" href="#index-REGNO_005fOK_005fFOR_005fBASE_005fP"> &para;</a></span></dt>
<dd><p>A C expression which is nonzero if register number <var class="var">num</var> is
suitable for use as a base register in operand addresses.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-REGNO_005fMODE_005fOK_005fFOR_005fBASE_005fP"><span class="category-def">Macro: </span><span><strong class="def-name">REGNO_MODE_OK_FOR_BASE_P</strong> <var class="def-var-arguments">(<var class="var">num</var>, <var class="var">mode</var>)</var><a class="copiable-link" href="#index-REGNO_005fMODE_005fOK_005fFOR_005fBASE_005fP"> &para;</a></span></dt>
<dd><p>A C expression that is just like <code class="code">REGNO_OK_FOR_BASE_P</code>, except that
that expression may examine the mode of the memory reference in
<var class="var">mode</var>.  You should define this macro if the mode of the memory
reference affects whether a register may be used as a base register.  If
you define this macro, the compiler will use it instead of
<code class="code">REGNO_OK_FOR_BASE_P</code>.  The mode may be <code class="code">VOIDmode</code> for
addresses that appear outside a <code class="code">MEM</code>, i.e., as an
<code class="code">address_operand</code>.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-REGNO_005fMODE_005fOK_005fFOR_005fREG_005fBASE_005fP"><span class="category-def">Macro: </span><span><strong class="def-name">REGNO_MODE_OK_FOR_REG_BASE_P</strong> <var class="def-var-arguments">(<var class="var">num</var>, <var class="var">mode</var>)</var><a class="copiable-link" href="#index-REGNO_005fMODE_005fOK_005fFOR_005fREG_005fBASE_005fP"> &para;</a></span></dt>
<dd><p>A C expression which is nonzero if register number <var class="var">num</var> is suitable for
use as a base register in base plus index operand addresses, accessing
memory in mode <var class="var">mode</var>.  It may be either a suitable hard register or a
pseudo register that has been allocated such a hard register.  You should
define this macro if base plus index addresses have different requirements
than other base register uses.
</p>
<p>Use of this macro is deprecated; please use the more general
<code class="code">REGNO_MODE_CODE_OK_FOR_BASE_P</code>.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-REGNO_005fMODE_005fCODE_005fOK_005fFOR_005fBASE_005fP"><span class="category-def">Macro: </span><span><strong class="def-name">REGNO_MODE_CODE_OK_FOR_BASE_P</strong> <var class="def-var-arguments">(<var class="var">num</var>, <var class="var">mode</var>, <var class="var">address_space</var>, <var class="var">outer_code</var>, <var class="var">index_code</var>)</var><a class="copiable-link" href="#index-REGNO_005fMODE_005fCODE_005fOK_005fFOR_005fBASE_005fP"> &para;</a></span></dt>
<dd><p>A C expression which is nonzero if register number <var class="var">num</var> is
suitable for use as a base register in operand addresses, accessing
memory in mode <var class="var">mode</var> in address space <var class="var">address_space</var>.
This is similar to <code class="code">REGNO_MODE_OK_FOR_BASE_P</code>, except
that that expression may examine the context in which the register
appears in the memory reference.  <var class="var">outer_code</var> is the code of the
immediately enclosing expression (<code class="code">MEM</code> if at the top level of the
address, <code class="code">ADDRESS</code> for something that occurs in an
<code class="code">address_operand</code>).  <var class="var">index_code</var> is the code of the
corresponding index expression if <var class="var">outer_code</var> is <code class="code">PLUS</code>;
<code class="code">SCRATCH</code> otherwise.  The mode may be <code class="code">VOIDmode</code> for addresses
that appear outside a <code class="code">MEM</code>, i.e., as an <code class="code">address_operand</code>.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-REGNO_005fOK_005fFOR_005fINSN_005fBASE_005fP"><span class="category-def">Macro: </span><span><strong class="def-name">REGNO_OK_FOR_INSN_BASE_P</strong> <var class="def-var-arguments">(<var class="var">num</var>, <var class="var">insn</var>)</var><a class="copiable-link" href="#index-REGNO_005fOK_005fFOR_005fINSN_005fBASE_005fP"> &para;</a></span></dt>
<dd><p>A C expression which is nonzero if register number <var class="var">num</var> is
suitable for use as a base register in operand addresses for a specified
<var class="var">insn</var>. This macro is used when some backend insn may have limited
usage of base register compared with other insns. If you define this
macro, the compiler will use it instead of all other defined macros
that relate to REGNO_OK_FOR_BASE_P.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-REGNO_005fOK_005fFOR_005fINDEX_005fP"><span class="category-def">Macro: </span><span><strong class="def-name">REGNO_OK_FOR_INDEX_P</strong> <var class="def-var-arguments">(<var class="var">num</var>)</var><a class="copiable-link" href="#index-REGNO_005fOK_005fFOR_005fINDEX_005fP"> &para;</a></span></dt>
<dd><p>A C expression which is nonzero if register number <var class="var">num</var> is
suitable for use as an index register in operand addresses.  It may be
either a suitable hard register or a pseudo register that has been
allocated such a hard register.
</p>
<p>The difference between an index register and a base register is that
the index register may be scaled.  If an address involves the sum of
two registers, neither one of them scaled, then either one may be
labeled the &ldquo;base&rdquo; and the other the &ldquo;index&rdquo;; but whichever
labeling is used must fit the machine&rsquo;s constraints of which registers
may serve in each capacity.  The compiler will try both labelings,
looking for one that is valid, and will reload one or both registers
only if neither labeling works.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fPREFERRED_005fRENAME_005fCLASS"><span class="category-def">Target Hook: </span><span><code class="def-type">reg_class_t</code> <strong class="def-name">TARGET_PREFERRED_RENAME_CLASS</strong> <code class="def-code-arguments">(reg_class_t <var class="var">rclass</var>)</code><a class="copiable-link" href="#index-TARGET_005fPREFERRED_005fRENAME_005fCLASS"> &para;</a></span></dt>
<dd><p>A target hook that places additional preference on the register
class to use when it is necessary to rename a register in class
<var class="var">rclass</var> to another class, or perhaps <var class="var">NO_REGS</var>, if no
preferred register class is found or hook <code class="code">preferred_rename_class</code>
is not implemented.
Sometimes returning a more restrictive class makes better code.  For
example, on ARM, thumb-2 instructions using <code class="code">LO_REGS</code> may be
smaller than instructions using <code class="code">GENERIC_REGS</code>.  By returning
<code class="code">LO_REGS</code> from <code class="code">preferred_rename_class</code>, code size can
be reduced.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fPREFERRED_005fRELOAD_005fCLASS"><span class="category-def">Target Hook: </span><span><code class="def-type">reg_class_t</code> <strong class="def-name">TARGET_PREFERRED_RELOAD_CLASS</strong> <code class="def-code-arguments">(rtx <var class="var">x</var>, reg_class_t <var class="var">rclass</var>)</code><a class="copiable-link" href="#index-TARGET_005fPREFERRED_005fRELOAD_005fCLASS"> &para;</a></span></dt>
<dd><p>A target hook that places additional restrictions on the register class
to use when it is necessary to copy value <var class="var">x</var> into a register in class
<var class="var">rclass</var>.  The value is a register class; perhaps <var class="var">rclass</var>, or perhaps
another, smaller class.
</p>
<p>The default version of this hook always returns value of <code class="code">rclass</code> argument.
</p>
<p>Sometimes returning a more restrictive class makes better code.  For
example, on the 68000, when <var class="var">x</var> is an integer constant that is in range
for a &lsquo;<samp class="samp">moveq</samp>&rsquo; instruction, the value of this macro is always
<code class="code">DATA_REGS</code> as long as <var class="var">rclass</var> includes the data registers.
Requiring a data register guarantees that a &lsquo;<samp class="samp">moveq</samp>&rsquo; will be used.
</p>
<p>One case where <code class="code">TARGET_PREFERRED_RELOAD_CLASS</code> must not return
<var class="var">rclass</var> is if <var class="var">x</var> is a legitimate constant which cannot be
loaded into some register class.  By returning <code class="code">NO_REGS</code> you can
force <var class="var">x</var> into a memory location.  For example, rs6000 can load
immediate values into general-purpose registers, but does not have an
instruction for loading an immediate value into a floating-point
register, so <code class="code">TARGET_PREFERRED_RELOAD_CLASS</code> returns <code class="code">NO_REGS</code> when
<var class="var">x</var> is a floating-point constant.  If the constant can&rsquo;t be loaded
into any kind of register, code generation will be better if
<code class="code">TARGET_LEGITIMATE_CONSTANT_P</code> makes the constant illegitimate instead
of using <code class="code">TARGET_PREFERRED_RELOAD_CLASS</code>.
</p>
<p>If an insn has pseudos in it after register allocation, reload will go
through the alternatives and call repeatedly <code class="code">TARGET_PREFERRED_RELOAD_CLASS</code>
to find the best one.  Returning <code class="code">NO_REGS</code>, in this case, makes
reload add a <code class="code">!</code> in front of the constraint: the x86 back-end uses
this feature to discourage usage of 387 registers when math is done in
the SSE registers (and vice versa).
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-PREFERRED_005fRELOAD_005fCLASS"><span class="category-def">Macro: </span><span><strong class="def-name">PREFERRED_RELOAD_CLASS</strong> <var class="def-var-arguments">(<var class="var">x</var>, <var class="var">class</var>)</var><a class="copiable-link" href="#index-PREFERRED_005fRELOAD_005fCLASS"> &para;</a></span></dt>
<dd><p>A C expression that places additional restrictions on the register class
to use when it is necessary to copy value <var class="var">x</var> into a register in class
<var class="var">class</var>.  The value is a register class; perhaps <var class="var">class</var>, or perhaps
another, smaller class.  On many machines, the following definition is
safe:
</p>
<div class="example smallexample">
<pre class="example-preformatted">#define PREFERRED_RELOAD_CLASS(X,CLASS) CLASS
</pre></div>

<p>Sometimes returning a more restrictive class makes better code.  For
example, on the 68000, when <var class="var">x</var> is an integer constant that is in range
for a &lsquo;<samp class="samp">moveq</samp>&rsquo; instruction, the value of this macro is always
<code class="code">DATA_REGS</code> as long as <var class="var">class</var> includes the data registers.
Requiring a data register guarantees that a &lsquo;<samp class="samp">moveq</samp>&rsquo; will be used.
</p>
<p>One case where <code class="code">PREFERRED_RELOAD_CLASS</code> must not return
<var class="var">class</var> is if <var class="var">x</var> is a legitimate constant which cannot be
loaded into some register class.  By returning <code class="code">NO_REGS</code> you can
force <var class="var">x</var> into a memory location.  For example, rs6000 can load
immediate values into general-purpose registers, but does not have an
instruction for loading an immediate value into a floating-point
register, so <code class="code">PREFERRED_RELOAD_CLASS</code> returns <code class="code">NO_REGS</code> when
<var class="var">x</var> is a floating-point constant.  If the constant cannot be loaded
into any kind of register, code generation will be better if
<code class="code">TARGET_LEGITIMATE_CONSTANT_P</code> makes the constant illegitimate instead
of using <code class="code">TARGET_PREFERRED_RELOAD_CLASS</code>.
</p>
<p>If an insn has pseudos in it after register allocation, reload will go
through the alternatives and call repeatedly <code class="code">PREFERRED_RELOAD_CLASS</code>
to find the best one.  Returning <code class="code">NO_REGS</code>, in this case, makes
reload add a <code class="code">!</code> in front of the constraint: the x86 back-end uses
this feature to discourage usage of 387 registers when math is done in
the SSE registers (and vice versa).
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fPREFERRED_005fOUTPUT_005fRELOAD_005fCLASS"><span class="category-def">Target Hook: </span><span><code class="def-type">reg_class_t</code> <strong class="def-name">TARGET_PREFERRED_OUTPUT_RELOAD_CLASS</strong> <code class="def-code-arguments">(rtx <var class="var">x</var>, reg_class_t <var class="var">rclass</var>)</code><a class="copiable-link" href="#index-TARGET_005fPREFERRED_005fOUTPUT_005fRELOAD_005fCLASS"> &para;</a></span></dt>
<dd><p>Like <code class="code">TARGET_PREFERRED_RELOAD_CLASS</code>, but for output reloads instead of
input reloads.
</p>
<p>The default version of this hook always returns value of <code class="code">rclass</code>
argument.
</p>
<p>You can also use <code class="code">TARGET_PREFERRED_OUTPUT_RELOAD_CLASS</code> to discourage
reload from using some alternatives, like <code class="code">TARGET_PREFERRED_RELOAD_CLASS</code>.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-LIMIT_005fRELOAD_005fCLASS"><span class="category-def">Macro: </span><span><strong class="def-name">LIMIT_RELOAD_CLASS</strong> <var class="def-var-arguments">(<var class="var">mode</var>, <var class="var">class</var>)</var><a class="copiable-link" href="#index-LIMIT_005fRELOAD_005fCLASS"> &para;</a></span></dt>
<dd><p>A C expression that places additional restrictions on the register class
to use when it is necessary to be able to hold a value of mode
<var class="var">mode</var> in a reload register for which class <var class="var">class</var> would
ordinarily be used.
</p>
<p>Unlike <code class="code">PREFERRED_RELOAD_CLASS</code>, this macro should be used when
there are certain modes that simply cannot go in certain reload classes.
</p>
<p>The value is a register class; perhaps <var class="var">class</var>, or perhaps another,
smaller class.
</p>
<p>Don&rsquo;t define this macro unless the target machine has limitations which
require the macro to do something nontrivial.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSECONDARY_005fRELOAD"><span class="category-def">Target Hook: </span><span><code class="def-type">reg_class_t</code> <strong class="def-name">TARGET_SECONDARY_RELOAD</strong> <code class="def-code-arguments">(bool <var class="var">in_p</var>, rtx <var class="var">x</var>, reg_class_t <var class="var">reload_class</var>, machine_mode <var class="var">reload_mode</var>, secondary_reload_info *<var class="var">sri</var>)</code><a class="copiable-link" href="#index-TARGET_005fSECONDARY_005fRELOAD"> &para;</a></span></dt>
<dd><p>Many machines have some registers that cannot be copied directly to or
from memory or even from other types of registers.  An example is the
&lsquo;<samp class="samp">MQ</samp>&rsquo; register, which on most machines, can only be copied to or
from general registers, but not memory.  Below, we shall be using the
term &rsquo;intermediate register&rsquo; when a move operation cannot be performed
directly, but has to be done by copying the source into the intermediate
register first, and then copying the intermediate register to the
destination.  An intermediate register always has the same mode as
source and destination.  Since it holds the actual value being copied,
reload might apply optimizations to re-use an intermediate register
and eliding the copy from the source when it can determine that the
intermediate register still holds the required value.
</p>
<p>Another kind of secondary reload is required on some machines which
allow copying all registers to and from memory, but require a scratch
register for stores to some memory locations (e.g., those with symbolic
address on the RT, and those with certain symbolic address on the SPARC
when compiling PIC).  Scratch registers need not have the same mode
as the value being copied, and usually hold a different value than
that being copied.  Special patterns in the md file are needed to
describe how the copy is performed with the help of the scratch register;
these patterns also describe the number, register class(es) and mode(s)
of the scratch register(s).
</p>
<p>In some cases, both an intermediate and a scratch register are required.
</p>
<p>For input reloads, this target hook is called with nonzero <var class="var">in_p</var>,
and <var class="var">x</var> is an rtx that needs to be copied to a register of class
<var class="var">reload_class</var> in <var class="var">reload_mode</var>.  For output reloads, this target
hook is called with zero <var class="var">in_p</var>, and a register of class <var class="var">reload_class</var>
needs to be copied to rtx <var class="var">x</var> in <var class="var">reload_mode</var>.
</p>
<p>If copying a register of <var class="var">reload_class</var> from/to <var class="var">x</var> requires
an intermediate register, the hook <code class="code">secondary_reload</code> should
return the register class required for this intermediate register.
If no intermediate register is required, it should return NO_REGS.
If more than one intermediate register is required, describe the one
that is closest in the copy chain to the reload register.
</p>
<p>If scratch registers are needed, you also have to describe how to
perform the copy from/to the reload register to/from this
closest intermediate register.  Or if no intermediate register is
required, but still a scratch register is needed, describe the
copy  from/to the reload register to/from the reload operand <var class="var">x</var>.
</p>
<p>You do this by setting <code class="code">sri-&gt;icode</code> to the instruction code of a pattern
in the md file which performs the move.  Operands 0 and 1 are the output
and input of this copy, respectively.  Operands from operand 2 onward are
for scratch operands.  These scratch operands must have a mode, and a
single-register-class
output constraint.
</p>
<p>When an intermediate register is used, the <code class="code">secondary_reload</code>
hook will be called again to determine how to copy the intermediate
register to/from the reload operand <var class="var">x</var>, so your hook must also
have code to handle the register class of the intermediate operand.
</p>


<p><var class="var">x</var> might be a pseudo-register or a <code class="code">subreg</code> of a
pseudo-register, which could either be in a hard register or in memory.
Use <code class="code">true_regnum</code> to find out; it will return &minus;1 if the pseudo is
in memory and the hard register number if it is in a register.
</p>
<p>Scratch operands in memory (constraint <code class="code">&quot;=m&quot;</code> / <code class="code">&quot;=&amp;m&quot;</code>) are
currently not supported.  For the time being, you will have to continue
to use <code class="code">TARGET_SECONDARY_MEMORY_NEEDED</code> for that purpose.
</p>
<p><code class="code">copy_cost</code> also uses this target hook to find out how values are
copied.  If you want it to include some extra cost for the need to allocate
(a) scratch register(s), set <code class="code">sri-&gt;extra_cost</code> to the additional cost.
Or if two dependent moves are supposed to have a lower cost than the sum
of the individual moves due to expected fortuitous scheduling and/or special
forwarding logic, you can set <code class="code">sri-&gt;extra_cost</code> to a negative amount.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-SECONDARY_005fRELOAD_005fCLASS"><span class="category-def">Macro: </span><span><strong class="def-name">SECONDARY_RELOAD_CLASS</strong> <var class="def-var-arguments">(<var class="var">class</var>, <var class="var">mode</var>, <var class="var">x</var>)</var><a class="copiable-link" href="#index-SECONDARY_005fRELOAD_005fCLASS"> &para;</a></span></dt>
<dt class="deffnx defmacx-alias-deffnx def-cmd-deffn" id="index-SECONDARY_005fINPUT_005fRELOAD_005fCLASS"><span class="category-def">Macro: </span><span><strong class="def-name">SECONDARY_INPUT_RELOAD_CLASS</strong> <var class="def-var-arguments">(<var class="var">class</var>, <var class="var">mode</var>, <var class="var">x</var>)</var><a class="copiable-link" href="#index-SECONDARY_005fINPUT_005fRELOAD_005fCLASS"> &para;</a></span></dt>
<dt class="deffnx defmacx-alias-deffnx def-cmd-deffn" id="index-SECONDARY_005fOUTPUT_005fRELOAD_005fCLASS"><span class="category-def">Macro: </span><span><strong class="def-name">SECONDARY_OUTPUT_RELOAD_CLASS</strong> <var class="def-var-arguments">(<var class="var">class</var>, <var class="var">mode</var>, <var class="var">x</var>)</var><a class="copiable-link" href="#index-SECONDARY_005fOUTPUT_005fRELOAD_005fCLASS"> &para;</a></span></dt>
<dd><p>These macros are obsolete, new ports should use the target hook
<code class="code">TARGET_SECONDARY_RELOAD</code> instead.
</p>
<p>These are obsolete macros, replaced by the <code class="code">TARGET_SECONDARY_RELOAD</code>
target hook.  Older ports still define these macros to indicate to the
reload phase that it may
need to allocate at least one register for a reload in addition to the
register to contain the data.  Specifically, if copying <var class="var">x</var> to a
register <var class="var">class</var> in <var class="var">mode</var> requires an intermediate register,
you were supposed to define <code class="code">SECONDARY_INPUT_RELOAD_CLASS</code> to return the
largest register class all of whose registers can be used as
intermediate registers or scratch registers.
</p>
<p>If copying a register <var class="var">class</var> in <var class="var">mode</var> to <var class="var">x</var> requires an
intermediate or scratch register, <code class="code">SECONDARY_OUTPUT_RELOAD_CLASS</code>
was supposed to be defined to return the largest register
class required.  If the
requirements for input and output reloads were the same, the macro
<code class="code">SECONDARY_RELOAD_CLASS</code> should have been used instead of defining both
macros identically.
</p>
<p>The values returned by these macros are often <code class="code">GENERAL_REGS</code>.
Return <code class="code">NO_REGS</code> if no spare register is needed; i.e., if <var class="var">x</var>
can be directly copied to or from a register of <var class="var">class</var> in
<var class="var">mode</var> without requiring a scratch register.  Do not define this
macro if it would always return <code class="code">NO_REGS</code>.
</p>
<p>If a scratch register is required (either with or without an
intermediate register), you were supposed to define patterns for
&lsquo;<samp class="samp">reload_in<var class="var">m</var></samp>&rsquo; or &lsquo;<samp class="samp">reload_out<var class="var">m</var></samp>&rsquo;, as required
(see <a class="pxref" href="Standard-Names.html">Standard Pattern Names For Generation</a>.  These patterns, which were normally
implemented with a <code class="code">define_expand</code>, should be similar to the
&lsquo;<samp class="samp">mov<var class="var">m</var></samp>&rsquo; patterns, except that operand 2 is the scratch
register.
</p>
<p>These patterns need constraints for the reload register and scratch
register that
contain a single register class.  If the original reload register (whose
class is <var class="var">class</var>) can meet the constraint given in the pattern, the
value returned by these macros is used for the class of the scratch
register.  Otherwise, two additional reload registers are required.
Their classes are obtained from the constraints in the insn pattern.
</p>
<p><var class="var">x</var> might be a pseudo-register or a <code class="code">subreg</code> of a
pseudo-register, which could either be in a hard register or in memory.
Use <code class="code">true_regnum</code> to find out; it will return &minus;1 if the pseudo is
in memory and the hard register number if it is in a register.
</p>
<p>These macros should not be used in the case where a particular class of
registers can only be copied to memory and not to another class of
registers.  In that case, secondary reload registers are not needed and
would not be helpful.  Instead, a stack location must be used to perform
the copy and the <code class="code">mov<var class="var">m</var></code> pattern should use memory as an
intermediate storage.  This case often occurs between floating-point and
general registers.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSECONDARY_005fMEMORY_005fNEEDED"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_SECONDARY_MEMORY_NEEDED</strong> <code class="def-code-arguments">(machine_mode <var class="var">mode</var>, reg_class_t <var class="var">class1</var>, reg_class_t <var class="var">class2</var>)</code><a class="copiable-link" href="#index-TARGET_005fSECONDARY_005fMEMORY_005fNEEDED"> &para;</a></span></dt>
<dd><p>Certain machines have the property that some registers cannot be copied
to some other registers without using memory.  Define this hook on
those machines to return true if objects of mode <var class="var">m</var> in registers
of <var class="var">class1</var> can only be copied to registers of class <var class="var">class2</var> by
 storing a register of <var class="var">class1</var> into memory and loading that memory
location into a register of <var class="var">class2</var>.  The default definition returns
false for all inputs.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-SECONDARY_005fMEMORY_005fNEEDED_005fRTX"><span class="category-def">Macro: </span><span><strong class="def-name">SECONDARY_MEMORY_NEEDED_RTX</strong> <var class="def-var-arguments">(<var class="var">mode</var>)</var><a class="copiable-link" href="#index-SECONDARY_005fMEMORY_005fNEEDED_005fRTX"> &para;</a></span></dt>
<dd><p>Normally when <code class="code">TARGET_SECONDARY_MEMORY_NEEDED</code> is defined, the compiler
allocates a stack slot for a memory location needed for register copies.
If this macro is defined, the compiler instead uses the memory location
defined by this macro.
</p>
<p>Do not define this macro if you do not define
<code class="code">TARGET_SECONDARY_MEMORY_NEEDED</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSECONDARY_005fMEMORY_005fNEEDED_005fMODE"><span class="category-def">Target Hook: </span><span><code class="def-type">machine_mode</code> <strong class="def-name">TARGET_SECONDARY_MEMORY_NEEDED_MODE</strong> <code class="def-code-arguments">(machine_mode <var class="var">mode</var>)</code><a class="copiable-link" href="#index-TARGET_005fSECONDARY_005fMEMORY_005fNEEDED_005fMODE"> &para;</a></span></dt>
<dd><p>If <code class="code">TARGET_SECONDARY_MEMORY_NEEDED</code> tells the compiler to use memory
when moving between two particular registers of mode <var class="var">mode</var>,
this hook specifies the mode that the memory should have.
</p>
<p>The default depends on <code class="code">TARGET_LRA_P</code>.  Without LRA, the default
is to use a word-sized mode for integral modes that are smaller than a
a word.  This is right thing to do on most machines because it ensures
that all bits of the register are copied and prevents accesses to the
registers in a narrower mode, which some machines prohibit for
floating-point registers.
</p>
<p>However, this default behavior is not correct on some machines, such as
the DEC Alpha, that store short integers in floating-point registers
differently than in integer registers.  On those machines, the default
widening will not work correctly and you must define this hook to
suppress that widening in some cases.  See the file <samp class="file">alpha.cc</samp> for
details.
</p>
<p>With LRA, the default is to use <var class="var">mode</var> unmodified.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSELECT_005fEARLY_005fREMAT_005fMODES"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_SELECT_EARLY_REMAT_MODES</strong> <code class="def-code-arguments">(sbitmap <var class="var">modes</var>)</code><a class="copiable-link" href="#index-TARGET_005fSELECT_005fEARLY_005fREMAT_005fMODES"> &para;</a></span></dt>
<dd><p>On some targets, certain modes cannot be held in registers around a
standard ABI call and are relatively expensive to spill to the stack.
The early rematerialization pass can help in such cases by aggressively
recomputing values after calls, so that they don&rsquo;t need to be spilled.
</p>
<p>This hook returns the set of such modes by setting the associated bits
in <var class="var">modes</var>.  The default implementation selects no modes, which has
the effect of disabling the early rematerialization pass.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fCLASS_005fLIKELY_005fSPILLED_005fP"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_CLASS_LIKELY_SPILLED_P</strong> <code class="def-code-arguments">(reg_class_t <var class="var">rclass</var>)</code><a class="copiable-link" href="#index-TARGET_005fCLASS_005fLIKELY_005fSPILLED_005fP"> &para;</a></span></dt>
<dd><p>A target hook which returns <code class="code">true</code> if pseudos that have been assigned
to registers of class <var class="var">rclass</var> would likely be spilled because
registers of <var class="var">rclass</var> are needed for spill registers.
</p>
<p>The default version of this target hook returns <code class="code">true</code> if <var class="var">rclass</var>
has exactly one register and <code class="code">false</code> otherwise.  On most machines, this
default should be used.  For generally register-starved machines, such as
i386, or machines with right register constraints, such as SH, this hook
can be used to avoid excessive spilling.
</p>
<p>This hook is also used by some of the global intra-procedural code
transformations to throtle code motion, to avoid increasing register
pressure.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fCLASS_005fMAX_005fNREGS"><span class="category-def">Target Hook: </span><span><code class="def-type">unsigned char</code> <strong class="def-name">TARGET_CLASS_MAX_NREGS</strong> <code class="def-code-arguments">(reg_class_t <var class="var">rclass</var>, machine_mode <var class="var">mode</var>)</code><a class="copiable-link" href="#index-TARGET_005fCLASS_005fMAX_005fNREGS"> &para;</a></span></dt>
<dd><p>A target hook returns the maximum number of consecutive registers
of class <var class="var">rclass</var> needed to hold a value of mode <var class="var">mode</var>.
</p>
<p>This is closely related to the macro <code class="code">TARGET_HARD_REGNO_NREGS</code>.
In fact, the value returned by <code class="code">TARGET_CLASS_MAX_NREGS (<var class="var">rclass</var>,
<var class="var">mode</var>)</code> target hook should be the maximum value of
<code class="code">TARGET_HARD_REGNO_NREGS (<var class="var">regno</var>, <var class="var">mode</var>)</code> for all <var class="var">regno</var>
values in the class <var class="var">rclass</var>.
</p>
<p>This target hook helps control the handling of multiple-word values
in the reload pass.
</p>
<p>The default version of this target hook returns the size of <var class="var">mode</var>
in words.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-CLASS_005fMAX_005fNREGS"><span class="category-def">Macro: </span><span><strong class="def-name">CLASS_MAX_NREGS</strong> <var class="def-var-arguments">(<var class="var">class</var>, <var class="var">mode</var>)</var><a class="copiable-link" href="#index-CLASS_005fMAX_005fNREGS"> &para;</a></span></dt>
<dd><p>A C expression for the maximum number of consecutive registers
of class <var class="var">class</var> needed to hold a value of mode <var class="var">mode</var>.
</p>
<p>This is closely related to the macro <code class="code">TARGET_HARD_REGNO_NREGS</code>.  In fact,
the value of the macro <code class="code">CLASS_MAX_NREGS (<var class="var">class</var>, <var class="var">mode</var>)</code>
should be the maximum value of <code class="code">TARGET_HARD_REGNO_NREGS (<var class="var">regno</var>,
<var class="var">mode</var>)</code> for all <var class="var">regno</var> values in the class <var class="var">class</var>.
</p>
<p>This macro helps control the handling of multiple-word values
in the reload pass.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fCAN_005fCHANGE_005fMODE_005fCLASS"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_CAN_CHANGE_MODE_CLASS</strong> <code class="def-code-arguments">(machine_mode <var class="var">from</var>, machine_mode <var class="var">to</var>, reg_class_t <var class="var">rclass</var>)</code><a class="copiable-link" href="#index-TARGET_005fCAN_005fCHANGE_005fMODE_005fCLASS"> &para;</a></span></dt>
<dd><p>This hook returns true if it is possible to bitcast values held in
registers of class <var class="var">rclass</var> from mode <var class="var">from</var> to mode <var class="var">to</var>
and if doing so preserves the low-order bits that are common to both modes.
The result is only meaningful if <var class="var">rclass</var> has registers that can hold
both <code class="code">from</code> and <code class="code">to</code>.  The default implementation returns true.
</p>
<p>As an example of when such bitcasting is invalid, loading 32-bit integer or
floating-point objects into floating-point registers on Alpha extends them
to 64 bits.  Therefore loading a 64-bit object and then storing it as a
32-bit object does not store the low-order 32 bits, as would be the case
for a normal register.  Therefore, <samp class="file">alpha.h</samp> defines
<code class="code">TARGET_CAN_CHANGE_MODE_CLASS</code> to return:
</p>
<div class="example smallexample">
<pre class="example-preformatted">(GET_MODE_SIZE (from) == GET_MODE_SIZE (to)
 || !reg_classes_intersect_p (FLOAT_REGS, rclass))
</pre></div>

<p>Even if storing from a register in mode <var class="var">to</var> would be valid,
if both <var class="var">from</var> and <code class="code">raw_reg_mode</code> for <var class="var">rclass</var> are wider
than <code class="code">word_mode</code>, then we must prevent <var class="var">to</var> narrowing the
mode.  This happens when the middle-end assumes that it can load
or store pieces of an <var class="var">N</var>-word pseudo, and that the pseudo will
eventually be allocated to <var class="var">N</var> <code class="code">word_mode</code> hard registers.
Failure to prevent this kind of mode change will result in the
entire <code class="code">raw_reg_mode</code> being modified instead of the partial
value that the middle-end intended.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fIRA_005fCHANGE_005fPSEUDO_005fALLOCNO_005fCLASS"><span class="category-def">Target Hook: </span><span><code class="def-type">reg_class_t</code> <strong class="def-name">TARGET_IRA_CHANGE_PSEUDO_ALLOCNO_CLASS</strong> <code class="def-code-arguments">(int, <var class="var">reg_class_t</var>, <var class="var">reg_class_t</var>)</code><a class="copiable-link" href="#index-TARGET_005fIRA_005fCHANGE_005fPSEUDO_005fALLOCNO_005fCLASS"> &para;</a></span></dt>
<dd><p>A target hook which can change allocno class for given pseudo from
  allocno and best class calculated by IRA.
</p>  
<p>The default version of this target hook always returns given class.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fLRA_005fP"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_LRA_P</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fLRA_005fP"> &para;</a></span></dt>
<dd><p>A target hook which returns true if we use LRA instead of reload pass.
</p>
<p>The default version of this target hook returns true.  New ports
should use LRA, and existing ports are encouraged to convert.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fREGISTER_005fPRIORITY"><span class="category-def">Target Hook: </span><span><code class="def-type">int</code> <strong class="def-name">TARGET_REGISTER_PRIORITY</strong> <code class="def-code-arguments">(int)</code><a class="copiable-link" href="#index-TARGET_005fREGISTER_005fPRIORITY"> &para;</a></span></dt>
<dd><p>A target hook which returns the register priority number to which the
register <var class="var">hard_regno</var> belongs to.  The bigger the number, the
more preferable the hard register usage (when all other conditions are
the same).  This hook can be used to prefer some hard register over
others in LRA.  For example, some x86-64 register usage needs
additional prefix which makes instructions longer.  The hook can
return lower priority number for such registers make them less favorable
and as result making the generated code smaller.
</p>
<p>The default version of this target hook returns always zero.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fREGISTER_005fUSAGE_005fLEVELING_005fP"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_REGISTER_USAGE_LEVELING_P</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fREGISTER_005fUSAGE_005fLEVELING_005fP"> &para;</a></span></dt>
<dd><p>A target hook which returns true if we need register usage leveling.
That means if a few hard registers are equally good for the
assignment, we choose the least used hard register.  The register
usage leveling may be profitable for some targets.  Don&rsquo;t use the
usage leveling for targets with conditional execution or targets
with big register files as it hurts if-conversion and cross-jumping
optimizations.
</p>
<p>The default version of this target hook returns always false.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fDIFFERENT_005fADDR_005fDISPLACEMENT_005fP"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_DIFFERENT_ADDR_DISPLACEMENT_P</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fDIFFERENT_005fADDR_005fDISPLACEMENT_005fP"> &para;</a></span></dt>
<dd><p>A target hook which returns true if an address with the same structure
can have different maximal legitimate displacement.  For example, the
displacement can depend on memory mode or on operand combinations in
the insn.
</p>
<p>The default version of this target hook returns always false.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fCANNOT_005fSUBSTITUTE_005fMEM_005fEQUIV_005fP"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_CANNOT_SUBSTITUTE_MEM_EQUIV_P</strong> <code class="def-code-arguments">(rtx <var class="var">subst</var>)</code><a class="copiable-link" href="#index-TARGET_005fCANNOT_005fSUBSTITUTE_005fMEM_005fEQUIV_005fP"> &para;</a></span></dt>
<dd><p>A target hook which returns <code class="code">true</code> if <var class="var">subst</var> can&rsquo;t
substitute safely pseudos with equivalent memory values during
register allocation.
The default version of this target hook returns <code class="code">false</code>.
On most machines, this default should be used.  For generally
machines with non orthogonal register usage for addressing, such
as SH, this hook can be used to avoid excessive spilling.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fLEGITIMIZE_005fADDRESS_005fDISPLACEMENT"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_LEGITIMIZE_ADDRESS_DISPLACEMENT</strong> <code class="def-code-arguments">(rtx *<var class="var">offset1</var>, rtx *<var class="var">offset2</var>, poly_int64 <var class="var">orig_offset</var>, machine_mode <var class="var">mode</var>)</code><a class="copiable-link" href="#index-TARGET_005fLEGITIMIZE_005fADDRESS_005fDISPLACEMENT"> &para;</a></span></dt>
<dd><p>This hook tries to split address offset <var class="var">orig_offset</var> into
two parts: one that should be added to the base address to create
a local anchor point, and an additional offset that can be applied
to the anchor to address a value of mode <var class="var">mode</var>.  The idea is that
the local anchor could be shared by other accesses to nearby locations.
</p>
<p>The hook returns true if it succeeds, storing the offset of the
anchor from the base in <var class="var">offset1</var> and the offset of the final address
from the anchor in <var class="var">offset2</var>.  The default implementation returns false.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSPILL_005fCLASS"><span class="category-def">Target Hook: </span><span><code class="def-type">reg_class_t</code> <strong class="def-name">TARGET_SPILL_CLASS</strong> <code class="def-code-arguments">(reg_class_t, <var class="var">machine_mode</var>)</code><a class="copiable-link" href="#index-TARGET_005fSPILL_005fCLASS"> &para;</a></span></dt>
<dd><p>This hook defines a class of registers which could be used for spilling
pseudos of the given mode and class, or <code class="code">NO_REGS</code> if only memory
should be used.  Not defining this hook is equivalent to returning
<code class="code">NO_REGS</code> for all inputs.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fADDITIONAL_005fALLOCNO_005fCLASS_005fP"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_ADDITIONAL_ALLOCNO_CLASS_P</strong> <code class="def-code-arguments">(reg_class_t)</code><a class="copiable-link" href="#index-TARGET_005fADDITIONAL_005fALLOCNO_005fCLASS_005fP"> &para;</a></span></dt>
<dd><p>This hook should return <code class="code">true</code> if given class of registers should
be an allocno class in any way.  Usually RA uses only one register
class from all classes containing the same register set.  In some
complicated cases, you need to have two or more such classes as
allocno ones for RA correct work.  Not defining this hook is
equivalent to returning <code class="code">false</code> for all inputs.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fCSTORE_005fMODE"><span class="category-def">Target Hook: </span><span><code class="def-type">scalar_int_mode</code> <strong class="def-name">TARGET_CSTORE_MODE</strong> <code class="def-code-arguments">(enum insn_code <var class="var">icode</var>)</code><a class="copiable-link" href="#index-TARGET_005fCSTORE_005fMODE"> &para;</a></span></dt>
<dd><p>This hook defines the machine mode to use for the boolean result of
conditional store patterns.  The ICODE argument is the instruction code
for the cstore being performed.  Not definiting this hook is the same
as accepting the mode encoded into operand 0 of the cstore expander
patterns.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fCOMPUTE_005fPRESSURE_005fCLASSES"><span class="category-def">Target Hook: </span><span><code class="def-type">int</code> <strong class="def-name">TARGET_COMPUTE_PRESSURE_CLASSES</strong> <code class="def-code-arguments">(enum reg_class *<var class="var">pressure_classes</var>)</code><a class="copiable-link" href="#index-TARGET_005fCOMPUTE_005fPRESSURE_005fCLASSES"> &para;</a></span></dt>
<dd><p>A target hook which lets a backend compute the set of pressure classes to
be used by those optimization passes which take register pressure into
account, as opposed to letting IRA compute them.  It returns the number of
register classes stored in the array <var class="var">pressure_classes</var>.
</p></dd></dl>

</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Stack-and-Calling.html">Stack Layout and Calling Conventions</a>, Previous: <a href="Registers.html">Register Usage</a>, Up: <a href="Target-Macros.html">Target Description Macros and Functions</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Option-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>

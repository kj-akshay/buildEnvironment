<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- Copyright Â© 1988-2025 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Funding Free Software", the Front-Cover
Texts being (a) (see below), and with the Back-Cover Texts being (b)
(see below).  A copy of the license is included in the section entitled
"GNU Free Documentation License".

(a) The FSF's Front-Cover Text is:

A GNU Manual

(b) The FSF's Back-Cover Text is:

You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development. -->
<title>Scheduling (GNU Compiler Collection (GCC) Internals)</title>

<meta name="description" content="Scheduling (GNU Compiler Collection (GCC) Internals)">
<meta name="keywords" content="Scheduling (GNU Compiler Collection (GCC) Internals)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Option-Index.html" rel="index" title="Option Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Target-Macros.html" rel="up" title="Target Macros">
<link href="Sections.html" rel="next" title="Sections">
<link href="Costs.html" rel="prev" title="Costs">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>


</head>

<body lang="en">
<div class="section-level-extent" id="Scheduling">
<div class="nav-panel">
<p>
Next: <a href="Sections.html" accesskey="n" rel="next">Dividing the Output into Sections (Texts, Data, &hellip;)</a>, Previous: <a href="Costs.html" accesskey="p" rel="prev">Describing Relative Costs of Operations</a>, Up: <a href="Target-Macros.html" accesskey="u" rel="up">Target Description Macros and Functions</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Option-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="Adjusting-the-Instruction-Scheduler"><span>17.17 Adjusting the Instruction Scheduler<a class="copiable-link" href="#Adjusting-the-Instruction-Scheduler"> &para;</a></span></h3>

<p>The instruction scheduler may need a fair amount of machine-specific
adjustment in order to produce good code.  GCC provides several target
hooks for this purpose.  It is usually enough to define just a few of
them: try the first ones in this list first.
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fISSUE_005fRATE"><span class="category-def">Target Hook: </span><span><code class="def-type">int</code> <strong class="def-name">TARGET_SCHED_ISSUE_RATE</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fISSUE_005fRATE"> &para;</a></span></dt>
<dd><p>This hook returns the maximum number of instructions that can ever
issue at the same time on the target machine.  The default is one.
Although the insn scheduler can define itself the possibility of issue
an insn on the same cycle, the value can serve as an additional
constraint to issue insns on the same simulated processor cycle (see
hooks &lsquo;<samp class="samp">TARGET_SCHED_REORDER</samp>&rsquo; and &lsquo;<samp class="samp">TARGET_SCHED_REORDER2</samp>&rsquo;).
This value must be constant over the entire compilation.  If you need
it to vary depending on what the instructions are, you must use
&lsquo;<samp class="samp">TARGET_SCHED_VARIABLE_ISSUE</samp>&rsquo;.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fVARIABLE_005fISSUE"><span class="category-def">Target Hook: </span><span><code class="def-type">int</code> <strong class="def-name">TARGET_SCHED_VARIABLE_ISSUE</strong> <code class="def-code-arguments">(FILE *<var class="var">file</var>, int <var class="var">verbose</var>, rtx_insn *<var class="var">insn</var>, int <var class="var">more</var>)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fVARIABLE_005fISSUE"> &para;</a></span></dt>
<dd><p>This hook is executed by the scheduler after it has scheduled an insn
from the ready list.  It should return the number of insns which can
still be issued in the current cycle.  The default is
&lsquo;<samp class="samp"><var class="var">more</var>&nbsp;-&nbsp;1<!-- /@w --></samp>&rsquo; for insns other than <code class="code">CLOBBER</code> and
<code class="code">USE</code>, which normally are not counted against the issue rate.
You should define this hook if some insns take more machine resources
than others, so that fewer insns can follow them in the same cycle.
<var class="var">file</var> is either a null pointer, or a stdio stream to write any
debug output to.  <var class="var">verbose</var> is the verbose level provided by
<samp class="option">-fsched-verbose-<var class="var">n</var></samp>.  <var class="var">insn</var> is the instruction that
was scheduled.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fADJUST_005fCOST"><span class="category-def">Target Hook: </span><span><code class="def-type">int</code> <strong class="def-name">TARGET_SCHED_ADJUST_COST</strong> <code class="def-code-arguments">(rtx_insn *<var class="var">insn</var>, int <var class="var">dep_type1</var>, rtx_insn *<var class="var">dep_insn</var>, int <var class="var">cost</var>, unsigned int <var class="var">dw</var>)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fADJUST_005fCOST"> &para;</a></span></dt>
<dd><p>This function corrects the value of <var class="var">cost</var> based on the
relationship between <var class="var">insn</var> and <var class="var">dep_insn</var> through a
dependence of type dep_type, and strength <var class="var">dw</var>.  It should return the new
value.  The default is to make no adjustment to <var class="var">cost</var>.  This can be
used for example to specify to the scheduler using the traditional pipeline
description that an output- or anti-dependence does not incur the same cost
as a data-dependence.  If the scheduler using the automaton based pipeline
description, the cost of anti-dependence is zero and the cost of
output-dependence is maximum of one and the difference of latency
times of the first and the second insns.  If these values are not
acceptable, you could use the hook to modify them too.  See also
see <a class="pxref" href="Processor-pipeline-description.html">Specifying processor pipeline description</a>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fADJUST_005fPRIORITY"><span class="category-def">Target Hook: </span><span><code class="def-type">int</code> <strong class="def-name">TARGET_SCHED_ADJUST_PRIORITY</strong> <code class="def-code-arguments">(rtx_insn *<var class="var">insn</var>, int <var class="var">priority</var>)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fADJUST_005fPRIORITY"> &para;</a></span></dt>
<dd><p>This hook adjusts the integer scheduling priority <var class="var">priority</var> of
<var class="var">insn</var>.  It should return the new priority.  Increase the priority to
execute <var class="var">insn</var> earlier, reduce the priority to execute <var class="var">insn</var>
later.  Do not define this hook if you do not need to adjust the
scheduling priorities of insns.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fREORDER"><span class="category-def">Target Hook: </span><span><code class="def-type">int</code> <strong class="def-name">TARGET_SCHED_REORDER</strong> <code class="def-code-arguments">(FILE *<var class="var">file</var>, int <var class="var">verbose</var>, rtx_insn **<var class="var">ready</var>, int *<var class="var">n_readyp</var>, int <var class="var">clock</var>)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fREORDER"> &para;</a></span></dt>
<dd><p>This hook is executed by the scheduler after it has scheduled the ready
list, to allow the machine description to reorder it (for example to
combine two small instructions together on &lsquo;<samp class="samp">VLIW</samp>&rsquo; machines).
<var class="var">file</var> is either a null pointer, or a stdio stream to write any
debug output to.  <var class="var">verbose</var> is the verbose level provided by
<samp class="option">-fsched-verbose-<var class="var">n</var></samp>.  <var class="var">ready</var> is a pointer to the ready
list of instructions that are ready to be scheduled.  <var class="var">n_readyp</var> is
a pointer to the number of elements in the ready list.  The scheduler
reads the ready list in reverse order, starting with
<var class="var">ready</var>[<var class="var">*n_readyp</var> &minus; 1] and going to <var class="var">ready</var>[0].  <var class="var">clock</var>
is the timer tick of the scheduler.  You may modify the ready list and
the number of ready insns.  The return value is the number of insns that
can issue this cycle; normally this is just <code class="code">issue_rate</code>.  See also
&lsquo;<samp class="samp">TARGET_SCHED_REORDER2</samp>&rsquo;.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fREORDER2"><span class="category-def">Target Hook: </span><span><code class="def-type">int</code> <strong class="def-name">TARGET_SCHED_REORDER2</strong> <code class="def-code-arguments">(FILE *<var class="var">file</var>, int <var class="var">verbose</var>, rtx_insn **<var class="var">ready</var>, int *<var class="var">n_readyp</var>, int <var class="var">clock</var>)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fREORDER2"> &para;</a></span></dt>
<dd><p>Like &lsquo;<samp class="samp">TARGET_SCHED_REORDER</samp>&rsquo;, but called at a different time.  That
function is called whenever the scheduler starts a new cycle.  This one
is called once per iteration over a cycle, immediately after
&lsquo;<samp class="samp">TARGET_SCHED_VARIABLE_ISSUE</samp>&rsquo;; it can reorder the ready list and
return the number of insns to be scheduled in the same cycle.  Defining
this hook can be useful if there are frequent situations where
scheduling one insn causes other insns to become ready in the same
cycle.  These other insns can then be taken into account properly.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fMACRO_005fFUSION_005fP"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_SCHED_MACRO_FUSION_P</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fMACRO_005fFUSION_005fP"> &para;</a></span></dt>
<dd><p>This hook is used to check whether target platform supports macro fusion.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fMACRO_005fFUSION_005fPAIR_005fP"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_SCHED_MACRO_FUSION_PAIR_P</strong> <code class="def-code-arguments">(rtx_insn *<var class="var">prev</var>, rtx_insn *<var class="var">curr</var>)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fMACRO_005fFUSION_005fPAIR_005fP"> &para;</a></span></dt>
<dd><p>This hook is used to check whether two insns should be macro fused for
a target microarchitecture. If this hook returns true for the given insn pair
(<var class="var">prev</var> and <var class="var">curr</var>), the scheduler will put them into a sched
group, and they will not be scheduled apart.  The two insns will be either
two SET insns or a compare and a conditional jump and this hook should
validate any dependencies needed to fuse the two insns together.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fDEPENDENCIES_005fEVALUATION_005fHOOK"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK</strong> <code class="def-code-arguments">(rtx_insn *<var class="var">head</var>, rtx_insn *<var class="var">tail</var>)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fDEPENDENCIES_005fEVALUATION_005fHOOK"> &para;</a></span></dt>
<dd><p>This hook is called after evaluation forward dependencies of insns in
chain given by two parameter values (<var class="var">head</var> and <var class="var">tail</var>
correspondingly) but before insns scheduling of the insn chain.  For
example, it can be used for better insn classification if it requires
analysis of dependencies.  This hook can use backward and forward
dependencies of the insn scheduler because they are already
calculated.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fINIT"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_SCHED_INIT</strong> <code class="def-code-arguments">(FILE *<var class="var">file</var>, int <var class="var">verbose</var>, int <var class="var">max_ready</var>)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fINIT"> &para;</a></span></dt>
<dd><p>This hook is executed by the scheduler at the beginning of each block of
instructions that are to be scheduled.  <var class="var">file</var> is either a null
pointer, or a stdio stream to write any debug output to.  <var class="var">verbose</var>
is the verbose level provided by <samp class="option">-fsched-verbose-<var class="var">n</var></samp>.
<var class="var">max_ready</var> is the maximum number of insns in the current scheduling
region that can be live at the same time.  This can be used to allocate
scratch space if it is needed, e.g. by &lsquo;<samp class="samp">TARGET_SCHED_REORDER</samp>&rsquo;.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fFINISH"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_SCHED_FINISH</strong> <code class="def-code-arguments">(FILE *<var class="var">file</var>, int <var class="var">verbose</var>)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fFINISH"> &para;</a></span></dt>
<dd><p>This hook is executed by the scheduler at the end of each block of
instructions that are to be scheduled.  It can be used to perform
cleanup of any actions done by the other scheduling hooks.  <var class="var">file</var>
is either a null pointer, or a stdio stream to write any debug output
to.  <var class="var">verbose</var> is the verbose level provided by
<samp class="option">-fsched-verbose-<var class="var">n</var></samp>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fINIT_005fGLOBAL"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_SCHED_INIT_GLOBAL</strong> <code class="def-code-arguments">(FILE *<var class="var">file</var>, int <var class="var">verbose</var>, int <var class="var">old_max_uid</var>)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fINIT_005fGLOBAL"> &para;</a></span></dt>
<dd><p>This hook is executed by the scheduler after function level initializations.
<var class="var">file</var> is either a null pointer, or a stdio stream to write any debug output to.
<var class="var">verbose</var> is the verbose level provided by <samp class="option">-fsched-verbose-<var class="var">n</var></samp>.
<var class="var">old_max_uid</var> is the maximum insn uid when scheduling begins.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fFINISH_005fGLOBAL"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_SCHED_FINISH_GLOBAL</strong> <code class="def-code-arguments">(FILE *<var class="var">file</var>, int <var class="var">verbose</var>)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fFINISH_005fGLOBAL"> &para;</a></span></dt>
<dd><p>This is the cleanup hook corresponding to <code class="code">TARGET_SCHED_INIT_GLOBAL</code>.
<var class="var">file</var> is either a null pointer, or a stdio stream to write any debug output to.
<var class="var">verbose</var> is the verbose level provided by <samp class="option">-fsched-verbose-<var class="var">n</var></samp>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fDFA_005fPRE_005fCYCLE_005fINSN"><span class="category-def">Target Hook: </span><span><code class="def-type">rtx</code> <strong class="def-name">TARGET_SCHED_DFA_PRE_CYCLE_INSN</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fDFA_005fPRE_005fCYCLE_005fINSN"> &para;</a></span></dt>
<dd><p>The hook returns an RTL insn.  The automaton state used in the
pipeline hazard recognizer is changed as if the insn were scheduled
when the new simulated processor cycle starts.  Usage of the hook may
simplify the automaton pipeline description for some <abbr class="acronym">VLIW</abbr>
processors.  If the hook is defined, it is used only for the automaton
based pipeline description.  The default is not to change the state
when the new simulated processor cycle starts.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fINIT_005fDFA_005fPRE_005fCYCLE_005fINSN"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fINIT_005fDFA_005fPRE_005fCYCLE_005fINSN"> &para;</a></span></dt>
<dd><p>The hook can be used to initialize data used by the previous hook.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fDFA_005fPOST_005fCYCLE_005fINSN"><span class="category-def">Target Hook: </span><span><code class="def-type">rtx_insn *</code> <strong class="def-name">TARGET_SCHED_DFA_POST_CYCLE_INSN</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fDFA_005fPOST_005fCYCLE_005fINSN"> &para;</a></span></dt>
<dd><p>The hook is analogous to &lsquo;<samp class="samp">TARGET_SCHED_DFA_PRE_CYCLE_INSN</samp>&rsquo; but used
to changed the state as if the insn were scheduled when the new
simulated processor cycle finishes.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fINIT_005fDFA_005fPOST_005fCYCLE_005fINSN"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_SCHED_INIT_DFA_POST_CYCLE_INSN</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fINIT_005fDFA_005fPOST_005fCYCLE_005fINSN"> &para;</a></span></dt>
<dd><p>The hook is analogous to &lsquo;<samp class="samp">TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN</samp>&rsquo; but
used to initialize data used by the previous hook.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fDFA_005fPRE_005fADVANCE_005fCYCLE"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_SCHED_DFA_PRE_ADVANCE_CYCLE</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fDFA_005fPRE_005fADVANCE_005fCYCLE"> &para;</a></span></dt>
<dd><p>The hook to notify target that the current simulated cycle is about to finish.
The hook is analogous to &lsquo;<samp class="samp">TARGET_SCHED_DFA_PRE_CYCLE_INSN</samp>&rsquo; but used
to change the state in more complicated situations - e.g., when advancing
state on a single insn is not enough.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fDFA_005fPOST_005fADVANCE_005fCYCLE"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_SCHED_DFA_POST_ADVANCE_CYCLE</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fDFA_005fPOST_005fADVANCE_005fCYCLE"> &para;</a></span></dt>
<dd><p>The hook to notify target that new simulated cycle has just started.
The hook is analogous to &lsquo;<samp class="samp">TARGET_SCHED_DFA_POST_CYCLE_INSN</samp>&rsquo; but used
to change the state in more complicated situations - e.g., when advancing
state on a single insn is not enough.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fFIRST_005fCYCLE_005fMULTIPASS_005fDFA_005fLOOKAHEAD"><span class="category-def">Target Hook: </span><span><code class="def-type">int</code> <strong class="def-name">TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fFIRST_005fCYCLE_005fMULTIPASS_005fDFA_005fLOOKAHEAD"> &para;</a></span></dt>
<dd><p>This hook controls better choosing an insn from the ready insn queue
for the <abbr class="acronym">DFA</abbr>-based insn scheduler.  Usually the scheduler
chooses the first insn from the queue.  If the hook returns a positive
value, an additional scheduler code tries all permutations of
&lsquo;<samp class="samp">TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD ()</samp>&rsquo;
subsequent ready insns to choose an insn whose issue will result in
maximal number of issued insns on the same cycle.  For the
<abbr class="acronym">VLIW</abbr> processor, the code could actually solve the problem of
packing simple insns into the <abbr class="acronym">VLIW</abbr> insn.  Of course, if the
rules of <abbr class="acronym">VLIW</abbr> packing are described in the automaton.
</p>
<p>This code also could be used for superscalar <abbr class="acronym">RISC</abbr>
processors.  Let us consider a superscalar <abbr class="acronym">RISC</abbr> processor
with 3 pipelines.  Some insns can be executed in pipelines <var class="var">A</var> or
<var class="var">B</var>, some insns can be executed only in pipelines <var class="var">B</var> or
<var class="var">C</var>, and one insn can be executed in pipeline <var class="var">B</var>.  The
processor may issue the 1st insn into <var class="var">A</var> and the 2nd one into
<var class="var">B</var>.  In this case, the 3rd insn will wait for freeing <var class="var">B</var>
until the next cycle.  If the scheduler issues the 3rd insn the first,
the processor could issue all 3 insns per cycle.
</p>
<p>Actually this code demonstrates advantages of the automaton based
pipeline hazard recognizer.  We try quickly and easy many insn
schedules to choose the best one.
</p>
<p>The default is no multipass scheduling.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fFIRST_005fCYCLE_005fMULTIPASS_005fDFA_005fLOOKAHEAD_005fGUARD"><span class="category-def">Target Hook: </span><span><code class="def-type">int</code> <strong class="def-name">TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD</strong> <code class="def-code-arguments">(rtx_insn *<var class="var">insn</var>, int <var class="var">ready_index</var>)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fFIRST_005fCYCLE_005fMULTIPASS_005fDFA_005fLOOKAHEAD_005fGUARD"> &para;</a></span></dt>
<dd>
<p>This hook controls what insns from the ready insn queue will be
considered for the multipass insn scheduling.  If the hook returns
zero for <var class="var">insn</var>, the insn will be considered in multipass scheduling.
Positive return values will remove <var class="var">insn</var> from consideration on
the current round of multipass scheduling.
Negative return values will remove <var class="var">insn</var> from consideration for given
number of cycles.
Backends should be careful about returning non-zero for highest priority
instruction at position 0 in the ready list.  <var class="var">ready_index</var> is passed
to allow backends make correct judgements.
</p>
<p>The default is that any ready insns can be chosen to be issued.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fFIRST_005fCYCLE_005fMULTIPASS_005fBEGIN"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_SCHED_FIRST_CYCLE_MULTIPASS_BEGIN</strong> <code class="def-code-arguments">(void *<var class="var">data</var>, signed char *<var class="var">ready_try</var>, int <var class="var">n_ready</var>, bool <var class="var">first_cycle_insn_p</var>)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fFIRST_005fCYCLE_005fMULTIPASS_005fBEGIN"> &para;</a></span></dt>
<dd><p>This hook prepares the target backend for a new round of multipass
scheduling.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fFIRST_005fCYCLE_005fMULTIPASS_005fISSUE"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_SCHED_FIRST_CYCLE_MULTIPASS_ISSUE</strong> <code class="def-code-arguments">(void *<var class="var">data</var>, signed char *<var class="var">ready_try</var>, int <var class="var">n_ready</var>, rtx_insn *<var class="var">insn</var>, const void *<var class="var">prev_data</var>)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fFIRST_005fCYCLE_005fMULTIPASS_005fISSUE"> &para;</a></span></dt>
<dd><p>This hook is called when multipass scheduling evaluates instruction INSN.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fFIRST_005fCYCLE_005fMULTIPASS_005fBACKTRACK"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_SCHED_FIRST_CYCLE_MULTIPASS_BACKTRACK</strong> <code class="def-code-arguments">(const void *<var class="var">data</var>, signed char *<var class="var">ready_try</var>, int <var class="var">n_ready</var>)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fFIRST_005fCYCLE_005fMULTIPASS_005fBACKTRACK"> &para;</a></span></dt>
<dd><p>This is called when multipass scheduling backtracks from evaluation of
an instruction.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fFIRST_005fCYCLE_005fMULTIPASS_005fEND"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_SCHED_FIRST_CYCLE_MULTIPASS_END</strong> <code class="def-code-arguments">(const void *<var class="var">data</var>)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fFIRST_005fCYCLE_005fMULTIPASS_005fEND"> &para;</a></span></dt>
<dd><p>This hook notifies the target about the result of the concluded current
round of multipass scheduling.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fFIRST_005fCYCLE_005fMULTIPASS_005fINIT"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_SCHED_FIRST_CYCLE_MULTIPASS_INIT</strong> <code class="def-code-arguments">(void *<var class="var">data</var>)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fFIRST_005fCYCLE_005fMULTIPASS_005fINIT"> &para;</a></span></dt>
<dd><p>This hook initializes target-specific data used in multipass scheduling.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fFIRST_005fCYCLE_005fMULTIPASS_005fFINI"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_SCHED_FIRST_CYCLE_MULTIPASS_FINI</strong> <code class="def-code-arguments">(void *<var class="var">data</var>)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fFIRST_005fCYCLE_005fMULTIPASS_005fFINI"> &para;</a></span></dt>
<dd><p>This hook finalizes target-specific data used in multipass scheduling.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fDFA_005fNEW_005fCYCLE"><span class="category-def">Target Hook: </span><span><code class="def-type">int</code> <strong class="def-name">TARGET_SCHED_DFA_NEW_CYCLE</strong> <code class="def-code-arguments">(FILE *<var class="var">dump</var>, int <var class="var">verbose</var>, rtx_insn *<var class="var">insn</var>, int <var class="var">last_clock</var>, int <var class="var">clock</var>, int *<var class="var">sort_p</var>)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fDFA_005fNEW_005fCYCLE"> &para;</a></span></dt>
<dd><p>This hook is called by the insn scheduler before issuing <var class="var">insn</var>
on cycle <var class="var">clock</var>.  If the hook returns nonzero,
<var class="var">insn</var> is not issued on this processor cycle.  Instead,
the processor cycle is advanced.  If *<var class="var">sort_p</var>
is zero, the insn ready queue is not sorted on the new cycle
start as usually.  <var class="var">dump</var> and <var class="var">verbose</var> specify the file and
verbosity level to use for debugging output.
<var class="var">last_clock</var> and <var class="var">clock</var> are, respectively, the
processor cycle on which the previous insn has been issued,
and the current processor cycle.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fIS_005fCOSTLY_005fDEPENDENCE"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_SCHED_IS_COSTLY_DEPENDENCE</strong> <code class="def-code-arguments">(struct _dep *<var class="var">_dep</var>, int <var class="var">cost</var>, int <var class="var">distance</var>)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fIS_005fCOSTLY_005fDEPENDENCE"> &para;</a></span></dt>
<dd><p>This hook is used to define which dependences are considered costly by
the target, so costly that it is not advisable to schedule the insns that
are involved in the dependence too close to one another.  The parameters
to this hook are as follows:  The first parameter <var class="var">_dep</var> is the dependence
being evaluated.  The second parameter <var class="var">cost</var> is the cost of the
dependence as estimated by the scheduler, and the third
parameter <var class="var">distance</var> is the distance in cycles between the two insns.
The hook returns <code class="code">true</code> if considering the distance between the two
insns the dependence between them is considered costly by the target,
and <code class="code">false</code> otherwise.
</p>
<p>Defining this hook can be useful in multiple-issue out-of-order machines,
where (a) it&rsquo;s practically hopeless to predict the actual data/resource
delays, however: (b) there&rsquo;s a better chance to predict the actual grouping
that will be formed, and (c) correctly emulating the grouping can be very
important.  In such targets one may want to allow issuing dependent insns
closer to one another&mdash;i.e., closer than the dependence distance;  however,
not in cases of &ldquo;costly dependences&rdquo;, which this hooks allows to define.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fH_005fI_005fD_005fEXTENDED"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_SCHED_H_I_D_EXTENDED</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fH_005fI_005fD_005fEXTENDED"> &para;</a></span></dt>
<dd><p>This hook is called by the insn scheduler after emitting a new instruction to
the instruction stream.  The hook notifies a target backend to extend its
per instruction data structures.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fALLOC_005fSCHED_005fCONTEXT"><span class="category-def">Target Hook: </span><span><code class="def-type">void *</code> <strong class="def-name">TARGET_SCHED_ALLOC_SCHED_CONTEXT</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fALLOC_005fSCHED_005fCONTEXT"> &para;</a></span></dt>
<dd><p>Return a pointer to a store large enough to hold target scheduling context.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fINIT_005fSCHED_005fCONTEXT"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_SCHED_INIT_SCHED_CONTEXT</strong> <code class="def-code-arguments">(void *<var class="var">tc</var>, bool <var class="var">clean_p</var>)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fINIT_005fSCHED_005fCONTEXT"> &para;</a></span></dt>
<dd><p>Initialize store pointed to by <var class="var">tc</var> to hold target scheduling context.
It <var class="var">clean_p</var> is true then initialize <var class="var">tc</var> as if scheduler is at the
beginning of the block.  Otherwise, copy the current context into <var class="var">tc</var>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fSET_005fSCHED_005fCONTEXT"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_SCHED_SET_SCHED_CONTEXT</strong> <code class="def-code-arguments">(void *<var class="var">tc</var>)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fSET_005fSCHED_005fCONTEXT"> &para;</a></span></dt>
<dd><p>Copy target scheduling context pointed to by <var class="var">tc</var> to the current context.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fCLEAR_005fSCHED_005fCONTEXT"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_SCHED_CLEAR_SCHED_CONTEXT</strong> <code class="def-code-arguments">(void *<var class="var">tc</var>)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fCLEAR_005fSCHED_005fCONTEXT"> &para;</a></span></dt>
<dd><p>Deallocate internal data in target scheduling context pointed to by <var class="var">tc</var>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fFREE_005fSCHED_005fCONTEXT"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_SCHED_FREE_SCHED_CONTEXT</strong> <code class="def-code-arguments">(void *<var class="var">tc</var>)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fFREE_005fSCHED_005fCONTEXT"> &para;</a></span></dt>
<dd><p>Deallocate a store for target scheduling context pointed to by <var class="var">tc</var>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fSPECULATE_005fINSN"><span class="category-def">Target Hook: </span><span><code class="def-type">int</code> <strong class="def-name">TARGET_SCHED_SPECULATE_INSN</strong> <code class="def-code-arguments">(rtx_insn *<var class="var">insn</var>, unsigned int <var class="var">dep_status</var>, rtx *<var class="var">new_pat</var>)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fSPECULATE_005fINSN"> &para;</a></span></dt>
<dd><p>This hook is called by the insn scheduler when <var class="var">insn</var> has only
speculative dependencies and therefore can be scheduled speculatively.
The hook is used to check if the pattern of <var class="var">insn</var> has a speculative
version and, in case of successful check, to generate that speculative
pattern.  The hook should return 1, if the instruction has a speculative form,
or &minus;1, if it doesn&rsquo;t.  <var class="var">request</var> describes the type of requested
speculation.  If the return value equals 1 then <var class="var">new_pat</var> is assigned
the generated speculative pattern.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fNEEDS_005fBLOCK_005fP"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_SCHED_NEEDS_BLOCK_P</strong> <code class="def-code-arguments">(unsigned int <var class="var">dep_status</var>)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fNEEDS_005fBLOCK_005fP"> &para;</a></span></dt>
<dd><p>This hook is called by the insn scheduler during generation of recovery code
for <var class="var">insn</var>.  It should return <code class="code">true</code>, if the corresponding check
instruction should branch to recovery code, or <code class="code">false</code> otherwise.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fGEN_005fSPEC_005fCHECK"><span class="category-def">Target Hook: </span><span><code class="def-type">rtx</code> <strong class="def-name">TARGET_SCHED_GEN_SPEC_CHECK</strong> <code class="def-code-arguments">(rtx_insn *<var class="var">insn</var>, rtx_insn *<var class="var">label</var>, unsigned int <var class="var">ds</var>)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fGEN_005fSPEC_005fCHECK"> &para;</a></span></dt>
<dd><p>This hook is called by the insn scheduler to generate a pattern for recovery
check instruction.  If <var class="var">mutate_p</var> is zero, then <var class="var">insn</var> is a
speculative instruction for which the check should be generated.
<var class="var">label</var> is either a label of a basic block, where recovery code should
be emitted, or a null pointer, when requested check doesn&rsquo;t branch to
recovery code (a simple check).  If <var class="var">mutate_p</var> is nonzero, then
a pattern for a branchy check corresponding to a simple check denoted by
<var class="var">insn</var> should be generated.  In this case <var class="var">label</var> can&rsquo;t be null.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fSET_005fSCHED_005fFLAGS"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_SCHED_SET_SCHED_FLAGS</strong> <code class="def-code-arguments">(struct spec_info_def *<var class="var">spec_info</var>)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fSET_005fSCHED_005fFLAGS"> &para;</a></span></dt>
<dd><p>This hook is used by the insn scheduler to find out what features should be
enabled/used.
The structure *<var class="var">spec_info</var> should be filled in by the target.
The structure describes speculation types that can be used in the scheduler.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fCAN_005fSPECULATE_005fINSN"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_SCHED_CAN_SPECULATE_INSN</strong> <code class="def-code-arguments">(rtx_insn *<var class="var">insn</var>)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fCAN_005fSPECULATE_005fINSN"> &para;</a></span></dt>
<dd><p>Some instructions should never be speculated by the schedulers, usually
 because the instruction is too expensive to get this wrong.  Often such
 instructions have long latency, and often they are not fully modeled in the
 pipeline descriptions.  This hook should return <code class="code">false</code> if <var class="var">insn</var>
 should not be speculated.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fSMS_005fRES_005fMII"><span class="category-def">Target Hook: </span><span><code class="def-type">int</code> <strong class="def-name">TARGET_SCHED_SMS_RES_MII</strong> <code class="def-code-arguments">(struct ddg *<var class="var">g</var>)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fSMS_005fRES_005fMII"> &para;</a></span></dt>
<dd><p>This hook is called by the swing modulo scheduler to calculate a
resource-based lower bound which is based on the resources available in
the machine and the resources required by each instruction.  The target
backend can use <var class="var">g</var> to calculate such bound.  A very simple lower
bound will be used in case this hook is not implemented: the total number
of instructions divided by the issue rate.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fDISPATCH"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_SCHED_DISPATCH</strong> <code class="def-code-arguments">(rtx_insn *<var class="var">insn</var>, int <var class="var">x</var>)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fDISPATCH"> &para;</a></span></dt>
<dd><p>This hook is called by Haifa Scheduler.  It returns true if dispatch scheduling
is supported in hardware and the condition specified in the parameter is true.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fDISPATCH_005fDO"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_SCHED_DISPATCH_DO</strong> <code class="def-code-arguments">(rtx_insn *<var class="var">insn</var>, int <var class="var">x</var>)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fDISPATCH_005fDO"> &para;</a></span></dt>
<dd><p>This hook is called by Haifa Scheduler.  It performs the operation specified
in its second parameter.
</p></dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-TARGET_005fSCHED_005fEXPOSED_005fPIPELINE"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_SCHED_EXPOSED_PIPELINE</strong><a class="copiable-link" href="#index-TARGET_005fSCHED_005fEXPOSED_005fPIPELINE"> &para;</a></span></dt>
<dd><p>True if the processor has an exposed pipeline, which means that not just
the order of instructions is important for correctness when scheduling, but
also the latencies of operations.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fREASSOCIATION_005fWIDTH"><span class="category-def">Target Hook: </span><span><code class="def-type">int</code> <strong class="def-name">TARGET_SCHED_REASSOCIATION_WIDTH</strong> <code class="def-code-arguments">(unsigned int <var class="var">opc</var>, machine_mode <var class="var">mode</var>)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fREASSOCIATION_005fWIDTH"> &para;</a></span></dt>
<dd><p>This hook is called by tree reassociator to determine a level of
parallelism required in output calculations chain.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSCHED_005fFUSION_005fPRIORITY"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_SCHED_FUSION_PRIORITY</strong> <code class="def-code-arguments">(rtx_insn *<var class="var">insn</var>, int <var class="var">max_pri</var>, int *<var class="var">fusion_pri</var>, int *<var class="var">pri</var>)</code><a class="copiable-link" href="#index-TARGET_005fSCHED_005fFUSION_005fPRIORITY"> &para;</a></span></dt>
<dd><p>This hook is called by scheduling fusion pass.  It calculates fusion
priorities for each instruction passed in by parameter.  The priorities
are returned via pointer parameters.
</p>
<p><var class="var">insn</var> is the instruction whose priorities need to be calculated.
<var class="var">max_pri</var> is the maximum priority can be returned in any cases.
<var class="var">fusion_pri</var> is the pointer parameter through which <var class="var">insn</var>&rsquo;s
fusion priority should be calculated and returned.
<var class="var">pri</var> is the pointer parameter through which <var class="var">insn</var>&rsquo;s priority
should be calculated and returned.
</p>
<p>Same <var class="var">fusion_pri</var> should be returned for instructions which should
be scheduled together.  Different <var class="var">pri</var> should be returned for
instructions with same <var class="var">fusion_pri</var>.  <var class="var">fusion_pri</var> is the major
sort key, <var class="var">pri</var> is the minor sort key.  All instructions will be
scheduled according to the two priorities.  All priorities calculated
should be between 0 (exclusive) and <var class="var">max_pri</var> (inclusive).  To avoid
false dependencies, <var class="var">fusion_pri</var> of instructions which need to be
scheduled together should be smaller than <var class="var">fusion_pri</var> of irrelevant
instructions.
</p>
<p>Given below example:
</p>
<div class="example smallexample">
<pre class="example-preformatted">    ldr r10, [r1, 4]
    add r4, r4, r10
    ldr r15, [r2, 8]
    sub r5, r5, r15
    ldr r11, [r1, 0]
    add r4, r4, r11
    ldr r16, [r2, 12]
    sub r5, r5, r16
</pre></div>

<p>On targets like ARM/AArch64, the two pairs of consecutive loads should be
merged.  Since peephole2 pass can&rsquo;t help in this case unless consecutive
loads are actually next to each other in instruction flow.  That&rsquo;s where
this scheduling fusion pass works.  This hook calculates priority for each
instruction based on its fustion type, like:
</p>
<div class="example smallexample">
<pre class="example-preformatted">    ldr r10, [r1, 4]  ; fusion_pri=99,  pri=96
    add r4, r4, r10   ; fusion_pri=100, pri=100
    ldr r15, [r2, 8]  ; fusion_pri=98,  pri=92
    sub r5, r5, r15   ; fusion_pri=100, pri=100
    ldr r11, [r1, 0]  ; fusion_pri=99,  pri=100
    add r4, r4, r11   ; fusion_pri=100, pri=100
    ldr r16, [r2, 12] ; fusion_pri=98,  pri=88
    sub r5, r5, r16   ; fusion_pri=100, pri=100
</pre></div>

<p>Scheduling fusion pass then sorts all ready to issue instructions according
to the priorities.  As a result, instructions of same fusion type will be
pushed together in instruction flow, like:
</p>
<div class="example smallexample">
<pre class="example-preformatted">    ldr r11, [r1, 0]
    ldr r10, [r1, 4]
    ldr r15, [r2, 8]
    ldr r16, [r2, 12]
    add r4, r4, r10
    sub r5, r5, r15
    add r4, r4, r11
    sub r5, r5, r16
</pre></div>

<p>Now peephole2 pass can simply merge the two pairs of loads.
</p>
<p>Since scheduling fusion pass relies on peephole2 to do real fusion
work, it is only enabled by default when peephole2 is in effect.
</p>
<p>This is firstly introduced on ARM/AArch64 targets, please refer to
the hook implementation for how different fusion types are supported.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fEXPAND_005fDIVMOD_005fLIBFUNC"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_EXPAND_DIVMOD_LIBFUNC</strong> <code class="def-code-arguments">(rtx <var class="var">libfunc</var>, machine_mode <var class="var">mode</var>, rtx <var class="var">op0</var>, rtx <var class="var">op1</var>, rtx *<var class="var">quot</var>, rtx *<var class="var">rem</var>)</code><a class="copiable-link" href="#index-TARGET_005fEXPAND_005fDIVMOD_005fLIBFUNC"> &para;</a></span></dt>
<dd><p>Define this hook for enabling divmod transform if the port does not have
hardware divmod insn but defines target-specific divmod libfuncs.
</p></dd></dl>

</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Sections.html">Dividing the Output into Sections (Texts, Data, &hellip;)</a>, Previous: <a href="Costs.html">Describing Relative Costs of Operations</a>, Up: <a href="Target-Macros.html">Target Description Macros and Functions</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Option-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>

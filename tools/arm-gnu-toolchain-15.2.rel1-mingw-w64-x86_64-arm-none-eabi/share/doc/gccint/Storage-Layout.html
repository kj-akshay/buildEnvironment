<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- Copyright Â© 1988-2025 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Funding Free Software", the Front-Cover
Texts being (a) (see below), and with the Back-Cover Texts being (b)
(see below).  A copy of the license is included in the section entitled
"GNU Free Documentation License".

(a) The FSF's Front-Cover Text is:

A GNU Manual

(b) The FSF's Back-Cover Text is:

You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development. -->
<title>Storage Layout (GNU Compiler Collection (GCC) Internals)</title>

<meta name="description" content="Storage Layout (GNU Compiler Collection (GCC) Internals)">
<meta name="keywords" content="Storage Layout (GNU Compiler Collection (GCC) Internals)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Option-Index.html" rel="index" title="Option Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Target-Macros.html" rel="up" title="Target Macros">
<link href="Type-Layout.html" rel="next" title="Type Layout">
<link href="Per_002dFunction-Data.html" rel="prev" title="Per-Function Data">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span.r {font-family: initial; font-weight: normal; font-style: normal}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>


</head>

<body lang="en">
<div class="section-level-extent" id="Storage-Layout">
<div class="nav-panel">
<p>
Next: <a href="Type-Layout.html" accesskey="n" rel="next">Layout of Source Language Data Types</a>, Previous: <a href="Per_002dFunction-Data.html" accesskey="p" rel="prev">Defining data structures for per-function information.</a>, Up: <a href="Target-Macros.html" accesskey="u" rel="up">Target Description Macros and Functions</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Option-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="Storage-Layout-1"><span>17.5 Storage Layout<a class="copiable-link" href="#Storage-Layout-1"> &para;</a></span></h3>
<a class="index-entry-id" id="index-storage-layout"></a>

<p>Note that the definitions of the macros in this table which are sizes or
alignments measured in bits do not need to be constant.  They can be C
expressions that refer to static variables, such as the <code class="code">target_flags</code>.
See <a class="xref" href="Run_002dtime-Target.html">Run-time Target Specification</a>.
</p>
<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-BITS_005fBIG_005fENDIAN"><span class="category-def">Macro: </span><span><strong class="def-name">BITS_BIG_ENDIAN</strong><a class="copiable-link" href="#index-BITS_005fBIG_005fENDIAN"> &para;</a></span></dt>
<dd><p>Define this macro to have the value 1 if the most significant bit in a
byte has the lowest number; otherwise define it to have the value zero.
This means that bit-field instructions count from the most significant
bit.  If the machine has no bit-field instructions, then this must still
be defined, but it doesn&rsquo;t matter which value it is defined to.  This
macro need not be a constant.
</p>
<p>This macro does not affect the way structure fields are packed into
bytes or words; that is controlled by <code class="code">BYTES_BIG_ENDIAN</code>.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-BYTES_005fBIG_005fENDIAN"><span class="category-def">Macro: </span><span><strong class="def-name">BYTES_BIG_ENDIAN</strong><a class="copiable-link" href="#index-BYTES_005fBIG_005fENDIAN"> &para;</a></span></dt>
<dd><p>Define this macro to have the value 1 if the most significant byte in a
word has the lowest number.  This macro need not be a constant.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-WORDS_005fBIG_005fENDIAN"><span class="category-def">Macro: </span><span><strong class="def-name">WORDS_BIG_ENDIAN</strong><a class="copiable-link" href="#index-WORDS_005fBIG_005fENDIAN"> &para;</a></span></dt>
<dd><p>Define this macro to have the value 1 if, in a multiword object, the
most significant word has the lowest number.  This applies to both
memory locations and registers; see <code class="code">REG_WORDS_BIG_ENDIAN</code> if the
order of words in memory is not the same as the order in registers.  This
macro need not be a constant.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-REG_005fWORDS_005fBIG_005fENDIAN"><span class="category-def">Macro: </span><span><strong class="def-name">REG_WORDS_BIG_ENDIAN</strong><a class="copiable-link" href="#index-REG_005fWORDS_005fBIG_005fENDIAN"> &para;</a></span></dt>
<dd><p>On some machines, the order of words in a multiword object differs between
registers in memory.  In such a situation, define this macro to describe
the order of words in a register.  The macro <code class="code">WORDS_BIG_ENDIAN</code> controls
the order of words in memory.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-FLOAT_005fWORDS_005fBIG_005fENDIAN"><span class="category-def">Macro: </span><span><strong class="def-name">FLOAT_WORDS_BIG_ENDIAN</strong><a class="copiable-link" href="#index-FLOAT_005fWORDS_005fBIG_005fENDIAN"> &para;</a></span></dt>
<dd><p>Define this macro to have the value 1 if <code class="code">DFmode</code>, <code class="code">XFmode</code> or
<code class="code">TFmode</code> floating point numbers are stored in memory with the word
containing the sign bit at the lowest address; otherwise define it to
have the value 0.  This macro need not be a constant.
</p>
<p>You need not define this macro if the ordering is the same as for
multi-word integers.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-BITS_005fPER_005fWORD"><span class="category-def">Macro: </span><span><strong class="def-name">BITS_PER_WORD</strong><a class="copiable-link" href="#index-BITS_005fPER_005fWORD"> &para;</a></span></dt>
<dd><p>Number of bits in a word.  If you do not define this macro, the default
is <code class="code">BITS_PER_UNIT * UNITS_PER_WORD</code>.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-MAX_005fBITS_005fPER_005fWORD"><span class="category-def">Macro: </span><span><strong class="def-name">MAX_BITS_PER_WORD</strong><a class="copiable-link" href="#index-MAX_005fBITS_005fPER_005fWORD"> &para;</a></span></dt>
<dd><p>Maximum number of bits in a word.  If this is undefined, the default is
<code class="code">BITS_PER_WORD</code>.  Otherwise, it is the constant value that is the
largest value that <code class="code">BITS_PER_WORD</code> can have at run-time.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-UNITS_005fPER_005fWORD"><span class="category-def">Macro: </span><span><strong class="def-name">UNITS_PER_WORD</strong><a class="copiable-link" href="#index-UNITS_005fPER_005fWORD"> &para;</a></span></dt>
<dd><p>Number of storage units in a word; normally the size of a general-purpose
register, a power of two from 1 or 8.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-MIN_005fUNITS_005fPER_005fWORD"><span class="category-def">Macro: </span><span><strong class="def-name">MIN_UNITS_PER_WORD</strong><a class="copiable-link" href="#index-MIN_005fUNITS_005fPER_005fWORD"> &para;</a></span></dt>
<dd><p>Minimum number of units in a word.  If this is undefined, the default is
<code class="code">UNITS_PER_WORD</code>.  Otherwise, it is the constant value that is the
smallest value that <code class="code">UNITS_PER_WORD</code> can have at run-time.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-POINTER_005fSIZE"><span class="category-def">Macro: </span><span><strong class="def-name">POINTER_SIZE</strong><a class="copiable-link" href="#index-POINTER_005fSIZE"> &para;</a></span></dt>
<dd><p>Width of a pointer, in bits.  You must specify a value no wider than the
width of <code class="code">Pmode</code>.  If it is not equal to the width of <code class="code">Pmode</code>,
you must define <code class="code">POINTERS_EXTEND_UNSIGNED</code>.  If you do not specify
a value the default is <code class="code">BITS_PER_WORD</code>.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-POINTERS_005fEXTEND_005fUNSIGNED"><span class="category-def">Macro: </span><span><strong class="def-name">POINTERS_EXTEND_UNSIGNED</strong><a class="copiable-link" href="#index-POINTERS_005fEXTEND_005fUNSIGNED"> &para;</a></span></dt>
<dd><p>A C expression that determines how pointers should be extended from
<code class="code">ptr_mode</code> to either <code class="code">Pmode</code> or <code class="code">word_mode</code>.  It is
greater than zero if pointers should be zero-extended, zero if they
should be sign-extended, and negative if some other sort of conversion
is needed.  In the last case, the extension is done by the target&rsquo;s
<code class="code">ptr_extend</code> instruction.
</p>
<p>You need not define this macro if the <code class="code">ptr_mode</code>, <code class="code">Pmode</code>
and <code class="code">word_mode</code> are all the same width.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-PROMOTE_005fMODE"><span class="category-def">Macro: </span><span><strong class="def-name">PROMOTE_MODE</strong> <var class="def-var-arguments">(<var class="var">m</var>, <var class="var">unsignedp</var>, <var class="var">type</var>)</var><a class="copiable-link" href="#index-PROMOTE_005fMODE"> &para;</a></span></dt>
<dd><p>A macro to update <var class="var">m</var> and <var class="var">unsignedp</var> when an object whose type
is <var class="var">type</var> and which has the specified mode and signedness is to be
stored in a register.  This macro is only called when <var class="var">type</var> is a
scalar type.
</p>
<p>On most RISC machines, which only have operations that operate on a full
register, define this macro to set <var class="var">m</var> to <code class="code">word_mode</code> if
<var class="var">m</var> is an integer mode narrower than <code class="code">BITS_PER_WORD</code>.  In most
cases, only integer modes should be widened because wider-precision
floating-point operations are usually more expensive than their narrower
counterparts.
</p>
<p>For most machines, the macro definition does not change <var class="var">unsignedp</var>.
However, some machines, have instructions that preferentially handle
either signed or unsigned quantities of certain modes.  For example, on
the DEC Alpha, 32-bit loads from memory and 32-bit add instructions
sign-extend the result to 64 bits.  On such machines, set
<var class="var">unsignedp</var> according to which kind of extension is more efficient.
</p>
<p>Do not define this macro if it would never modify <var class="var">m</var>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fC_005fEXCESS_005fPRECISION"><span class="category-def">Target Hook: </span><span><code class="def-type">enum flt_eval_method</code> <strong class="def-name">TARGET_C_EXCESS_PRECISION</strong> <code class="def-code-arguments">(enum excess_precision_type <var class="var">type</var>)</code><a class="copiable-link" href="#index-TARGET_005fC_005fEXCESS_005fPRECISION"> &para;</a></span></dt>
<dd><p>Return a value, with the same meaning as the C99 macro
<code class="code">FLT_EVAL_METHOD</code> that describes which excess precision should be
applied.  <var class="var">type</var> is either <code class="code">EXCESS_PRECISION_TYPE_IMPLICIT</code>,
<code class="code">EXCESS_PRECISION_TYPE_FAST</code>,
<code class="code">EXCESS_PRECISION_TYPE_STANDARD</code>, or
<code class="code">EXCESS_PRECISION_TYPE_FLOAT16</code>.  For
<code class="code">EXCESS_PRECISION_TYPE_IMPLICIT</code>, the target should return which
precision and range operations will be implictly evaluated in regardless
of the excess precision explicitly added.  For
<code class="code">EXCESS_PRECISION_TYPE_STANDARD</code>, 
<code class="code">EXCESS_PRECISION_TYPE_FLOAT16</code>, and
<code class="code">EXCESS_PRECISION_TYPE_FAST</code>, the target should return the
explicit excess precision that should be added depending on the
value set for <samp class="option">-fexcess-precision=<span class="r">[</span>standard<span class="r">|</span>fast<span class="r">|</span>16<span class="r">]</span></samp>.
Note that unpredictable explicit excess precision does not make sense,
so a target should never return <code class="code">FLT_EVAL_METHOD_UNPREDICTABLE</code>
when <var class="var">type</var> is <code class="code">EXCESS_PRECISION_TYPE_STANDARD</code>,
<code class="code">EXCESS_PRECISION_TYPE_FLOAT16</code> or
<code class="code">EXCESS_PRECISION_TYPE_FAST</code>.
</p></dd></dl>
<p>Return a value, with the same meaning as the C99 macro
<code class="code">FLT_EVAL_METHOD</code> that describes which excess precision should be
applied.
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fC_005fBITINT_005fTYPE_005fINFO"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_C_BITINT_TYPE_INFO</strong> <code class="def-code-arguments">(int <var class="var">n</var>, struct bitint_info *<var class="var">info</var>)</code><a class="copiable-link" href="#index-TARGET_005fC_005fBITINT_005fTYPE_005fINFO"> &para;</a></span></dt>
<dd><p>This target hook returns true if <code class="code">_BitInt(<var class="var">N</var>)</code> is supported and
provides details on it.  <code class="code">_BitInt(<var class="var">N</var>)</code> is to be represented as
series of <code class="code">info-&gt;abi_limb_mode</code>
<code class="code">CEIL (<var class="var">N</var>, GET_MODE_PRECISION (info-&gt;abi_limb_mode))</code> limbs,
ordered from least significant to most significant if
<code class="code">!info-&gt;big_endian</code>, otherwise from most significant to least
significant.  If <code class="code">info-&gt;extended</code> is false, the bits above or equal to
<var class="var">N</var> are undefined when stored in a register or memory, otherwise they
are zero or sign extended depending on if it is
<code class="code">unsigned _BitInt(<var class="var">N</var>)</code> or one of <code class="code">_BitInt(<var class="var">N</var>)</code> or
<code class="code">signed _BitInt(<var class="var">N</var>)</code>.  Alignment of the type is
<code class="code">GET_MODE_ALIGNMENT (info-&gt;limb_mode)</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fC_005fMODE_005fFOR_005fFLOATING_005fTYPE"><span class="category-def">Target Hook: </span><span><code class="def-type">machine_mode</code> <strong class="def-name">TARGET_C_MODE_FOR_FLOATING_TYPE</strong> <code class="def-code-arguments">(enum tree_index <var class="var">ti</var>)</code><a class="copiable-link" href="#index-TARGET_005fC_005fMODE_005fFOR_005fFLOATING_005fTYPE"> &para;</a></span></dt>
<dd><p>Return machine mode for a C floating point type which is indicated by
 a given <code class="code">enum tree_index</code> <var class="var">ti</var>, <var class="var">ti</var> should be
 <code class="code">TI_FLOAT_TYPE</code>, <code class="code">TI_DOUBLE_TYPE</code> or <code class="code">TI_LONG_DOUBLE_TYPE</code>.
 The default implementation returns <code class="code">SFmode</code> for <code class="code">TI_FLOAT_TYPE</code>,
 and <code class="code">DFmode</code> for <code class="code">TI_DOUBLE_TYPE</code> or <code class="code">TI_LONG_DOUBLE_TYPE</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fPROMOTE_005fFUNCTION_005fMODE"><span class="category-def">Target Hook: </span><span><code class="def-type">machine_mode</code> <strong class="def-name">TARGET_PROMOTE_FUNCTION_MODE</strong> <code class="def-code-arguments">(const_tree <var class="var">type</var>, machine_mode <var class="var">mode</var>, int *<var class="var">punsignedp</var>, const_tree <var class="var">funtype</var>, int <var class="var">for_return</var>)</code><a class="copiable-link" href="#index-TARGET_005fPROMOTE_005fFUNCTION_005fMODE"> &para;</a></span></dt>
<dd><p>Like <code class="code">PROMOTE_MODE</code>, but it is applied to outgoing function arguments or
function return values.  The target hook should return the new mode
and possibly change <code class="code">*<var class="var">punsignedp</var></code> if the promotion should
change signedness.  This function is called only for scalar <em class="emph">or
pointer</em> types.
</p>
<p><var class="var">for_return</var> allows to distinguish the promotion of arguments and
return values.  If it is <code class="code">1</code>, a return value is being promoted and
<code class="code">TARGET_FUNCTION_VALUE</code> must perform the same promotions done here.
If it is <code class="code">2</code>, the returned mode should be that of the register in
which an incoming parameter is copied, or the outgoing result is computed;
then the hook should return the same mode as <code class="code">promote_mode</code>, though
the signedness may be different.
</p>
<p><var class="var">type</var> can be NULL when promoting function arguments of libcalls.
</p>
<p>The default is to not promote arguments and return values.  You can
also define the hook to <code class="code">default_promote_function_mode_always_promote</code>
if you would like to apply the same rules given by <code class="code">PROMOTE_MODE</code>.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-PARM_005fBOUNDARY"><span class="category-def">Macro: </span><span><strong class="def-name">PARM_BOUNDARY</strong><a class="copiable-link" href="#index-PARM_005fBOUNDARY"> &para;</a></span></dt>
<dd><p>Normal alignment required for function parameters on the stack, in
bits.  All stack parameters receive at least this much alignment
regardless of data type.  On most machines, this is the same as the
size of an integer.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-STACK_005fBOUNDARY"><span class="category-def">Macro: </span><span><strong class="def-name">STACK_BOUNDARY</strong><a class="copiable-link" href="#index-STACK_005fBOUNDARY"> &para;</a></span></dt>
<dd><p>Define this macro to the minimum alignment enforced by hardware for the
stack pointer on this machine.  The definition is a C expression for the
desired alignment (measured in bits).  This value is used as a default
if <code class="code">PREFERRED_STACK_BOUNDARY</code> is not defined.  On most machines,
this should be the same as <code class="code">PARM_BOUNDARY</code>.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-PREFERRED_005fSTACK_005fBOUNDARY"><span class="category-def">Macro: </span><span><strong class="def-name">PREFERRED_STACK_BOUNDARY</strong><a class="copiable-link" href="#index-PREFERRED_005fSTACK_005fBOUNDARY"> &para;</a></span></dt>
<dd><p>Define this macro if you wish to preserve a certain alignment for the
stack pointer, greater than what the hardware enforces.  The definition
is a C expression for the desired alignment (measured in bits).  This
macro must evaluate to a value equal to or larger than
<code class="code">STACK_BOUNDARY</code>.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-INCOMING_005fSTACK_005fBOUNDARY"><span class="category-def">Macro: </span><span><strong class="def-name">INCOMING_STACK_BOUNDARY</strong><a class="copiable-link" href="#index-INCOMING_005fSTACK_005fBOUNDARY"> &para;</a></span></dt>
<dd><p>Define this macro if the incoming stack boundary may be different
from <code class="code">PREFERRED_STACK_BOUNDARY</code>.  This macro must evaluate
to a value equal to or larger than <code class="code">STACK_BOUNDARY</code>.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-FUNCTION_005fBOUNDARY"><span class="category-def">Macro: </span><span><strong class="def-name">FUNCTION_BOUNDARY</strong><a class="copiable-link" href="#index-FUNCTION_005fBOUNDARY"> &para;</a></span></dt>
<dd><p>Alignment required for a function entry point, in bits.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-BIGGEST_005fALIGNMENT"><span class="category-def">Macro: </span><span><strong class="def-name">BIGGEST_ALIGNMENT</strong><a class="copiable-link" href="#index-BIGGEST_005fALIGNMENT"> &para;</a></span></dt>
<dd><p>Biggest alignment that any data type can require on this machine, in
bits.  Note that this is not the biggest alignment that is supported,
just the biggest alignment that, when violated, may cause a fault.
</p></dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-TARGET_005fABSOLUTE_005fBIGGEST_005fALIGNMENT"><span class="category-def">Target Hook: </span><span><code class="def-type">HOST_WIDE_INT</code> <strong class="def-name">TARGET_ABSOLUTE_BIGGEST_ALIGNMENT</strong><a class="copiable-link" href="#index-TARGET_005fABSOLUTE_005fBIGGEST_005fALIGNMENT"> &para;</a></span></dt>
<dd><p>If defined, this target hook specifies the absolute biggest alignment
that a type or variable can have on this machine, otherwise,
<code class="code">BIGGEST_ALIGNMENT</code> is used.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-MALLOC_005fABI_005fALIGNMENT"><span class="category-def">Macro: </span><span><strong class="def-name">MALLOC_ABI_ALIGNMENT</strong><a class="copiable-link" href="#index-MALLOC_005fABI_005fALIGNMENT"> &para;</a></span></dt>
<dd><p>Alignment, in bits, a C conformant malloc implementation has to
provide.  If not defined, the default value is <code class="code">BITS_PER_WORD</code>.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-ATTRIBUTE_005fALIGNED_005fVALUE"><span class="category-def">Macro: </span><span><strong class="def-name">ATTRIBUTE_ALIGNED_VALUE</strong><a class="copiable-link" href="#index-ATTRIBUTE_005fALIGNED_005fVALUE"> &para;</a></span></dt>
<dd><p>Alignment used by the <code class="code">__attribute__ ((aligned))</code> construct.  If
not defined, the default value is <code class="code">BIGGEST_ALIGNMENT</code>.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-MINIMUM_005fATOMIC_005fALIGNMENT"><span class="category-def">Macro: </span><span><strong class="def-name">MINIMUM_ATOMIC_ALIGNMENT</strong><a class="copiable-link" href="#index-MINIMUM_005fATOMIC_005fALIGNMENT"> &para;</a></span></dt>
<dd><p>If defined, the smallest alignment, in bits, that can be given to an
object that can be referenced in one operation, without disturbing any
nearby object.  Normally, this is <code class="code">BITS_PER_UNIT</code>, but may be larger
on machines that don&rsquo;t have byte or half-word store operations.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-BIGGEST_005fFIELD_005fALIGNMENT"><span class="category-def">Macro: </span><span><strong class="def-name">BIGGEST_FIELD_ALIGNMENT</strong><a class="copiable-link" href="#index-BIGGEST_005fFIELD_005fALIGNMENT"> &para;</a></span></dt>
<dd><p>Biggest alignment that any structure or union field can require on this
machine, in bits.  If defined, this overrides <code class="code">BIGGEST_ALIGNMENT</code> for
structure and union fields only, unless the field alignment has been set
by the <code class="code">__attribute__ ((aligned (<var class="var">n</var>)))</code> construct.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-ADJUST_005fFIELD_005fALIGN"><span class="category-def">Macro: </span><span><strong class="def-name">ADJUST_FIELD_ALIGN</strong> <var class="def-var-arguments">(<var class="var">field</var>, <var class="var">type</var>, <var class="var">computed</var>)</var><a class="copiable-link" href="#index-ADJUST_005fFIELD_005fALIGN"> &para;</a></span></dt>
<dd><p>An expression for the alignment of a structure field <var class="var">field</var> of
type <var class="var">type</var> if the alignment computed in the usual way (including
applying of <code class="code">BIGGEST_ALIGNMENT</code> and <code class="code">BIGGEST_FIELD_ALIGNMENT</code> to the
alignment) is <var class="var">computed</var>.  It overrides alignment only if the
field alignment has not been set by the
<code class="code">__attribute__ ((aligned (<var class="var">n</var>)))</code> construct.  Note that <var class="var">field</var>
may be <code class="code">NULL_TREE</code> in case we just query for the minimum alignment
of a field of type <var class="var">type</var> in structure context.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-MAX_005fSTACK_005fALIGNMENT"><span class="category-def">Macro: </span><span><strong class="def-name">MAX_STACK_ALIGNMENT</strong><a class="copiable-link" href="#index-MAX_005fSTACK_005fALIGNMENT"> &para;</a></span></dt>
<dd><p>Biggest stack alignment guaranteed by the backend.  Use this macro
to specify the maximum alignment of a variable on stack.
</p>
<p>If not defined, the default value is <code class="code">STACK_BOUNDARY</code>.
</p>
</dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-MAX_005fOFILE_005fALIGNMENT"><span class="category-def">Macro: </span><span><strong class="def-name">MAX_OFILE_ALIGNMENT</strong><a class="copiable-link" href="#index-MAX_005fOFILE_005fALIGNMENT"> &para;</a></span></dt>
<dd><p>Biggest alignment supported by the object file format of this machine.
Use this macro to limit the alignment which can be specified using the
<code class="code">__attribute__ ((aligned (<var class="var">n</var>)))</code> construct for functions and
objects with static storage duration.  The alignment of automatic
objects may exceed the object file format maximum up to the maximum
supported by GCC.  If not defined, the default value is
<code class="code">BIGGEST_ALIGNMENT</code>.
</p>
<p>On systems that use ELF, the default (in <samp class="file">config/elfos.h</samp>) is
the largest supported 32-bit ELF section alignment representable on
a 32-bit host e.g. &lsquo;<samp class="samp">(((uint64_t) 1 &lt;&lt; 28) * 8)</samp>&rsquo;.
On 32-bit ELF the largest supported section alignment in bits is
&lsquo;<samp class="samp">(0x80000000 * 8)</samp>&rsquo;, but this is not representable on 32-bit hosts.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fLOWER_005fLOCAL_005fDECL_005fALIGNMENT"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_LOWER_LOCAL_DECL_ALIGNMENT</strong> <code class="def-code-arguments">(tree <var class="var">decl</var>)</code><a class="copiable-link" href="#index-TARGET_005fLOWER_005fLOCAL_005fDECL_005fALIGNMENT"> &para;</a></span></dt>
<dd><p>Define this hook to lower alignment of local, parm or result
decl &lsquo;<samp class="samp">(<var class="var">decl</var>)</samp>&rsquo;.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fSTATIC_005fRTX_005fALIGNMENT"><span class="category-def">Target Hook: </span><span><code class="def-type">HOST_WIDE_INT</code> <strong class="def-name">TARGET_STATIC_RTX_ALIGNMENT</strong> <code class="def-code-arguments">(machine_mode <var class="var">mode</var>)</code><a class="copiable-link" href="#index-TARGET_005fSTATIC_005fRTX_005fALIGNMENT"> &para;</a></span></dt>
<dd><p>This hook returns the preferred alignment in bits for a
statically-allocated rtx, such as a constant pool entry.  <var class="var">mode</var>
is the mode of the rtx.  The default implementation returns
&lsquo;<samp class="samp">GET_MODE_ALIGNMENT (<var class="var">mode</var>)</samp>&rsquo;.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-DATA_005fALIGNMENT"><span class="category-def">Macro: </span><span><strong class="def-name">DATA_ALIGNMENT</strong> <var class="def-var-arguments">(<var class="var">type</var>, <var class="var">basic-align</var>)</var><a class="copiable-link" href="#index-DATA_005fALIGNMENT"> &para;</a></span></dt>
<dd><p>If defined, a C expression to compute the alignment for a variable in
the static store.  <var class="var">type</var> is the data type, and <var class="var">basic-align</var> is
the alignment that the object would ordinarily have.  The value of this
macro is used instead of that alignment to align the object.
</p>
<p>If this macro is not defined, then <var class="var">basic-align</var> is used.
</p>
<a class="index-entry-id" id="index-strcpy"></a>
<p>One use of this macro is to increase alignment of medium-size data to
make it all fit in fewer cache lines.  Another is to cause character
arrays to be word-aligned so that <code class="code">strcpy</code> calls that copy
constants to character arrays can be done inline.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-DATA_005fABI_005fALIGNMENT"><span class="category-def">Macro: </span><span><strong class="def-name">DATA_ABI_ALIGNMENT</strong> <var class="def-var-arguments">(<var class="var">type</var>, <var class="var">basic-align</var>)</var><a class="copiable-link" href="#index-DATA_005fABI_005fALIGNMENT"> &para;</a></span></dt>
<dd><p>Similar to <code class="code">DATA_ALIGNMENT</code>, but for the cases where the ABI mandates
some alignment increase, instead of optimization only purposes.  E.g.&nbsp;AMD x86-64 psABI says that variables with array type larger than 15 bytes
must be aligned to 16 byte boundaries.
</p>
<p>If this macro is not defined, then <var class="var">basic-align</var> is used.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fCONSTANT_005fALIGNMENT"><span class="category-def">Target Hook: </span><span><code class="def-type">HOST_WIDE_INT</code> <strong class="def-name">TARGET_CONSTANT_ALIGNMENT</strong> <code class="def-code-arguments">(const_tree <var class="var">constant</var>, HOST_WIDE_INT <var class="var">basic_align</var>)</code><a class="copiable-link" href="#index-TARGET_005fCONSTANT_005fALIGNMENT"> &para;</a></span></dt>
<dd><p>This hook returns the alignment in bits of a constant that is being
placed in memory.  <var class="var">constant</var> is the constant and <var class="var">basic_align</var>
is the alignment that the object would ordinarily have.
</p>
<p>The default definition just returns <var class="var">basic_align</var>.
</p>
<p>The typical use of this hook is to increase alignment for string
constants to be word aligned so that <code class="code">strcpy</code> calls that copy
constants can be done inline.  The function
<code class="code">constant_alignment_word_strings</code> provides such a definition.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-LOCAL_005fALIGNMENT"><span class="category-def">Macro: </span><span><strong class="def-name">LOCAL_ALIGNMENT</strong> <var class="def-var-arguments">(<var class="var">type</var>, <var class="var">basic-align</var>)</var><a class="copiable-link" href="#index-LOCAL_005fALIGNMENT"> &para;</a></span></dt>
<dd><p>If defined, a C expression to compute the alignment for a variable in
the local store.  <var class="var">type</var> is the data type, and <var class="var">basic-align</var> is
the alignment that the object would ordinarily have.  The value of this
macro is used instead of that alignment to align the object.
</p>
<p>If this macro is not defined, then <var class="var">basic-align</var> is used.
</p>
<p>One use of this macro is to increase alignment of medium-size data to
make it all fit in fewer cache lines.
</p>
<p>If the value of this macro has a type, it should be an unsigned type.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fVECTOR_005fALIGNMENT"><span class="category-def">Target Hook: </span><span><code class="def-type">HOST_WIDE_INT</code> <strong class="def-name">TARGET_VECTOR_ALIGNMENT</strong> <code class="def-code-arguments">(const_tree <var class="var">type</var>)</code><a class="copiable-link" href="#index-TARGET_005fVECTOR_005fALIGNMENT"> &para;</a></span></dt>
<dd><p>This hook can be used to define the alignment for a vector of type
<var class="var">type</var>, in order to comply with a platform ABI.  The default is to
require natural alignment for vector types.  The alignment returned by
this hook must be a power-of-two multiple of the default alignment of
the vector element type.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-STACK_005fSLOT_005fALIGNMENT"><span class="category-def">Macro: </span><span><strong class="def-name">STACK_SLOT_ALIGNMENT</strong> <var class="def-var-arguments">(<var class="var">type</var>, <var class="var">mode</var>, <var class="var">basic-align</var>)</var><a class="copiable-link" href="#index-STACK_005fSLOT_005fALIGNMENT"> &para;</a></span></dt>
<dd><p>If defined, a C expression to compute the alignment for stack slot.
<var class="var">type</var> is the data type, <var class="var">mode</var> is the widest mode available,
and <var class="var">basic-align</var> is the alignment that the slot would ordinarily
have.  The value of this macro is used instead of that alignment to
align the slot.
</p>
<p>If this macro is not defined, then <var class="var">basic-align</var> is used when
<var class="var">type</var> is <code class="code">NULL</code>.  Otherwise, <code class="code">LOCAL_ALIGNMENT</code> will
be used.
</p>
<p>This macro is to set alignment of stack slot to the maximum alignment
of all possible modes which the slot may have.
</p>
<p>If the value of this macro has a type, it should be an unsigned type.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-LOCAL_005fDECL_005fALIGNMENT"><span class="category-def">Macro: </span><span><strong class="def-name">LOCAL_DECL_ALIGNMENT</strong> <var class="def-var-arguments">(<var class="var">decl</var>)</var><a class="copiable-link" href="#index-LOCAL_005fDECL_005fALIGNMENT"> &para;</a></span></dt>
<dd><p>If defined, a C expression to compute the alignment for a local
variable <var class="var">decl</var>.
</p>
<p>If this macro is not defined, then
<code class="code">LOCAL_ALIGNMENT (TREE_TYPE (<var class="var">decl</var>), DECL_ALIGN (<var class="var">decl</var>))</code>
is used.
</p>
<p>One use of this macro is to increase alignment of medium-size data to
make it all fit in fewer cache lines.
</p>
<p>If the value of this macro has a type, it should be an unsigned type.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-MINIMUM_005fALIGNMENT"><span class="category-def">Macro: </span><span><strong class="def-name">MINIMUM_ALIGNMENT</strong> <var class="def-var-arguments">(<var class="var">exp</var>, <var class="var">mode</var>, <var class="var">align</var>)</var><a class="copiable-link" href="#index-MINIMUM_005fALIGNMENT"> &para;</a></span></dt>
<dd><p>If defined, a C expression to compute the minimum required alignment
for dynamic stack realignment purposes for <var class="var">exp</var> (a type or decl),
<var class="var">mode</var>, assuming normal alignment <var class="var">align</var>.
</p>
<p>If this macro is not defined, then <var class="var">align</var> will be used.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-EMPTY_005fFIELD_005fBOUNDARY"><span class="category-def">Macro: </span><span><strong class="def-name">EMPTY_FIELD_BOUNDARY</strong><a class="copiable-link" href="#index-EMPTY_005fFIELD_005fBOUNDARY"> &para;</a></span></dt>
<dd><p>Alignment in bits to be given to a structure bit-field that follows an
empty field such as <code class="code">int : 0;</code>.
</p>
<p>If <code class="code">PCC_BITFIELD_TYPE_MATTERS</code> is true, it overrides this macro.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-STRUCTURE_005fSIZE_005fBOUNDARY"><span class="category-def">Macro: </span><span><strong class="def-name">STRUCTURE_SIZE_BOUNDARY</strong><a class="copiable-link" href="#index-STRUCTURE_005fSIZE_005fBOUNDARY"> &para;</a></span></dt>
<dd><p>Number of bits which any structure or union&rsquo;s size must be a multiple of.
Each structure or union&rsquo;s size is rounded up to a multiple of this.
</p>
<p>If you do not define this macro, the default is the same as
<code class="code">BITS_PER_UNIT</code>.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-STRICT_005fALIGNMENT"><span class="category-def">Macro: </span><span><strong class="def-name">STRICT_ALIGNMENT</strong><a class="copiable-link" href="#index-STRICT_005fALIGNMENT"> &para;</a></span></dt>
<dd><p>Define this macro to be the value 1 if instructions will fail to work
if given data not on the nominal alignment.  If instructions will merely
go slower in that case, define this macro as 0.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-PCC_005fBITFIELD_005fTYPE_005fMATTERS"><span class="category-def">Macro: </span><span><strong class="def-name">PCC_BITFIELD_TYPE_MATTERS</strong><a class="copiable-link" href="#index-PCC_005fBITFIELD_005fTYPE_005fMATTERS"> &para;</a></span></dt>
<dd><p>Define this if you wish to imitate the way many other C compilers handle
alignment of bit-fields and the structures that contain them.
</p>
<p>The behavior is that the type written for a named bit-field (<code class="code">int</code>,
<code class="code">short</code>, or other integer type) imposes an alignment for the entire
structure, as if the structure really did contain an ordinary field of
that type.  In addition, the bit-field is placed within the structure so
that it would fit within such a field, not crossing a boundary for it.
</p>
<p>Thus, on most machines, a named bit-field whose type is written as
<code class="code">int</code> would not cross a four-byte boundary, and would force
four-byte alignment for the whole structure.  (The alignment used may
not be four bytes; it is controlled by the other alignment parameters.)
</p>
<p>An unnamed bit-field will not affect the alignment of the containing
structure.
</p>
<p>If the macro is defined, its definition should be a C expression;
a nonzero value for the expression enables this behavior.
</p>
<p>Note that if this macro is not defined, or its value is zero, some
bit-fields may cross more than one alignment boundary.  The compiler can
support such references if there are &lsquo;<samp class="samp">insv</samp>&rsquo;, &lsquo;<samp class="samp">extv</samp>&rsquo;, and
&lsquo;<samp class="samp">extzv</samp>&rsquo; insns that can directly reference memory.
</p>
<p>The other known way of making bit-fields work is to define
<code class="code">STRUCTURE_SIZE_BOUNDARY</code> as large as <code class="code">BIGGEST_ALIGNMENT</code>.
Then every structure can be accessed with fullwords.
</p>
<p>Unless the machine has bit-field instructions or you define
<code class="code">STRUCTURE_SIZE_BOUNDARY</code> that way, you must define
<code class="code">PCC_BITFIELD_TYPE_MATTERS</code> to have a nonzero value.
</p>
<p>If your aim is to make GCC use the same conventions for laying out
bit-fields as are used by another compiler, here is how to investigate
what the other compiler does.  Compile and run this program:
</p>
<div class="example smallexample">
<pre class="example-preformatted">struct foo1
{
  char x;
  char :0;
  char y;
};

struct foo2
{
  char x;
  int :0;
  char y;
};

main ()
{
  printf (&quot;Size of foo1 is %d\n&quot;,
          sizeof (struct foo1));
  printf (&quot;Size of foo2 is %d\n&quot;,
          sizeof (struct foo2));
  exit (0);
}
</pre></div>

<p>If this prints 2 and 5, then the compiler&rsquo;s behavior is what you would
get from <code class="code">PCC_BITFIELD_TYPE_MATTERS</code>.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-BITFIELD_005fNBYTES_005fLIMITED"><span class="category-def">Macro: </span><span><strong class="def-name">BITFIELD_NBYTES_LIMITED</strong><a class="copiable-link" href="#index-BITFIELD_005fNBYTES_005fLIMITED"> &para;</a></span></dt>
<dd><p>Like <code class="code">PCC_BITFIELD_TYPE_MATTERS</code> except that its effect is limited
to aligning a bit-field within the structure.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fALIGN_005fANON_005fBITFIELD"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_ALIGN_ANON_BITFIELD</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fALIGN_005fANON_005fBITFIELD"> &para;</a></span></dt>
<dd><p>When <code class="code">PCC_BITFIELD_TYPE_MATTERS</code> is true this hook will determine
whether unnamed bitfields affect the alignment of the containing
structure.  The hook should return true if the structure should inherit
the alignment requirements of an unnamed bitfield&rsquo;s type.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fNARROW_005fVOLATILE_005fBITFIELD"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_NARROW_VOLATILE_BITFIELD</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fNARROW_005fVOLATILE_005fBITFIELD"> &para;</a></span></dt>
<dd><p>This target hook should return <code class="code">true</code> if accesses to volatile bitfields
should use the narrowest mode possible.  It should return <code class="code">false</code> if
these accesses should use the bitfield container type.
</p>
<p>The default is <code class="code">false</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fMEMBER_005fTYPE_005fFORCES_005fBLK"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_MEMBER_TYPE_FORCES_BLK</strong> <code class="def-code-arguments">(const_tree <var class="var">field</var>, machine_mode <var class="var">mode</var>)</code><a class="copiable-link" href="#index-TARGET_005fMEMBER_005fTYPE_005fFORCES_005fBLK"> &para;</a></span></dt>
<dd><p>Return true if a structure, union or array containing <var class="var">field</var> should
be accessed using <code class="code">BLKMODE</code>.
</p>
<p>If <var class="var">field</var> is the only field in the structure, <var class="var">mode</var> is its
mode, otherwise <var class="var">mode</var> is VOIDmode.  <var class="var">mode</var> is provided in the
case where structures of one field would require the structure&rsquo;s mode to
retain the field&rsquo;s mode.
</p>
<p>Normally, this is not needed.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-ROUND_005fTYPE_005fALIGN"><span class="category-def">Macro: </span><span><strong class="def-name">ROUND_TYPE_ALIGN</strong> <var class="def-var-arguments">(<var class="var">type</var>, <var class="var">computed</var>, <var class="var">specified</var>)</var><a class="copiable-link" href="#index-ROUND_005fTYPE_005fALIGN"> &para;</a></span></dt>
<dd><p>Define this macro as an expression for the alignment of a type (given
by <var class="var">type</var> as a tree node) if the alignment computed in the usual
way is <var class="var">computed</var> and the alignment explicitly specified was
<var class="var">specified</var>.
</p>
<p>The default is to use <var class="var">specified</var> if it is larger; otherwise, use
the smaller of <var class="var">computed</var> and <code class="code">BIGGEST_ALIGNMENT</code>
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-MAX_005fFIXED_005fMODE_005fSIZE"><span class="category-def">Macro: </span><span><strong class="def-name">MAX_FIXED_MODE_SIZE</strong><a class="copiable-link" href="#index-MAX_005fFIXED_005fMODE_005fSIZE"> &para;</a></span></dt>
<dd><p>An integer expression for the size in bits of the largest integer
machine mode that should actually be used.  All integer machine modes of
this size or smaller can be used for structures and unions with the
appropriate sizes.  If this macro is undefined, <code class="code">GET_MODE_BITSIZE
(DImode)</code> is assumed.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-STACK_005fSAVEAREA_005fMODE"><span class="category-def">Macro: </span><span><strong class="def-name">STACK_SAVEAREA_MODE</strong> <var class="def-var-arguments">(<var class="var">save_level</var>)</var><a class="copiable-link" href="#index-STACK_005fSAVEAREA_005fMODE"> &para;</a></span></dt>
<dd><p>If defined, an expression of type <code class="code">machine_mode</code> that
specifies the mode of the save area operand of a
<code class="code">save_stack_<var class="var">level</var></code> named pattern (see <a class="pxref" href="Standard-Names.html">Standard Pattern Names For Generation</a>).
<var class="var">save_level</var> is one of <code class="code">SAVE_BLOCK</code>, <code class="code">SAVE_FUNCTION</code>, or
<code class="code">SAVE_NONLOCAL</code> and selects which of the three named patterns is
having its mode specified.
</p>
<p>You need not define this macro if it always returns <code class="code">Pmode</code>.  You
would most commonly define this macro if the
<code class="code">save_stack_<var class="var">level</var></code> patterns need to support both a 32- and a
64-bit mode.
</p></dd></dl>

<dl class="first-deffn first-defmac-alias-first-deffn">
<dt class="deffn defmac-alias-deffn" id="index-STACK_005fSIZE_005fMODE"><span class="category-def">Macro: </span><span><strong class="def-name">STACK_SIZE_MODE</strong><a class="copiable-link" href="#index-STACK_005fSIZE_005fMODE"> &para;</a></span></dt>
<dd><p>If defined, an expression of type <code class="code">machine_mode</code> that
specifies the mode of the size increment operand of an
<code class="code">allocate_stack</code> named pattern (see <a class="pxref" href="Standard-Names.html">Standard Pattern Names For Generation</a>).
</p>
<p>You need not define this macro if it always returns <code class="code">word_mode</code>.
You would most commonly define this macro if the <code class="code">allocate_stack</code>
pattern needs to support both a 32- and a 64-bit mode.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fLIBGCC_005fCMP_005fRETURN_005fMODE"><span class="category-def">Target Hook: </span><span><code class="def-type">scalar_int_mode</code> <strong class="def-name">TARGET_LIBGCC_CMP_RETURN_MODE</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fLIBGCC_005fCMP_005fRETURN_005fMODE"> &para;</a></span></dt>
<dd><p>This target hook should return the mode to be used for the return value
of compare instructions expanded to libgcc calls.  If not defined
<code class="code">word_mode</code> is returned which is the right choice for a majority of
targets.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fLIBGCC_005fSHIFT_005fCOUNT_005fMODE"><span class="category-def">Target Hook: </span><span><code class="def-type">scalar_int_mode</code> <strong class="def-name">TARGET_LIBGCC_SHIFT_COUNT_MODE</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fLIBGCC_005fSHIFT_005fCOUNT_005fMODE"> &para;</a></span></dt>
<dd><p>This target hook should return the mode to be used for the shift count operand
of shift instructions expanded to libgcc calls.  If not defined
<code class="code">word_mode</code> is returned which is the right choice for a majority of
targets.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fUNWIND_005fWORD_005fMODE"><span class="category-def">Target Hook: </span><span><code class="def-type">scalar_int_mode</code> <strong class="def-name">TARGET_UNWIND_WORD_MODE</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fUNWIND_005fWORD_005fMODE"> &para;</a></span></dt>
<dd><p>Return machine mode to be used for <code class="code">_Unwind_Word</code> type.
The default is to use <code class="code">word_mode</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fMS_005fBITFIELD_005fLAYOUT_005fP"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_MS_BITFIELD_LAYOUT_P</strong> <code class="def-code-arguments">(const_tree <var class="var">record_type</var>)</code><a class="copiable-link" href="#index-TARGET_005fMS_005fBITFIELD_005fLAYOUT_005fP"> &para;</a></span></dt>
<dd><p>This target hook returns <code class="code">true</code> if bit-fields in the given
<var class="var">record_type</var> are to be laid out following the rules of Microsoft
Visual C/C++, namely: (i) a bit-field won&rsquo;t share the same storage
unit with the previous bit-field if their underlying types have
different sizes, and the bit-field will be aligned to the highest
alignment of the underlying types of itself and of the previous
bit-field; (ii) a zero-sized bit-field will affect the alignment of
the whole enclosing structure, even if it is unnamed; except that
(iii) a zero-sized bit-field will be disregarded unless it follows
another bit-field of nonzero size.  If this hook returns <code class="code">true</code>,
other macros that control bit-field layout are ignored.
</p>
<p>When a bit-field is inserted into a packed record, the whole size
of the underlying type is used by one or more same-size adjacent
bit-fields (that is, if its long:3, 32 bits is used in the record,
and any additional adjacent long bit-fields are packed into the same
chunk of 32 bits.  However, if the size changes, a new field of that
size is allocated).  In an unpacked record, this is the same as using
alignment, but not equivalent when packing.
</p>
<p>If both MS bit-fields and &lsquo;<samp class="samp">__attribute__((packed))</samp>&rsquo; are used,
the latter will take precedence.  If &lsquo;<samp class="samp">__attribute__((packed))</samp>&rsquo; is
used on a single field when MS bit-fields are in use, it will take
precedence for that field, but the alignment of the rest of the structure
may affect its placement.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fDECIMAL_005fFLOAT_005fSUPPORTED_005fP"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_DECIMAL_FLOAT_SUPPORTED_P</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fDECIMAL_005fFLOAT_005fSUPPORTED_005fP"> &para;</a></span></dt>
<dd><p>Returns true if the target supports decimal floating point.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fFIXED_005fPOINT_005fSUPPORTED_005fP"><span class="category-def">Target Hook: </span><span><code class="def-type">bool</code> <strong class="def-name">TARGET_FIXED_POINT_SUPPORTED_P</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fFIXED_005fPOINT_005fSUPPORTED_005fP"> &para;</a></span></dt>
<dd><p>Returns true if the target supports fixed-point arithmetic.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fEXPAND_005fTO_005fRTL_005fHOOK"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_EXPAND_TO_RTL_HOOK</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fEXPAND_005fTO_005fRTL_005fHOOK"> &para;</a></span></dt>
<dd><p>This hook is called just before expansion into rtl, allowing the target
to perform additional initializations or analysis before the expansion.
For example, the rs6000 port uses it to allocate a scratch stack slot
for use in copying SDmode values between memory and floating point
registers whenever the function being expanded has any SDmode
usage.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fINSTANTIATE_005fDECLS"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_INSTANTIATE_DECLS</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="#index-TARGET_005fINSTANTIATE_005fDECLS"> &para;</a></span></dt>
<dd><p>This hook allows the backend to perform additional instantiations on rtl
that are not actually in any insns yet, but will be later.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fMANGLE_005fTYPE"><span class="category-def">Target Hook: </span><span><code class="def-type">const char *</code> <strong class="def-name">TARGET_MANGLE_TYPE</strong> <code class="def-code-arguments">(const_tree <var class="var">type</var>)</code><a class="copiable-link" href="#index-TARGET_005fMANGLE_005fTYPE"> &para;</a></span></dt>
<dd><p>If your target defines any fundamental types, or any types your target
uses should be mangled differently from the default, define this hook
to return the appropriate encoding for these types as part of a C++
mangled name.  The <var class="var">type</var> argument is the tree structure representing
the type to be mangled.  The hook may be applied to trees which are
not target-specific fundamental types; it should return <code class="code">NULL</code>
for all such types, as well as arguments it does not recognize.  If the
return value is not <code class="code">NULL</code>, it must point to a statically-allocated
string constant.
</p>
<p>Target-specific fundamental types might be new fundamental types or
qualified versions of ordinary fundamental types.  Encode new
fundamental types as &lsquo;<samp class="samp">u&nbsp;<var class="var">n</var>&nbsp;<var class="var">name</var><!-- /@w --></samp>&rsquo;, where <var class="var">name</var>
is the name used for the type in source code, and <var class="var">n</var> is the
length of <var class="var">name</var> in decimal.  Encode qualified versions of
ordinary types as &lsquo;<samp class="samp">U&nbsp;<var class="var">n</var>&nbsp;<var class="var">name</var>&nbsp;<var class="var">code</var><!-- /@w --></samp>&rsquo;, where
<var class="var">name</var> is the name used for the type qualifier in source code,
<var class="var">n</var> is the length of <var class="var">name</var> as above, and <var class="var">code</var> is the
code used to represent the unqualified version of this type.  (See
<code class="code">write_builtin_type</code> in <samp class="file">cp/mangle.cc</samp> for the list of
codes.)  In both cases the spaces are for clarity; do not include any
spaces in your string.
</p>
<p>This hook is applied to types prior to typedef resolution.  If the mangled
name for a particular type depends only on that type&rsquo;s main variant, you
can perform typedef resolution yourself using <code class="code">TYPE_MAIN_VARIANT</code>
before mangling.
</p>
<p>The default version of this hook always returns <code class="code">NULL</code>, which is
appropriate for a target that does not define any new fundamental
types.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-TARGET_005fEMIT_005fSUPPORT_005fTINFOS"><span class="category-def">Target Hook: </span><span><code class="def-type">void</code> <strong class="def-name">TARGET_EMIT_SUPPORT_TINFOS</strong> <code class="def-code-arguments">(emit_support_tinfos_callback <var class="var">callback</var>)</code><a class="copiable-link" href="#index-TARGET_005fEMIT_005fSUPPORT_005fTINFOS"> &para;</a></span></dt>
<dd><p>If your target defines any fundamental types which depend on ISA flags,
they might need C++ tinfo symbols in libsupc++/libstdc++ regardless of
ISA flags the library is compiled with.
This hook allows creating tinfo symbols even for those cases, by temporarily
creating each corresponding fundamental type trees, calling the
<var class="var">callback</var> function on it and setting the type back to <code class="code">nullptr</code>.
</p></dd></dl>

</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Type-Layout.html">Layout of Source Language Data Types</a>, Previous: <a href="Per_002dFunction-Data.html">Defining data structures for per-function information.</a>, Up: <a href="Target-Macros.html">Target Description Macros and Functions</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Option-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
